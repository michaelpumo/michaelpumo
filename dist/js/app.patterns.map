{"version":3,"sources":["webpack:///js/app.patterns.js","webpack:///./src/js/app.patterns.js","webpack:///./~/acorn/dist/acorn.es.js","webpack:///./src/js/modules/patterns/index.js","webpack:///./src/js/utilities/settings.js","webpack:///./~/paper/dist/paper-full.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_helpers","_patterns","app","init","confetti","background","domReady","__webpack_exports__","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","nonASCIIidentifierStart","test","String","fromCharCode","astralIdentifierStartCodes","isIdentifierChar","nonASCIIidentifier","astralIdentifierCodes","binop","name","prec","TokenType","beforeExpr","kw","options","keyword","keywords$1","isNewLine","has","obj","propName","hasOwnProperty","call","getLineInfo","input","offset","line","cur","lineBreakG","lastIndex","match","exec","index","Position","getOptions","opts","opt","defaultOptions","ecmaVersion","allowReserved","isArray","onToken","tokens","token","push","onComment","pushComment","array","block","text","start","end","startLoc","endLoc","comment","type","value","locations","loc","SourceLocation","this","ranges","range","keywordRegexp","words","RegExp","replace","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","finishNodeAt","node","tryCreateRegexp","src","flags","throwErrorAt","parser","e","undefined","SyntaxError","raise","message","codePointToString","parse","Parser","parseExpressionAt","p","nextToken","parseExpression","tokenizer","addLooseExports","Parser$$1","plugins$$1","parse_dammit","LooseParser","pluginsLoose","Object","defineProperty","d","version","plugins","Node","types","TokContext","types$1","Token","lineBreak","nonASCIIwhitespace","reservedWords","3","5","6","strict","strictBind","ecma5AndLessKeywords","keywords","nonASCIIidentifierStartChars","nonASCIIidentifierChars","label","conf","startsExpr","isLoop","isAssign","prefix","postfix","updateContext","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","source","skipWhiteSpace","ref","prototype","toString","Array","col","column","n","sourceFile","sourceType","onInsertedSemicolon","onTrailingComma","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","program","directSourceFile","preserveParens","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","isKeyword","word","isReservedWord","extend","f","pluginConfigs","this$1","plugin","Error","startNode","parseTopLevel","pp","literal","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","body","stmt","parseStatement","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","enterLexicalScope","parseFor","init$1","parseVar","declarations","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","isFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","list","label$1","statementStart","generator","createNewLexicalScope","update","left","right","isFor","decl","parseVarId","parseMaybeAssign","id","isStatement","allowExpressionBody","initFunction","async","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","method","isGenerator","isMaybeStatic","parsePropertyName","static","computed","key","isGetSet","parseClassMethod","paramCount","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","prop","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","pp$2","isBinding","toAssignableList","operator","exprList","last","arg","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","startNodeAt","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","redefinition","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","parseLiteral","regex","pattern","raw","parseParenAndDistinguishExpression","parseNew","val","spreadStart","innerParenStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parsePropertyValue","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","liberal","delegate","pp$4","err","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","pp$6","isExpr","preserveSpace","override","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","pp$8","isRhino","Packages","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","ch","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","str","regexpUnicodeSupport","escaped","inClass","content","mods","readWord1","tmp","tmpFlags","validFlags","_match","Number","readInt","radix","total","Infinity","startsWithDot","isFloat","octal","parseFloat","parseInt","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","substr","escStart","esc","_interopRequireDefault","__esModule","default","selector","document","querySelector","window","papers","_paper2","PaperScope","paperObj","install","addEventListener","randColor","_settings2","colors","randNumber","randPosition","view","bounds","width","height","randPositionX","Math","round","Point","random","x","setup","activate","quantity","items","shape","Path","Rectangle","point","fillColor","copy","clone","blendMode","rotate","scale","children","project","activeLayer","onFrame","rotationDirection","y","top","draw","color","selected","find","_paper","_settings","settings","speed","easing","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","paper","self","Base","inject","dest","enumerable","beans","preserve","field","describe","substring","bean","isFunc","res","prev","beansNames","toLowerCase","isPlainObject","writable","configurable","define","hidden","part","l","create","getOwnPropertyDescriptor","forEach","iter","bind","forIn","dst","each","desc","statics","ctor","initialize","apply","constructor","pick","a","b","begin","_id","_name","Formatter","instance","number","join","getClassName","importJSON","json","exportJSON","toJSON","serialize","props","exclude","filter","_prioritize","equals","obj1","obj2","keys","read","amount","peek","__index","readIndex","_readIndex","readNull","__read","filtered","__filtered","remain","readList","entry","readNamed","getNamed","hasObject","__unfiltered","_hasObject","hasNamed","prioritize","handleKey","processed","isPlainValue","asString","compact","dictionary","isRoot","formatter","precision","definitions","references","add","unshift","_serialize","_compactSerialize","deserialize","_data","_setDictionary","_isRoot","isFirst","hasDictionary","isDictionary","args","JSON","stringify","useTarget","Item","Layer","insert","splice","remove","append","_index","removed","capitalize","toUpperCase","camelize","chr","hyphenate","Emitter","on","func","_eventTypes","handlers","_callbacks","off","uninstall","once","emit","event","setTarget","currentTarget","stop","responds","attach","detach","fire","_installEvents","events","_events","isString","applyMatrix","insertItems","handleSize","hitTolerance","projects","tools","_scopes","support","ctx","CanvasProvider","getContext","nativeDash","nativeBlendModes","BlendMode","nativeModes","release","agent","user","navigator","userAgent","os","platform","browser","v1","v2","rv","chrome","versionNumber","webkit","atom","getView","_view","getPaper","execute","PaperScript","View","updateFocus","scope","that","element","Project","createCanvas","getCanvas","clear","handleAttribute","el","attr","getAttribute","hasAttribute","PaperScopeItem","_scope","_list","_reference","isActive","multiplier","pow","pair","val1","val2","separator","rectangle","Numerical","clamp","min","max","getDiscriminant","c","hi","D","E","abs","ad","bd","cd","dp","q","getNormalizationFactor","norm","log2","abscissas","weights","sqrt","log","LOG2E","EPSILON","MACHINE_EPSILON","CURVETIME_EPSILON","GEOMETRIC_EPSILON","TRIGONOMETRIC_EPSILON","KAPPA","isZero","integrate","w","A","B","m","sum","Ax","findRoot","df","tolerance","fx","dx","nx","solveQuadratic","roots","x1","x2","Q","R","count","boundless","minB","maxB","isFinite","solveCubic","evaluate","x0","b1","c2","qd","t","r","s","td","rd","UID","_pools","pool","arg0","arg1","reading","hasY","_set","setAngle","angle","getLength","setLength","_angle","cos","sin","getAngle","getAngleInRadians","PI","setAngleInRadians","getAngleInDegrees","setAngleInDegrees","div","NaN","acos","atan2","getQuadrant","getDirectedAngle","cross","getDistance","normalize","current","center","subtract","transform","matrix","_transformPoint","multiply","divide","negate","isInside","contains","isClose","isCollinear","isColinear","isOrthogonal","isNaN","isInQuadrant","point1","point2","y1","y2","LinkedPoint","owner","setter","_x","_y","_owner","_setter","_dontNotify","getX","setX","getY","setY","isSelected","_selection","_getSelection","setSelected","_changeSelection","Size","hasHeight","size1","size2","LinkedSize","_width","_height","getWidth","setWidth","getHeight","setHeight","arg2","arg3","from","to","frm","rect","rt","getPoint","_dontLink","setPoint","getSize","_fw","_fh","setSize","sx","_sx","sy","_sy","h","getLeft","setLeft","getTop","setTop","getRight","setRight","getBottom","setBottom","bottom","getCenterX","setCenterX","getCenterY","setCenterY","getCenter","setCenter","getArea","isEmpty","_containsRectangle","_containsPoint","intersects","epsilon","intersect","unite","include","expand","hor","ver","parts","xFirst","LinkedRectangle","internal","Matrix","ok","_a","_b","_c","_d","_tx","_ty","concat","reset","tx","ty","_changed","getValues","_applyMatrix","mx","recursively","_setApplyMatrix","isIdentity","translate","shear","skew","toRadians","tan","a1","c1","d1","a2","b2","d2","tx2","ty2","prepend","tx1","ty1","appended","prepended","invert","det","inverted","concatenate","preConcatenate","chain","_shiftless","_orNullIfIdentity","isInvertible","isSingular","_transformCoordinates","_transformCorners","coords","_transformBounds","j","inverseTransform","_inverseTransform","decompose","degrees","asin","translation","getTranslation","rotation","scaling","skewing","getScaling","getRotation","applyToContext","Line","arg4","asVector","_px","_py","_vx","_vy","getVector","isInfinite","getSide","getSignedDistance","p1x","p1y","v1x","v1y","p2x","p2y","v2x","v2y","dy","u1","u2","px","py","vx","vy","ccw","_children","_namedChildren","_activeLayer","_currentStyle","Style","_selectionItems","_selectionCount","_updateVersion","_needsUpdate","_requested","_autoUpdate","requestUpdate","changes","_changes","changesById","_changesById","getCurrentStyle","setCurrentStyle","style","getIndex","getLayers","getActiveLayer","getSymbolDefinitions","ids","getItems","class","SymbolItem","definition","_definition","getSymbols","getSelectedItems","selectionItems","selection","isInserted","_updateSelection","selectAll","setFullySelected","deselectAll","addLayer","layer","insertLayer","_remove","_setProject","setName","_insertItem","_created","NO_INSERT","insertChild","_getItems","getItem","removeOn","sets","_removeSets","mousedrag","pixelRatio","save","viewMatrix","matrices","updateMatrix","restore","strokeWidth","_drawSelection","_serializeFields","_canApplyMatrix","_canScaleStroke","_pivot","_visible","_blendMode","_opacity","_locked","_guide","_clipMask","_selectBounds","_selectChildren","pivot","visible","opacity","locked","guide","clipMask","data","_countItemEvent","_animateItem","onLoad","onError","_itemHandlers","_initialize","hasProps","_matrix","_parent","_style","fields","fontSize","Group","_defaults","symbol","_symbol","cacheParent","_project","_bounds","_position","_decomposed","_globalMatrix","_clearBoundsCache","getId","getName","_removeNamed","_getOwner","namedChildren","getStyle","setStyle","getSelection","setSelection","flag","isFullySelected","isClipMask","setClipMask","setFillColor","setStrokeColor","getData","setData","getPosition","getBounds","setPosition","getPivot","setPivot","getStrokeBounds","stroke","getHandleBounds","handle","getInternalBounds","hasMatrix","_boundsOptions","getStrokeScaling","cacheItem","_getCachedBounds","setBounds","_backup","_getBounds","_updateBoundsCache","_getBoundsCacheKey","noInternal","cacheKey","cached","nonscaling","hasStroke","_getStrokeMatrix","_item","getViewMatrix","_boundsCache","cache","_decompose","decomposed","setRotation","setScaling","getMatrix","setMatrix","getGlobalMatrix","_dontClone","updateVersion","getApplyMatrix","setApplyMatrix","getTransformContent","setTransformContent","getProject","installEvents","getLayer","getParent","setParent","addChild","getChildren","setChildren","removeChildren","addChildren","getFirstChild","getLastChild","getNextSibling","getPreviousSibling","_equals","deep","copyAttributes","copyContent","insertAbove","orig","excludeMatrix","rasterize","resolution","getResolution","topLeft","getTopLeft","floor","bottomRight","getBottomRight","ceil","raster","Raster","canvas","setCanvas","_contains","_asPathItem","getIntersections","hitTest","_hitTest","HitResult","hitTestAll","all","hitTestChildren","_exclude","child","_hitTestChildren","parentViewMatrix","hit","checkPoint","pt","tolerancePadding","guides","_tolerancePadding","_getStrokePadding","checkSelf","checkPosition","checkCenter","checkBounds","points","_hitTestSelf","fill","hasFill","matches","compare","matchObject","firstOnly","overlapping","inside","recursive","path","childMatrix","insertChildren","inserted","notifySelf","_insertAt","insertBelow","sendToBack","bringToFront","appendTop","appendBottom","moveAbove","moveBelow","addTo","copyTo","reduce","namedArray","notifyParent","replaceWith","reverseChildren","reverse","isEditable","hasShadow","_getOrder","getList","list1","list2","hasChildren","isAbove","isBelow","isParent","isChild","isDescendant","isAncestor","isSibling","isGroupedWith","_applyRecursively","getFillColor","strokeColor","getStrokeColor","_transformContent","decomp","applyRecursively","globalToLocal","localToGlobal","parentToLocal","localToParent","fitBounds","itemRatio","rectRatio","newBounds","_setStyles","fillStyle","toCanvasStyle","strokeStyle","lineWidth","getStrokeWidth","strokeJoin","getStrokeJoin","strokeCap","getStrokeCap","miterLimit","getMiterLimit","lineJoin","lineCap","dashArray","getDashArray","dashOffset","getDashOffset","setLineDash","lineDashOffset","mozDash","mozDashOffset","blur","getShadowBlur","getShadowOffset","shadowColor","getShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","parentStrokeMatrix","globalMatrix","mainCtx","itemOffset","prevOffset","normalBlend","nativeBlend","direct","dontStart","clip","_canComposite","strokeMatrix","clipItem","globalAlpha","globalCompositeOperation","setTransform","_draw","dontFinish","process","_isUpdated","CompoundPath","updated","itemSelected","boundsSelected","positionSelected","_drawSelected","getSelectedColor","half","beginPath","arc","deltas","delta","moveTo","lineTo","closePath","fillRect","hash","_clipItem","_getClipItem","isClipped","setClipped","clipped","Shape","radius","_type","_size","_radius","setType","setRadius","getType","getShape","setShape","getRadius","rad","toPath","toShape","dontPaint","untransformed","isCircle","rx","ry","kappa","cx","cy","bezierCurveTo","getFillRule","getCornerCenter","halfSize","dir","corner","quadrant","isOnEllipseStroke","padding","vector","hitStroke","hitFill","strokeRadius","strokePadding","outer","inner","createShape","Circle","Ellipse","ellipse","_readEllipse","crossOrigin","image","getElementById","setImage","setSource","_loaded","getSource","_image","_canvas","_setImage","copyCanvas","drawImage","_crossOrigin","getElement","getLoaded","u","getPpi","getImage","Event","setTimeout","DomEvent","load","error","complete","naturalWidth","naturalHeight","_context","modify","setContext","toDataURL","Image","getCrossOrigin","setCrossOrigin","getSubCanvas","getSubRaster","getAverageColor","PathItem","_sampleContext","clearRect","sampleSize","pixels","getImageData","channels","alpha","Color","getPixel","setPixel","components","_convert","_alpha","imageData","createImageData","putImageData","setImageData","setDefinition","SymbolDefinition","getDefinition","getSymbol","setSymbol","dontCenter","setItem","_dontCenter","place","values","segments","handles","ends","Segment","arg5","handleIn","handleOut","SegmentPoint","_point","hasHandles","_handleIn","_handleOut","_path","curve","curves","_curves","_closed","getHandleIn","setHandleIn","getHandleOut","setHandleOut","isSmooth","clearHandles","oldSelection","getPath","getCurve","_segments","getCurves","getLocation","CurveLocation","_segment1","getNext","smooth","_first","_last","factor","getPrevious","p0","p1","p2","k","d1_a","d1_2a","d2_a","d2_2a","N","isLast","reversed","removeSegment","segment","interpolate","handleIn1","handleIn2","handleOut2","handleOut1","change","Curve","arg6","arg7","seg1","seg2","handle1","handle2","segment1","segment2","_segment2","getPoint1","getHandle1","getHandle2","getPoint2","_length","classify","setPoint1","setPoint2","setHandle1","setHandle2","getSegment1","getSegment2","getPoints","getLine","getPart","getPartLength","divideAt","location","divideAtTime","time","getTimeAt","_setHandles","subdivide","setHandles","splitAt","splitAtTime","getLocationAtTime","isTime","straight","h1","h2","y0","x3","y3","x4","y4","x5","y5","x6","y6","x7","y7","x8","y8","x9","y9","getMonoCurves","io","o0","o1","o2","o3","isStraight","sort","coord","v0","v3","getTimeOf","p3","getNearestTime","refine","dist","minDist","minT","step","flip","isFlatEnough","flatness","ux","uy","_addBounds","minPad","maxPad","s1","s2","isLinear","third","hasLength","isHorizontal","getTangentAtTime","isVertical","getLocationAt","_isTime","getParameterAt","getOffsetAtTime","getLocationOf","getOffsetOf","getOffset","getParameterOf","getNearestLocation","getNearestPoint","methods","_evaluateMethods","getLengthIntegrand","ax","bx","ay","by","getIterations","normalized","t1","t2","hasRoots","t1Ok","t2Ok","a3","d3","f1","f2","ds","forward","rangeLength","diff","guess","getTangent","getWeightedTangent","getNormal","getWeightedNormal","getCurvature","getPeaks","addLocation","overlap","excludeStart","excludeEnd","loc1","loc2","_intersection","addCurveIntersections","recursion","calls","tMin","tMax","uMin","uMax","tMinClip","tMaxClip","q0x","q0y","q3x","q3y","dMin","dMax","dp0","dp1","dp2","dp3","hull","getConvexHull","clipConvexHull","tMinNew","tMaxNew","dq0","dq1","dq2","dq3","dist1","dist2","distRatio","hullTop","hullBottom","clipConvexHullPart","threshold","qx","qy","getCurveLineIntersections","addCurveLineIntersections","addLineIntersection","getCurveIntersections","overlaps","getOverlaps","straight1","straight2","before","i1","i2","getLoopIntersection","info","curves1","curves2","matrix1","matrix2","_returnFirst","length1","length2","values2","arrays","curve1","values1","path1","getSquaredLineLength","straightBoth","l1","l2","pairs","_overlap","_distance","_setCurve","_time","getPointAtTime","_next","_previous","_version","_curve","_segment","_setSegment","getSegment","getTime","trySegment","_offset","_curveOffset","getParameter","getCurveOffset","getIntersection","getLastSegment","_ignoreOther","isTouching","inter","curve2","isCrossing","addOffsets","offsets","isInRange","t1Inside","t2Inside","c4","c3","getPointAt","v4","a4","hasOverlap","merge","search","found","path2","expanded","compound","pathData","isClockwise","setClockwise","clockwise","setPathData","getCoord","relative","previous","control","command","lower","move","cubicCurveTo","quadraticCurveTo","arcTo","winding","_getWinding","onPath","windingL","windingR","getCrossings","minLoc","isPath","itemsFrom","itemsTo","setClosed","paths1","paths2","matched","closed","setSegments","_segmentSelection","_area","getSegments","fullySelected","_add","getFirstSegment","_countCurves","getFirstCurve","getLastCurve","isClosed","getPathData","_precision","addSegment","skipLine","curX","curY","inX","inY","outX","prevX","outY","prevY","segs","_adjustCurves","insertSegment","addSegments","insertSegments","removeSegments","_includeCurves","area","_selectSegments","newSelection","last1","last2","first2","first1","simplify","flatten","flattener","PathFlattener","PathFitter","fit","asymmetric","paddingLeft","paddingRight","knots","n_1","rf","hx","hy","seg3","seg4","isArc","pt1","pt2","topCenter","pos2","end2","pos1","end1","start2","isCloseEnough","checkSegmentPoint","seg","anchor","checkSegmentPoints","addToArea","checkSegmentStroke","isJoin","numSegments","cap","_addBevelJoin","_addSquareCap","hitCurves","drawHandles","drawHandle","hX","hY","pX","pY","drawSegments","drawSegment","dashLength","drawPart","getCurrentSegment","moveBy","curveTo","through","extent","middle","large","rxSq","rySq","xSq","ySq","throughSide","centerSide","ext","inc","z","lineBy","curveBy","parameter","cubicCurveBy","quadraticCurveBy","arcBy","processSegment","prevCoords","addPoint","addRound","joinBounds","addJoin","addCap","phi","isArea","normal1","getNormalAtTime","normal2","normal","joinPadding","joinRadius","SQRT2","paddingX","paddingY","xn","xx","yn","yx","createPath","createEllipse","ellipseSegments","bl","getBottomLeft","tl","tr","getTopRight","br","RoundRectangle","Oval","Arc","RegularPolygon","sides","three","Star","radius1","radius2","paths","getCurrentPath","check","preparePath","resolve","resolveCrossings","reorient","createResult","traceBoolean","operation","collect","_overlapsOnly","trace","splitBoolean","_path1","_path2","operators","crossings","divideLocations","propagateWinding","_winding","tracePaths","reorientPaths","addPath","added","linkIntersections","clearCurveHandles","lookup","container","sorted","entry1","getInteriorPoint","containerWinding","entry2","clearLater","renormalizeLocs","prevCurve","prevTime","results","clearCurves","clearLookup","origTime","newCurve","getWinding","dontFlip","addWinding","po","a0","ia","paR","paL","windingPrev","vPrev","a3Prev","pathWindingL","pathWindingR","pa","qualityEpsilon","quality","handleCurve","monoCurves","vClose","pv","onAnyPath","totalLength","curveLength","operand","SQRT1_2","wind","isValid","_visited","isStart","starts","visitPath","inter1","inter2","over1","over2","branch","visited","valid","finished","branches","collectStarts","nextInter","_prev","shift","1","2","-1","hasOverlaps","hasCrossings","intersections","nonZero","intercepts","mv","mo0","mo3","maxRecursion","ignoreStraight","addCurve","computeParts","minSpan","halves","tMid","_get","fitCubic","tan1","tan2","uPrime","chordLengthParameterize","maxError","parametersInOrder","generateBezier","findMaxError","reparameterize","tanCenter","C","X","b0","b3","alpha1","alpha2","detC0C1","detC0X","c0","segLength","eps","degree","maxDist","P","TextItem","_content","_lines","setContent","getContent","getCharacterStyle","setCharacterStyle","getParagraphStyle","setParagraphStyle","PointText","lines","leading","getLeading","font","getFontStyle","textAlign","getJustification","fillText","strokeText","numLines","justification","getTextWidth","fromCSS","colorCache","colorCtx","gray","rgb","hsb","hsl","gradient","componentParsers","hsbIndices","converters","rgb-hsb","g","hsb-rgb","rgb-hsl","achromatic","hsl-rgb","t3s","t3","rgb-gray","gray-rgb","gray-hsb","gray-hsl","gradient-rgb","rgb-gradient","_components","Gradient","_removeOwner","_addOwner","_properties","argType","parsers","stops","radial","getComponents","_canvasStyle","converter","convert","getAlpha","setAlpha","hasAlpha","isGradient","toCSS","hex","canvasGradient","_stops","origin","destination","highlight","inverse","_radial","createRadialGradient","createLinearGradient","addColorStop","_color","_types","components1","components2","setStops","setRadial","_owners","getStops","GradientStop","getRadial","stops1","stops2","rampPoint","setColor","setOffset","getRampPoint","setRampPoint","getColor","itemDefaults","fillRule","strokeScaling","shadowOffset","selectedColor","groupDefaults","fontFamily","fontWeight","textDefaults","_values","isColor","isPoint","old","_dontMerge","childValue","Font","WindingRule","isStyle","style1","style2","secondary","defaults2","value1","value2","getFontSize","getFontWeight","getFontFamily","getFont","setFont","getPixelSize","DomElement","handlePrefix","prefixes","suffix","getStyles","doc","nodeType","ownerDocument","defaultView","getComputedStyle","viewport","html","documentElement","getBoundingClientRect","clientLeft","clientTop","pageXOffset","scrollLeft","pageYOffset","scrollTop","getViewportBounds","innerWidth","clientWidth","innerHeight","clientHeight","isInvisible","isInView","getPrefixed","setPrefixed","removeEventListener","targetTouches","changedTouches","pageX","clientX","pageY","clientY","getTarget","srcElement","getRelatedTarget","relatedTarget","toElement","requestAnimationFrame","handleCallbacks","functions","callbacks","requested","nativeRequest","timer","callback","setInterval","getCanvasSize","setAttribute","_viewEvents","userDrag","userSelect","touchCallout","contentZooming","tapHighlightColor","_windowEvents","resize","setViewSize","Stats","_stats","stats","domElement","appendChild","_element","_pixelRatio","devicePixelRatio","_setElementSize","_viewSize","_views","_viewsById","_focused","_frameItems","_frameItemCount","_itemEvents","native","virtual","_animate","play","pause","_count","getAutoUpdate","setAutoUpdate","autoUpdate","_handleFrame","now","Date","animate","_handleFrameItems","getPixelRatio","getViewSize","isVisible","parentNode","temp","createElement","removeChild","getZoom","setZoom","zoom","scrollBy","projectToView","viewToProject","getEventPoint","CanvasView","tempFocus","handleMouseMove","_handleMouseEvent","emitMouseEvent","prevPoint","stopItem","mouseEvent","MouseEvent","called","prevented","stopped","fallback","fallbacks","emitMouseEvents","hitItem","dragItem","prevFocus","mousedown","mousemove","mouseup","dragging","mouseDown","pointerEnabled","msPointerEnabled","viewEvents","docEvents","mouseout","nodeName","scroll","overView","downPoint","lastPoint","downItem","overItem","clickItem","clickTime","dblClick","doubleclick","wasInView","itemEventsMap","click","mouseenter","mouseleave","itemEvents","tool","hitItems","nativeMove","inView","mouse","drag","down","up","preventDefault","_handleKeyEvent","character","keyEvent","KeyEvent","sign","HTMLCanvasElement","deviceRatio","backingStoreRatio","firefox","prevFont","measureText","stopPropagation","getTimeStamp","timeStamp","getModifiers","Key","modifiers","getKey","keyIdentifier","keyCode","keyLookup","keyMap","charMap","mac","metaFixMap","downKey","\t"," ","\b","","Spacebar","Del","Win","Esc","charLookup","tab","space","enter","alt","capsLock","option","keydown","altKey","metaKey","ctrlKey","keypress","charCode","keyup","isDown","ToolEvent","_choosePoint","toolPoint","getLastPoint","_lastPoint","setLastPoint","getDownPoint","_downPoint","setDownPoint","getMiddlePoint","_middlePoint","setMiddlePoint","middlePoint","getDelta","_delta","setDelta","getCount","setCount","Tool","_moveCount","_downCount","getMinDistance","_minDistance","setMinDistance","minDistance","_maxDistance","getMaxDistance","setMaxDistance","maxDistance","getFixedDistance","setFixedDistance","distance","Http","request","xhr","XMLHttpRequest","open","url","mimeType","overrideMimeType","onload","status","responseText","onerror","send","canvases","getLum","setLum","dr","dg","db","mn","lmn","ln","mxl","getSat","setSat","md","sr","sg","sb","sa","bg","bb","ba","modes","screen","overlay","soft-light","hard-light","color-dodge","color-burn","darken","lighten","difference","exclusion","hue","saturation","luminosity","average","negation","mode","srcContext","dstContext","srcCanvas","dstData","SvgElement","attributes","createElementNS","svg","namespace","attributeNamespace","getAttributeNS","setAttributeNS","xmlns","xlink","href","xmlns:xlink","SvgStyles","true","false","attribute","toSVG","fromSVG","exportFilter","getTransform","coordinates","attrs","trans","exportGroup","childNode","exportSVG","clip-path","exportRaster","embedImages","exportPath","matchShapes","exportShape","exportCompoundPath","exportSymbolItem","definitionItem","viewBox","overflow","exportGradient","gradientNode","getGradient","getOrigin","getDestination","getHighlight","fy","gradientUnits","stopColor","exportText","textContent","applyStyle","visibility","svgs","__id","typeId","exportDefinitions","defs","insertBefore","firstChild","XMLSerializer","serializeToString","exporter","exporters","onExport","setOptions","getValue","allowNull","allowPercent","rootSize","convertValue","map","importGroup","childNodes","isClip","isDefs","currentStyle","applyAttributes","querySelectorAll","importNode","importPoly","importPath","importGradient","scaleToBounds","_scaleToBounds","applyTransform","transforms","applyOpacity","styles","tagName","isElement","nextSibling","importer","importers","onImport","expandShapes","importSVG","DOMParser","parseFromString","File","reader","FileReader","readAsText","#document","clippath","polygon","polyline","lineargradient","radialgradient","use","circle","trim","gradientTransform","fill-opacity","stroke-opacity","setVisible","display","stop-color","stop-opacity","percent","group","global","acorn","__$__","binaryOperators","$__","unaryOperators","compile","insertions","insertion","getCode","getBetween","replaceCode","walkAST","between","parentType","exp","offsetCode","sourceMaps","lineBreaks","getElementsByTagName","innerHTML","safari","mappings","file","names","sourceRoot","sourcesContent","btoa","unescape","encodeURIComponent","expose","toolHandlers","compiled","script","head","createTextNode","_execute","Function","onResize","setOnResize","setOnFrame","loadScript","canvasId","baseURI","loadAll","root","mod","tokPos","makePredicate","compareTo","arr","cats","cat","line_loc_t","tokCurLine","tokLineStart","initTokenState","tokRegexpAllowed","tokEnd","tokEndLoc","tokVal","inputLen","_dot","_assign","_slash","readToken_mult_modulo","_multiplyModulo","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseAND","_bitwiseXOR","newline","lastEnd","_incDec","_plusMin","_bitShift","_relational","_equality","_eq","_prefix","_parenL","_parenR","_semi","_comma","_bracketL","_bracketR","_braceL","_braceR","_colon","_question","readHexNumber","forceRegexp","tokStart","tokStartLoc","_eof","tok","_regexp","_num","_string","escStr","keywordTypes","lastStart","lastEndLoc","setStrict","strct","node_t","node_loc_t","startNodeFrom","isUseStrict","strictSemicolons","isStrictBadIdWord","guard","guardedHandlers","allowStrict","noComma","isUpdate","atomValue","tokStartLoc1","tokStart1","sawGetSet","allowTrailingCommas","conflict","isStrictReservedWord","forbidReserved","isReservedWord3","isReservedWord5","inpt","tokenize","jumpTo","reAllowed","break","case","catch","continue","debugger","do","else","finally","for","function","if","return","switch","throw","try","while","with","null","new","in","instanceof","typeof","void","delete","tokTypes","+","-","*","/","%","==","!=","__self","readyState","PlacedSymbol"],"mappings":"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","file":"js/app.patterns.js","sourcesContent":["webpackJsonp([1],[\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _helpers = __webpack_require__(0);\n\nvar _patterns = __webpack_require__(11);\n\nvar app = {\n  init: function init() {\n    (0, _patterns.confetti)('#pattern-cover');\n    (0, _patterns.background)('#pattern-reference', 'cyan');\n    (0, _patterns.background)('#pattern-availability', 'yellow');\n    (0, _patterns.background)('#pattern-resume', 'purple');\n  }\n};\n\n(0, _helpers.domReady)(app.init);\n\n/***/ }),\n/* 3 */,\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseExpressionAt\", function() { return parseExpressionAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenizer\", function() { return tokenizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse_dammit\", function() { return parse_dammit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LooseParser\", function() { return LooseParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginsLoose\", function() { return pluginsLoose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLooseExports\", function() { return addLooseExports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plugins\", function() { return plugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultOptions\", function() { return defaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SourceLocation\", function() { return SourceLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLineInfo\", function() { return getLineInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenType\", function() { return TokenType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokTypes\", function() { return types; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keywordTypes\", function() { return keywords$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokContext\", function() { return TokContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokContexts\", function() { return types$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifierChar\", function() { return isIdentifierChar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifierStart\", function() { return isIdentifierStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNewLine\", function() { return isNewLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineBreak\", function() { return lineBreak; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineBreakG\", function() { return lineBreakG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nonASCIIwhitespace\", function() { return nonASCIIwhitespace; });\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType == \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^']|\\.)*)'|\"((?:[^\"]|\\.)*)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) == \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(types.name)\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;\n  if (!andThrow) { return pos >= 0 }\n  if (pos > -1) { this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != \"let\") { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!this.isKeyword(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind != \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) { return this.parseFor(node, null) }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      { return this.parseForIn(node, init$1) }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init);\n    this.checkLVal(init);\n    this.checkPatternErrors(refDestructuringErrors, true);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.isFunction = function() {\n  return this.type === types._function || this.isAsyncFunction()\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction());\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type != types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    this.expect(types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.enterLexicalScope();\n    this.checkLVal(clause.param, \"let\");\n    this.expect(types.parenR);\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart == node.start) {\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type == types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (this$1.eat(types.semi)) { continue }\n    var method = this$1.startNode();\n    var isGenerator = this$1.eat(types.star);\n    var isAsync = false;\n    var isMaybeStatic = this$1.type === types.name && this$1.value === \"static\";\n    this$1.parsePropertyName(method);\n    method.static = isMaybeStatic && this$1.type !== types.parenL;\n    if (method.static) {\n      if (isGenerator) { this$1.unexpected(); }\n      isGenerator = this$1.eat(types.star);\n      this$1.parsePropertyName(method);\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== types.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true;\n      this$1.parsePropertyName(method);\n    }\n    method.kind = \"method\";\n    var isGetSet = false;\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== types.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true;\n        method.kind = key.name;\n        key = this$1.parsePropertyName(method);\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) { this$1.raise(key.start, \"Duplicate constructor in the same class\"); }\n        if (isGetSet) { this$1.raise(key.start, \"Constructor can't have get/set modifier\"); }\n        if (isGenerator) { this$1.raise(key.start, \"Constructor can't be a generator\"); }\n        if (isAsync) { this$1.raise(key.start, \"Constructor can't be an async method\"); }\n        method.kind = \"constructor\";\n        hadConstructor = true;\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync);\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1;\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start;\n        if (method.kind === \"get\")\n          { this$1.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this$1.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          { this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type == \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type == \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop.value);\n      } }\n  else if (type == \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type == \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type == \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      if (prop.kind !== \"init\") { this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\"); }\n        this$1.toAssignable(prop.value, isBinding);\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type == \"RestElement\") {\n      --end;\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding);\n      --end;\n    }\n\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) { return this.parseIdent() }\n  switch (this.type) {\n  case types.name:\n    return this.parseIdent()\n\n  case types.bracketL:\n    var node = this.startNode();\n    this.next();\n    node.elements = this.parseBindingList(types.bracketR, true, true);\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case types.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop.value, bindingType, checkClashes);\n  }\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type == types.parenL || this.type == types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left) : left;\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors);\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon();\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n\n  case types._this:\n    var type = this.type === types._this ? \"ThisExpression\" : \"Super\";\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, type)\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        if (this$1.type === types.parenL && !innerParenStart) {\n          innerParenStart = this$1.start;\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (innerParenStart) { this.unexpected(innerParenStart); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), startPos = (void 0), startLoc = (void 0);\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start;\n        startLoc = this$1.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this$1.eat(types.star); }\n    }\n    this$1.parsePropertyName(prop);\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && this$1.isAsyncProp(prop)) {\n      isAsync = true;\n      this$1.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);\n    this$1.checkPropClash(prop, propHash);\n    node.properties.push(this$1.finishNode(prop, \"Property\"));\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != types.comma && this.type != types.braceR)) {\n    if (isGenerator || isAsync || isPattern) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") != -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name))\n    { this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\")); }\n};\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved == \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType == types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)\n    { return true }\n  if (prevType == types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType == types._var || prevType == types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType == types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType == types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6) {\n    if (this.value == \"of\" && !this.exprAllowed ||\n        this.value == \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\";\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) { this.unexpected(); }\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) { parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message); }\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\");\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var content = this.input.slice(start, this.pos);\n  ++this.pos;\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1();\n  var tmp = content, tmpFlags = \"\";\n  if (mods) {\n    var validFlags = /^[gim]*$/;\n    if (this.options.ecmaVersion >= 6) { validFlags = /^[gimuy]*$/; }\n    if (!validFlags.test(mods)) { this.raise(start, \"Invalid regular expression flag\"); }\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\";\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code);\n          if (code > 0x10FFFF) { this$1.raise(start + offset + 3, \"Code point out of bounds\"); }\n          return \"x\"\n        });\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n        tmpFlags = tmpFlags.replace(\"u\", \"\");\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null;\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this);\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods);\n  }\n  return this.finishToken(types.regexp, {pattern: content, flags: mods, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  if (octal && this.pos == start + 1) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    isFloat = true;\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    isFloat = true;\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos), val;\n  if (isFloat) { val = parseFloat(str); }\n  else if (!octal || str.length === 1) { val = parseInt(str, 10); }\n  else if (this.strict) { this.raise(start, \"Invalid number\"); }\n  else if (/[89]/.test(str)) { val = parseInt(str, 10); }\n  else { val = parseInt(str, 8); }\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.invalidStringToken(this.pos - 2, \"Octal literal in strict mode\");\n      }\n      this.pos += octalStr.length - 1;\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.1.1\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\n\n\n\n/***/ }),\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.background = exports.confetti = undefined;\n\nvar _paper = __webpack_require__(19);\n\nvar _paper2 = _interopRequireDefault(_paper);\n\nvar _helpers = __webpack_require__(0);\n\nvar _settings = __webpack_require__(15);\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.papers = {};\n\nfunction confetti() {\n  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n  var pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers['' + pattern.id] = new _paper2.default.PaperScope();\n  var paperObj = window.papers['' + pattern.id];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', function () {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function randColor() {\n      var selectedColor = _settings2.default.colors[(0, _helpers.randNumber)(0, _settings2.default.colors.length)];\n      return selectedColor.value;\n    }\n\n    function randPosition() {\n      return [(0, _helpers.randNumber)(1, paperObj.view.bounds.width), (0, _helpers.randNumber)(1, paperObj.view.bounds.height)];\n    }\n\n    function randPositionX() {\n      return Math.round(paperObj.Point.random().x * paperObj.view.size.width);\n    }\n\n    var density = 0.02;\n    var quantity = Math.round(area() / 100 * density);\n    var items = quantity <= 200 ? quantity : 200;\n    var shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: randColor()\n    });\n\n    for (var i = 0; i < items; i++) {\n      var copy = shape.clone();\n\n      copy.size = [(0, _helpers.randNumber)(20, 30), 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.fillColor = randColor();\n      copy.blendMode = 'multiply';\n      copy.rotate((0, _helpers.randNumber)(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale(i / items * (0, _helpers.randNumber)(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n    paperObj.view.update();\n    var children = paperObj.project.activeLayer.children;\n\n    paperObj.view.onFrame = function () {\n      for (var _i = 0; _i < items; _i++) {\n        var item = children[_i];\n        var rotationDirection = _i % 2 ? +1 : -1;\n\n        item.rotate(rotationDirection);\n        item.position.y += item.bounds.width / (item.bounds.width * 2);\n\n        if (item.bounds.top > paperObj.view.size.height) {\n          item.position.y = -item.bounds.width;\n          item.position.x = randPositionX();\n        }\n      }\n    };\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nfunction background() {\n  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'white';\n\n  var pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers['' + pattern.id] = new _paper2.default.PaperScope();\n  var paperObj = window.papers['' + pattern.id];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', function () {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function selectColor(name) {\n      var selected = _settings2.default.colors.find(function (item) {\n        return item.name === name;\n      });\n      return selected ? selected.value : name;\n    }\n\n    function randPosition() {\n      return [(0, _helpers.randNumber)(1, paperObj.view.bounds.width), (0, _helpers.randNumber)(1, paperObj.view.bounds.height)];\n    }\n\n    var density = 0.02;\n    var quantity = Math.round(area() / 100 * density);\n    var items = quantity <= 200 ? quantity : 200;\n    var shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: selectColor(color)\n    });\n\n    for (var i = 0; i < items; i++) {\n      var copy = shape.clone();\n\n      copy.size = [30, 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.rotate((0, _helpers.randNumber)(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale(i / items * (0, _helpers.randNumber)(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nexports.confetti = confetti;\nexports.background = background;\n\n/***/ }),\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar settings = {\n  speed: 500,\n  easing: 'easeInOutExpo',\n  colors: [{ name: 'red', value: '#DF6C74' }, { name: 'green', value: '#99C46D' }, { name: 'yellow', value: '#ecce79' }, { name: 'blue', value: '#63ADF5' }, { name: 'cyan', value: '#59B6C4' }, { name: 'orange', value: '#D09B5C' }, { name: 'purple', value: '#C575E4' }, { name: 'slate', value: '#5F697F' }]\n};\n\nexports.default = settings;\n\n/***/ }),\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Paper.js v0.11.4 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Wed Jun 7 16:56:44 2017 +0200\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2016 Juerg Lehni\n * http://scratchdisk.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * http://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = function(self, undefined) {\n\nself = self || __webpack_require__(25);\nvar window = self.window,\n\tdocument = self.document;\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\tarray = [],\n\t\tslice = array.slice,\n\t\tcreate = Object.create,\n\t\tdescribe = Object.getOwnPropertyDescriptor,\n\t\tdefine = Object.defineProperty,\n\n\t\tforEach = array.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this) {\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tset = Object.assign || function(dst) {\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tfor (var key in src) {\n\t\t\t\t\tif (src.hasOwnProperty(key))\n\t\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\n\t\teach = function(obj, iter, bind) {\n\t\t\tif (obj) {\n\t\t\t\tvar desc = describe(obj, 'length');\n\t\t\t\t(desc && typeof desc.value === 'number' ? forEach : forIn)\n\t\t\t\t\t.call(obj, iter, bind = bind || obj);\n\t\t\t}\n\t\t\treturn bind;\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res)) {\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t}\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable != null ? enumerable : !bean;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tvar src = arguments[i];\n\t\t\tif (src)\n\t\t\t\tset(this, src);\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn inject(Base, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, null, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, obj, l = arguments.length;\n\t\t\t\t\ti < l && !(ctor && proto); i++) {\n\t\t\t\tobj = arguments[i];\n\t\t\t\tctor = ctor || obj.initialize;\n\t\t\t\tproto = proto || obj.prototype;\n\t\t\t}\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = proto || create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}).inject({\n\t\tenumerable: false,\n\n\t\tinitialize: Base,\n\n\t\tset: Base,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src) {\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\tset: set,\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t},\n\n\t\t\tslice: function(list, begin, end) {\n\t\t\t\treturn slice.call(list, begin, end);\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (true)\n\tmodule.exports = Base;\n\nBase.inject({\n\tenumerable: false,\n\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\timportJSON: function(json) {\n\t\treturn Base.importJSON(json, this);\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\tset: function(props, exclude) {\n\t\tif (props)\n\t\t\tBase.filter(this, props, exclude, this._prioritize);\n\t\treturn this;\n\t}\n}, {\n\nbeans: false,\nstatics: {\n\texports: {},\n\n\textend: function extend() {\n\t\tvar res = extend.base.apply(this, arguments),\n\t\t\tname = res.prototype._class;\n\t\tif (name && !Base.exports[name])\n\t\t\tBase.exports[name] = res;\n\t\treturn res;\n\t},\n\n\tequals: function(obj1, obj2) {\n\t\tif (obj1 === obj2)\n\t\t\treturn true;\n\t\tif (obj1 && obj1.equals)\n\t\t\treturn obj1.equals(obj2);\n\t\tif (obj2 && obj2.equals)\n\t\t\treturn obj2.equals(obj1);\n\t\tif (obj1 && obj2\n\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\tvar length = obj1.length;\n\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\tlength = keys.length;\n\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tread: function(list, start, options, amount) {\n\t\tif (this === Base) {\n\t\t\tvar value = this.peek(list, start);\n\t\t\tlist.__index++;\n\t\t\treturn value;\n\t\t}\n\t\tvar proto = this.prototype,\n\t\t\treadIndex = proto._readIndex,\n\t\t\tbegin = start || readIndex && list.__index || 0,\n\t\t\tlength = list.length,\n\t\t\tobj = list[begin];\n\t\tamount = amount || length - begin;\n\t\tif (obj instanceof this\n\t\t\t|| options && options.readNull && obj == null && amount <= 1) {\n\t\t\tif (readIndex)\n\t\t\t\tlist.__index = begin + 1;\n\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t}\n\t\tobj = Base.create(proto);\n\t\tif (readIndex)\n\t\t\tobj.__read = true;\n\t\tobj = obj.initialize.apply(obj, begin > 0 || begin + amount < length\n\t\t\t\t? Base.slice(list, begin, begin + amount)\n\t\t\t\t: list) || obj;\n\t\tif (readIndex) {\n\t\t\tlist.__index = begin + obj.__read;\n\t\t\tvar filtered = obj.__filtered;\n\t\t\tif (filtered) {\n\t\t\t\tlist.__filtered = filtered;\n\t\t\t\tobj.__filtered = undefined;\n\t\t\t}\n\t\t\tobj.__read = undefined;\n\t\t}\n\t\treturn obj;\n\t},\n\n\tpeek: function(list, start) {\n\t\treturn list[list.__index = start || list.__index || 0];\n\t},\n\n\tremain: function(list) {\n\t\treturn list.length - (list.__index || 0);\n\t},\n\n\treadList: function(list, start, options, amount) {\n\t\tvar res = [],\n\t\t\tentry,\n\t\t\tbegin = start || 0,\n\t\t\tend = amount ? begin + amount : list.length;\n\t\tfor (var i = begin; i < end; i++) {\n\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t}\n\t\treturn res;\n\t},\n\n\treadNamed: function(list, name, start, options, amount) {\n\t\tvar value = this.getNamed(list, name),\n\t\t\thasObject = value !== undefined;\n\t\tif (hasObject) {\n\t\t\tvar filtered = list.__filtered;\n\t\t\tif (!filtered) {\n\t\t\t\tfiltered = list.__filtered = Base.create(list[0]);\n\t\t\t\tfiltered.__unfiltered = list[0];\n\t\t\t}\n\t\t\tfiltered[name] = undefined;\n\t\t}\n\t\tvar l = hasObject ? [value] : list,\n\t\t\tres = this.read(l, start, options, amount);\n\t\treturn res;\n\t},\n\n\tgetNamed: function(list, name) {\n\t\tvar arg = list[0];\n\t\tif (list._hasObject === undefined)\n\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\tif (list._hasObject)\n\t\t\treturn name ? arg[name] : list.__filtered || arg;\n\t},\n\n\thasNamed: function(list, name) {\n\t\treturn !!this.getNamed(list, name);\n\t},\n\n\tfilter: function(dest, source, exclude, prioritize) {\n\t\tvar processed;\n\n\t\tfunction handleKey(key) {\n\t\t\tif (!(exclude && key in exclude) &&\n\t\t\t\t!(processed && key in processed)) {\n\t\t\t\tvar value = source[key];\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\tdest[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tif (prioritize) {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0, key, l = prioritize.length; i < l; i++) {\n\t\t\t\tif ((key = prioritize[i]) in source) {\n\t\t\t\t\thandleKey(key);\n\t\t\t\t\tkeys[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed = keys;\n\t\t}\n\n\t\tObject.keys(source.__unfiltered || source).forEach(handleKey);\n\t\treturn dest;\n\t},\n\n\tisPlainValue: function(obj, asString) {\n\t\treturn Base.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t|| asString && typeof obj === 'string';\n\t},\n\n\tserialize: function(obj, options, compact, dictionary) {\n\t\toptions = options || {};\n\n\t\tvar isRoot = !dictionary,\n\t\t\tres;\n\t\tif (isRoot) {\n\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\tdictionary = {\n\t\t\t\tlength: 0,\n\t\t\t\tdefinitions: {},\n\t\t\t\treferences: {},\n\t\t\t\tadd: function(item, create) {\n\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t}\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (obj && obj._serialize) {\n\t\t\tres = obj._serialize(options, dictionary);\n\t\t\tvar name = obj._class;\n\t\t\tif (name && !obj._compactSerialize && (isRoot || !compact)\n\t\t\t\t\t&& res[0] !== name) {\n\t\t\t\tres.unshift(name);\n\t\t\t}\n\t\t} else if (Array.isArray(obj)) {\n\t\t\tres = [];\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\tres[i] = Base.serialize(obj[i], options, compact, dictionary);\n\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\tres = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\tdictionary);\n\t\t\t}\n\t\t} else if (typeof obj === 'number') {\n\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t} else {\n\t\t\tres = obj;\n\t\t}\n\t\treturn isRoot && dictionary.length > 0\n\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t: res;\n\t},\n\n\tdeserialize: function(json, create, _data, _setDictionary, _isRoot) {\n\t\tvar res = json,\n\t\t\tisFirst = !_data,\n\t\t\thasDictionary = isFirst && json && json.length\n\t\t\t\t&& json[0][0] === 'dictionary';\n\t\t_data = _data || {};\n\t\tif (Array.isArray(json)) {\n\t\t\tvar type = json[0],\n\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\tif (json.length == 1 && /^#/.test(type)) {\n\t\t\t\treturn _data.dictionary[type];\n\t\t\t}\n\t\t\ttype = Base.exports[type];\n\t\t\tres = [];\n\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++) {\n\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\tisDictionary, hasDictionary));\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tvar args = res;\n\t\t\t\tif (create) {\n\t\t\t\t\tres = create(type, args, isFirst || _isRoot);\n\t\t\t\t} else {\n\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Base.isPlainObject(json)) {\n\t\t\tres = {};\n\t\t\tif (_setDictionary)\n\t\t\t\t_data.dictionary = res;\n\t\t\tfor (var key in json)\n\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t}\n\t\treturn hasDictionary ? res[1] : res;\n\t},\n\n\texportJSON: function(obj, options) {\n\t\tvar json = Base.serialize(obj, options);\n\t\treturn options && options.asString == false\n\t\t\t\t? json\n\t\t\t\t: JSON.stringify(json);\n\t},\n\n\timportJSON: function(json, target) {\n\t\treturn Base.deserialize(\n\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\tfunction(ctor, args, isRoot) {\n\t\t\t\t\tvar useTarget = isRoot && target\n\t\t\t\t\t\t\t&& target.constructor === ctor,\n\t\t\t\t\t\tobj = useTarget ? target\n\t\t\t\t\t\t\t: Base.create(ctor.prototype);\n\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t&& (useTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t}\n\t\t\t\t\t(useTarget ? obj.set : ctor).apply(obj, args);\n\t\t\t\t\tif (useTarget)\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\treturn obj;\n\t\t\t\t});\n\t},\n\n\tsplice: function(list, items, index, remove) {\n\t\tvar amount = items && items.length,\n\t\t\tappend = index === undefined;\n\t\tindex = append ? list.length : index;\n\t\tif (index > list.length)\n\t\t\tindex = list.length;\n\t\tfor (var i = 0; i < amount; i++)\n\t\t\titems[i]._index = index + i;\n\t\tif (append) {\n\t\t\tlist.push.apply(list, items);\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar args = [index, remove];\n\t\t\tif (items)\n\t\t\t\targs.push.apply(args, items);\n\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\tremoved[i]._index = undefined;\n\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\tlist[i]._index = i;\n\t\t\treturn removed;\n\t\t}\n\t},\n\n\tcapitalize: function(str) {\n\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t},\n\n\tcamelize: function(str) {\n\t\treturn str.replace(/-(.)/g, function(match, chr) {\n\t\t\treturn chr.toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(str) {\n\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t}\n}});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, func);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = Base.slice(arguments, 1),\n\t\t\tsetTarget = event && event.target && !event.currentTarget;\n\t\thandlers = handlers.slice();\n\t\tif (setTarget)\n\t\t\tevent.currentTarget = this;\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) == false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t   }\n\t\t}\n\t\tif (setTarget)\n\t\t\tdelete event.currentTarget;\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar types = this._eventTypes,\n\t\t\thandlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tif (types) {\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar entry = types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\tinsertItems: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1) || {};\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\t\tif (!this.agent) {\n\t\t\tvar user = self.navigator.userAgent.toLowerCase(),\n\t\t\t\tos = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],\n\t\t\t\tplatform = os === 'darwin' ? 'mac' : os,\n\t\t\t\tagent = proto.agent = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tagent[platform] = true;\n\t\t\tuser.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g,\n\t\t\t\tfunction(match, n, v1, v2, rv) {\n\t\t\t\t\tif (!agent.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 :\n\t\t\t\t\t\t\t\t/^(node|trident)$/.test(n) ? rv : v1;\n\t\t\t\t\t\tagent.version = v;\n\t\t\t\t\t\tagent.versionNumber = parseFloat(v);\n\t\t\t\t\t\tn = n === 'trident' ? 'msie' : n;\n\t\t\t\t\t\tagent.name = n;\n\t\t\t\t\t\tagent[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (agent.chrome)\n\t\t\t\tdelete agent.webkit;\n\t\t\tif (agent.atom)\n\t\t\t\tdelete agent.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.11.4\",\n\n\tgetView: function() {\n\t\tvar project = this.project;\n\t\treturn project && project._view;\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, options) {\n\t\tpaper.PaperScript.execute(code, this, options);\n\t\tView.updateFocus();\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tcreateCanvas: function(width, height) {\n\t\treturn CanvasProvider.getCanvas(width, height);\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tvar projects = this.projects,\n\t\t\ttools = this.tools;\n\t\tfor (var i = projects.length - 1; i >= 0; i--)\n\t\t\tprojects[i].remove();\n\t\tfor (var i = tools.length - 1; i >= 0; i--)\n\t\t\ttools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._scope.getView();\n\t}\n});\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = Base.pick(precision, 5);\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn this.precision < 16\n\t\t\t\t? Math.round(val * this.multiplier) / this.multiplier : val;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tlog2 = Math.log2 || function(x) {\n\t\t\treturn Math.log(x) * Math.LOG2E;\n\t\t},\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clamp(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\tfunction getDiscriminant(a, b, c) {\n\t\tfunction split(v) {\n\t\t\tvar x = v * 134217729,\n\t\t\t\ty = v - x,\n\t\t\t\thi = y + x,\n\t\t\t\tlo = v - hi;\n\t\t\treturn [hi, lo];\n\t\t}\n\n\t\tvar D = b * b - a * c,\n\t\t\tE = b * b + a * c;\n\t\tif (abs(D) * 3 < E) {\n\t\t\tvar ad = split(a),\n\t\t\t\tbd = split(b),\n\t\t\t\tcd = split(c),\n\t\t\t\tp = b * b,\n\t\t\t\tdp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],\n\t\t\t\tq = a * c,\n\t\t\t\tdq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])\n\t\t\t\t\t\t+ ad[1] * cd[1];\n\t\t\tD = (p - q) + (dp - dq);\n\t\t}\n\t\treturn D;\n\t}\n\n\tfunction getNormalizationFactor() {\n\t\tvar norm = Math.max.apply(Math, arguments);\n\t\treturn norm && (norm < 1e-8 || norm > 1e8)\n\t\t\t\t? pow(2, -Math.round(log2(norm)))\n\t\t\t\t: 0;\n\t}\n\n\treturn {\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 1e-8,\n\t\tGEOMETRIC_EPSILON: 1e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-8,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tclamp: clamp,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance) {\n\t\t\t\t\tx = nx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clamp(x, a, b);\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar x1, x2 = Infinity;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(b) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / b;\n\t\t\t} else {\n\t\t\t\tb *= -0.5;\n\t\t\t\tvar D = getDiscriminant(a, b, c);\n\t\t\t\tif (D && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c));\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\ta *= f;\n\t\t\t\t\t\tb *= f;\n\t\t\t\t\t\tc *= f;\n\t\t\t\t\t\tD = getDiscriminant(a, b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0,\n\t\t\t\tboundless = min == null,\n\t\t\t\tminB = min - EPSILON,\n\t\t\t\tmaxB = max + EPSILON;\n\t\t\tif (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))\n\t\t\t\troots[count++] = boundless ? x1 : clamp(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))\n\t\t\t\troots[count++] = boundless ? x2 : clamp(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),\n\t\t\t\tx, b1, c2, qd, q;\n\t\t\tif (f) {\n\t\t\t\ta *= f;\n\t\t\t\tb *= f;\n\t\t\t\tc *= f;\n\t\t\t\td *= f;\n\t\t\t}\n\n\t\t\tfunction evaluate(x0) {\n\t\t\t\tx = x0;\n\t\t\t\tvar tmp = a * x;\n\t\t\t\tb1 = tmp + b;\n\t\t\t\tc2 = b1 * x + c;\n\t\t\t\tqd = (tmp + b1) * x + c2;\n\t\t\t\tq = c2 * x + d;\n\t\t\t}\n\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tevaluate(-(b / a) / 3);\n\t\t\t\tvar t = q / a,\n\t\t\t\t\tr = pow(abs(t), 1/3),\n\t\t\t\t\ts = t < 0 ? -1 : 1,\n\t\t\t\t\ttd = -qd / a,\n\t\t\t\t\trd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,\n\t\t\t\t\tx0 = x - s * rd;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tevaluate(x0);\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),\n\t\t\t\tboundless = min == null;\n\t\t\tif (isFinite(x) && (count === 0\n\t\t\t\t\t|| count > 0 && x !== roots[0] && x !== roots[1])\n\t\t\t\t\t&& (boundless || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = boundless ? x : clamp(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(name) {\n\t\tif (name) {\n\t\t\tvar pool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasY ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('angle' in obj) {\n\t\t\t\tthis._set(obj.length || 0, 0);\n\t\t\t\tthis.setAngle(obj.angle || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis._set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(arguments);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\ttolerance = Base.read(arguments);\n\t\treturn this.getDistance(point) <= tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.x) && isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tisInQuadrant: function(q) {\n\t\treturn this.x * (q > 1 && q < 4 ? -1 : 1) >= 0\n\t\t\t&& this.y * (q > 2 ? -1 : 1) >= 0;\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\treturn this._setter === 'setPosition' ? 4 : 0;\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasHeight ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.width) && isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar type = typeof arg0,\n\t\t\tread;\n\t\tif (type === 'number') {\n\t\t\tthis._set(arg0, arg1, arg2, arg3);\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0, 0, 0);\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis._set.apply(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis._set(arg0.x || 0, arg0.y || 0,\n\t\t\t\t\t\targ0.width || 0, arg0.height || 0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis._set(0, 0, 0, 0);\n\t\t\t\tBase.filter(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t}\n\t\t}\n\t\tif (read === undefined) {\n\t\t\tvar frm = Point.readNamed(arguments, 'from'),\n\t\t\t\tnext = Base.peek(arguments),\n\t\t\t\tx = frm.x,\n\t\t\t\ty = frm.y,\n\t\t\t\twidth,\n\t\t\t\theight;\n\t\t\tif (next && next.x !== undefined\n\t\t\t\t\t|| Base.hasNamed(arguments, 'to')) {\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\twidth = to.x - x;\n\t\t\t\theight = to.y - y;\n\t\t\t\tif (width < 0) {\n\t\t\t\t\tx = to.x;\n\t\t\t\t\twidth = -width;\n\t\t\t\t}\n\t\t\t\tif (height < 0) {\n\t\t\t\t\ty = to.y;\n\t\t\t\t\theight = -height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\twidth = size.width;\n\t\t\t\theight = size.height;\n\t\t\t}\n\t\t\tthis._set(x, y, width, height);\n\t\t\tread = arguments.__index;\n\t\t\tvar filtered = arguments.__filtered;\n\t\t\tif (filtered)\n\t\t\t\tthis.__filtered = filtered;\n\t\t}\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\t_fw: 1,\n\t_fh: 1,\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tsx = this._sx,\n\t\t\tsy = this._sy,\n\t\t\tw = size.width,\n\t\t\th = size.height;\n\t\tif (sx) {\n\t\t\tthis.x += (this.width - w) * sx;\n\t\t}\n\t\tif (sy) {\n\t\t\tthis.y += (this.height - h) * sy;\n\t\t}\n\t\tthis.width = w;\n\t\tthis.height = h;\n\t\tthis._fw = this._fh = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = left - this.x;\n\t\t\tthis.width -= this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = left;\n\t\tthis._sx = this._fw = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = top - this.y;\n\t\t\tthis.height -= this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = top;\n\t\tthis._sy = this._fh = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = right - this.x;\n\t\t\tthis.width = this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = right - this.width;\n\t\tthis._sx = 1;\n\t\tthis._fw = 0;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = bottom - this.y;\n\t\t\tthis.height = this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = bottom - this.height;\n\t\tthis._sy = 1;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width / 2;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tif (this._fw || this._sx === 0.5) {\n\t\t\tthis.x = x - this.width / 2;\n\t\t} else {\n\t\t\tif (this._sx) {\n\t\t\t\tthis.x += (x - this.x) * 2 * this._sx;\n\t\t\t}\n\t\t\tthis.width = (x - this.x) * 2;\n\t\t}\n\t\tthis._sx = 0.5;\n\t\tthis._fw = 0;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height / 2;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tif (this._fh || this._sy === 0.5) {\n\t\t\tthis.y = y - this.height / 2;\n\t\t} else {\n\t\t\tif (this._sy) {\n\t\t\t\tthis.y += (y - this.y) * 2 * this._sy;\n\t\t\t}\n\t\t\tthis.height = (y - this.y) * 2;\n\t\t}\n\t\tthis._sy = 0.5;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length === 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tepsilon = Base.read(arguments) || 0;\n\t\treturn rect.x + rect.width > this.x - epsilon\n\t\t\t\t&& rect.y + rect.height > this.y - epsilon\n\t\t\t\t&& rect.x < this.x + this.width + epsilon\n\t\t\t\t&& rect.y < this.y + this.height + epsilon;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join(''),\n\t\t\txFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis._set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tinternal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn !!(this._owner._selection & 2);\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner._changeSelection) {\n\t\t\t\t\towner._changeSelection(2, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg, _dontNotify) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count >= 6) {\n\t\t\tthis._set.apply(this, arguments);\n\t\t} else if (count === 1 || count === 2) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,\n\t\t\t\t\t\t_dontNotify);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis._set.apply(this,\n\t\t\t\t\t\t_dontNotify ? arg.concat([_dontNotify]) : arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (!count) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok) {\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t}\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(a, b, c, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._b = b;\n\t\tthis._c = c;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.getValues(), options, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(9);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._c),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._b), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._b = this._c = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t_setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._c;\n\t\tthis._ty += x * this._b + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar scale = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._b *= scale.x;\n\t\tthis._c *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * c;\n\t\tthis._b = cos * b + sin * d;\n\t\tthis._c = -sin * a + cos * c;\n\t\tthis._d = -sin * b + cos * d;\n\t\tthis._tx += tx * a + ty * c;\n\t\tthis._ty += tx * b + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar shear = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tb = this._b;\n\t\tthis._a += shear.y * this._c;\n\t\tthis._b += shear.y * this._d;\n\t\tthis._c += shear.x * a;\n\t\tthis._d += shear.x * b;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar skew = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tappend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * c1;\n\t\t\tthis._c = b2 * a1 + d2 * c1;\n\t\t\tthis._b = a2 * b1 + c2 * d1;\n\t\t\tthis._d = b2 * b1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * c1;\n\t\t\tthis._ty += tx2 * b1 + ty2 * d1;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tprepend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * b1;\n\t\t\tthis._c = a2 * c1 + b2 * d1;\n\t\t\tthis._b = c2 * a1 + d2 * b1;\n\t\t\tthis._d = c2 * c1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tappended: function(mx) {\n\t\treturn this.clone().append(mx);\n\t},\n\n\tprepended: function(mx) {\n\t\treturn this.clone().prepend(mx);\n\t},\n\n\tinvert: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tthis._a = d / det;\n\t\t\tthis._b = -b / det;\n\t\t\tthis._c = -c / det;\n\t\t\tthis._d = a / det;\n\t\t\tthis._tx = (c * ty - d * tx) / det;\n\t\t\tthis._ty = (b * tx - a * ty) / det;\n\t\t\tres = this;\n\t\t}\n\t\treturn res;\n\t},\n\n\tinverted: function() {\n\t\treturn this.clone().invert();\n\t},\n\n\tconcatenate: '#append',\n\tpreConcatenate: '#prepend',\n\tchain: '#appended',\n\n\t_shiftless: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n\t},\n\n\t_orNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\tisInvertible: function() {\n\t\tvar det = this._a * this._d - this._c * this._b;\n\t\treturn det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n\t},\n\n\tisSingular: function() {\n\t\treturn !this.isInvertible();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest._set(\n\t\t\t\tx * this._a + y * this._c + this._tx,\n\t\t\t\tx * this._b + y * this._d + this._ty,\n\t\t\t\t_dontNotify);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tfor (var i = 0, max = 2 * count; i < max; i += 2) {\n\t\t\tvar x = src[i],\n\t\t\t\ty = src[i + 1];\n\t\t\tdst[i] = x * this._a + y * this._c + this._tx;\n\t\t\tdst[i + 1] = x * this._b + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j]) {\n\t\t\t\tmin[j] = val;\n\t\t\t} else if (val > max[j]) {\n\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\tres = dest._set(\n\t\t\t\t\t(x * d - y * c) / det,\n\t\t\t\t\t(y * a - x * b) / det,\n\t\t\t\t\t_dontNotify);\n\t\t}\n\t\treturn res;\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\tdet = a * d - b * c,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tatan2 = Math.atan2,\n\t\t\tdegrees = 180 / Math.PI,\n\t\t\trotate,\n\t\t\tscale,\n\t\t\tskew;\n\t\tif (a !== 0 || b !== 0) {\n\t\t\tvar r = sqrt(a * a + b * b);\n\t\t\trotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n\t\t\tscale = [r, det / r];\n\t\t\tskew = [atan2(a * c + b * d, r * r), 0];\n\t\t} else if (c !== 0 || d !== 0) {\n\t\t\tvar s = sqrt(c * c + d * d);\n\t\t\trotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);\n\t\t\tscale = [det / s, s];\n\t\t\tskew = [0, atan2(a * c + b * d, s * s)];\n\t\t} else {\n\t\t\trotate = 0;\n\t\t\tskew = scale = [0, 0];\n\t\t}\n\t\treturn {\n\t\t\ttranslation: this.getTranslation(),\n\t\t\trotation: rotate * degrees,\n\t\t\tscaling: new Point(scale),\n\t\t\tskewing: new Point(skew[0] * degrees, skew[1] * degrees)\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._b, this._c, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn (this.decompose() || {}).scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn (this.decompose() || {}).rotation;\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tif (!this.isIdentity()) {\n\t\t\tctx.transform(this._a, this._b, this._c, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t}\n\t}\n}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {\n\tvar part = Base.capitalize(key),\n\t\tprop = '_' + key;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(this.getSignedDistance(point));\n\t},\n\n\tgetSignedDistance: function(point) {\n\t\treturn Line.getSignedDistance(this._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true);\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (!isInfinite && Numerical.isZero(ccw)) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t},\n\n\t\tgetDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\treturn Math.abs(\n\t\t\t\t\tLine.getSignedDistance(px, py, vx, vy, x, y, asVector));\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\t_compactSerialize: true,\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis._activeLayer = null;\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectionItems = {};\n\t\tthis._selectionCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this._children, options, true, dictionary);\n\t},\n\n\t_changed: function(flags, item) {\n\t\tif (flags & 1) {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview._needsUpdate = true;\n\t\t\t\tif (!view._requested && view._autoUpdate)\n\t\t\t\t\tview.requestUpdate();\n\t\t\t}\n\t\t}\n\t\tvar changes = this._changes;\n\t\tif (changes && item) {\n\t\t\tvar changesById = this._changesById,\n\t\t\t\tid = item._id,\n\t\t\t\tentry = changesById[id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tchanges.push(changesById[id] = { item: item, flags: flags });\n\t\t\t}\n\t\t}\n\t},\n\n\tclear: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--)\n\t\t\tchildren[i].remove();\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children.length;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.set(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetLayers: function() {\n\t\treturn this._children;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this, insert: true });\n\t},\n\n\tgetSymbolDefinitions: function() {\n\t\tvar definitions = [],\n\t\t\tids = {};\n\t\tthis.getItems({\n\t\t\tclass: SymbolItem,\n\t\t\tmatch: function(item) {\n\t\t\t\tvar definition = item._definition,\n\t\t\t\t\tid = definition._id;\n\t\t\t\tif (!ids[id]) {\n\t\t\t\t\tids[id] = true;\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn definitions;\n\t},\n\n\tgetSymbols: 'getSymbolDefinitions',\n\n\tgetSelectedItems: function() {\n\t\tvar selectionItems = this._selectionItems,\n\t\t\titems = [];\n\t\tfor (var id in selectionItems) {\n\t\t\tvar item = selectionItems[id],\n\t\t\t\tselection = item._selection;\n\t\t\tif ((selection & 1) && item.isInserted()) {\n\t\t\t\titems.push(item);\n\t\t\t} else if (!selection) {\n\t\t\t\tthis._updateSelection(item);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectionItems = this._selectionItems;\n\t\tif (item._selection) {\n\t\t\tif (selectionItems[id] !== item) {\n\t\t\t\tthis._selectionCount++;\n\t\t\t\tselectionItems[id] = item;\n\t\t\t}\n\t\t} else if (selectionItems[id] === item) {\n\t\t\tthis._selectionCount--;\n\t\t\tdelete selectionItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectionItems = this._selectionItems;\n\t\tfor (var i in selectionItems)\n\t\t\tselectionItems[i].setFullySelected(false);\n\t},\n\n\taddLayer: function(layer) {\n\t\treturn this.insertLayer(undefined, layer);\n\t},\n\n\tinsertLayer: function(index, layer) {\n\t\tif (layer instanceof Layer) {\n\t\t\tlayer._remove(false, true);\n\t\t\tBase.splice(this._children, [layer], index, 0);\n\t\t\tlayer._setProject(this, true);\n\t\t\tvar name = layer._name;\n\t\t\tif (name)\n\t\t\t\tlayer.setName(name);\n\t\t\tif (this._changes)\n\t\t\t\tlayer._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = layer;\n\t\t} else {\n\t\t\tlayer = null;\n\t\t}\n\t\treturn layer;\n\t},\n\n\t_insertItem: function(index, item, _created) {\n\t\titem = this.insertLayer(index, item)\n\t\t\t\t|| (this._activeLayer || this._insertItem(undefined,\n\t\t\t\t\t\tnew Layer(Item.NO_INSERT), true))\n\t\t\t\t\t\t.insertChild(index, item);\n\t\tif (_created && item.activate)\n\t\t\titem.activate();\n\t\treturn item;\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tremoveOn: function(type) {\n\t\tvar sets = this._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar children = this._children,\n\t\t\tparam = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].draw(ctx, param);\n\t\t}\n\t\tctx.restore();\n\n\t\tif (this._selectionCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectionItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items) {\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = Base.set({},\n\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_name: null,\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_canScaleStroke: false,\n\t_pivot: null,\n\t_visible: true,\n\t_blendMode: 'normal',\n\t_opacity: 1,\n\t_locked: false,\n\t_guide: false,\n\t_clipMask: false,\n\t_selection: 0,\n\t_selectBounds: true,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tlocked: false,\n\t\tguide: false,\n\t\tclipMask: false,\n\t\tselected: false,\n\t\tdata: {}\n\t},\n\t_prioritize: ['applyMatrix']\n},\nnew function() {\n\tvar handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];\n\treturn Base.each(handlers,\n\t\tfunction(name) {\n\t\t\tthis._events[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, 1);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, -1);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\t_events: {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tonLoad: {},\n\t\t\t\tonError: {}\n\t\t\t},\n\t\t\tstatics: {\n\t\t\t\t_itemHandlers: handlers\n\t\t\t}\n\t\t}\n\t);\n}, {\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project,\n\t\t\tsettings = paper.settings;\n\t\tthis._id = internal ? null : UID.get();\n\t\tthis._parent = this._index = null;\n\t\tthis._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (internal || hasProps && props.insert == false\n\t\t\t|| !settings.insertItems && !(hasProps && props.insert === true)) {\n\t\t\tthis._setProject(project);\n\t\t} else {\n\t\t\t(hasProps && props.parent || project)\n\t\t\t\t\t._insertItem(undefined, this, true);\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT) {\n\t\t\tthis.set(props, {\n\t\t\t\tinternal: true, insert: true, project: true, parent: true\n\t\t\t});\n\t\t}\n\t\treturn hasProps;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._symbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\tthis._globalMatrix = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 40)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project)\n\t\t\tproject._changed(flags, this);\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar owner = this._getOwner();\n\t\tif (name && owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tif (!(name in children))\n\t\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(128);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tkey = '_' + name,\n\t\t\tflags = {\n\t\t\t\tlocked: 128,\n\t\t\t\tvisible: 137\n\t\t\t};\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[key];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[key]) {\n\t\t\t\tthis[key] = value;\n\t\t\t\tthis._changed(flags[name] || 129);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tif (selection !== this._selection) {\n\t\t\tthis._selection = selection;\n\t\t\tvar project = this._project;\n\t\t\tif (project) {\n\t\t\t\tproject._updateSelection(this);\n\t\t\t\tthis._changed(129);\n\t\t\t}\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn !!(this._selection & 1);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisFullySelected: function() {\n\t\tvar children = this._children,\n\t\t\tselected = !!(this._selection & 1);\n\t\tif (children && selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(129);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(1024);\n\t\t}\n\t},\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar position = this._position,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\tif (!position) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tposition = this._position = pivot\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t}\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\tgetPivot: function() {\n\t\tvar pivot = this._pivot;\n\t\treturn pivot\n\t\t\t\t? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')\n\t\t\t\t: null;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t}\n}, Base.each({\n\t\tgetStrokeBounds: { stroke: true },\n\t\tgetHandleBounds: { handle: true },\n\t\tgetInternalBounds: { internal: true }\n\t},\n\tfunction(options, key) {\n\t\tthis[key] = function(matrix) {\n\t\t\treturn this.getBounds(matrix, options);\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\tgetBounds: function(matrix, options) {\n\t\tvar hasMatrix = options || matrix instanceof Matrix,\n\t\t\topts = Base.set({}, hasMatrix ? options : matrix,\n\t\t\t\t\tthis._boundsOptions);\n\t\tif (!opts.stroke || this.getStrokeScaling())\n\t\t\topts.cacheItem = this;\n\t\tvar rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n\t\treturn !arguments.length\n\t\t\t\t? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,\n\t\t\t\t\tthis, 'setBounds')\n\t\t\t\t: rect;\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\t_matrix = this._matrix,\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tif (!_matrix.isInvertible()) {\n\t\t\t\t_matrix.set(_matrix._backup\n\t\t\t\t\t\t|| new Matrix().translate(_matrix.getTranslation()));\n\t\t\t\tbounds = this.getBounds();\n\t\t\t}\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width !== 0 ? rect.width / bounds.width : 0,\n\t\t\t\t\tbounds.height !== 0 ? rect.height / bounds.height : 0);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar children = this._children;\n\t\tif (!children || !children.length)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, options.cacheItem);\n\t\treturn Item._getBounds(children, matrix, options);\n\t},\n\n\t_getBoundsCacheKey: function(options, internal) {\n\t\treturn [\n\t\t\toptions.stroke ? 1 : 0,\n\t\t\toptions.handle ? 1 : 0,\n\t\t\tinternal ? 1 : 0\n\t\t].join('');\n\t},\n\n\t_getCachedBounds: function(matrix, options, noInternal) {\n\t\tmatrix = matrix && matrix._orNullIfIdentity();\n\t\tvar internal = options.internal && !noInternal,\n\t\t\tcacheItem = options.cacheItem,\n\t\t\t_matrix = internal ? null : this._matrix._orNullIfIdentity(),\n\t\t\tcacheKey = cacheItem && (!matrix || matrix.equals(_matrix))\n\t\t\t\t&& this._getBoundsCacheKey(options, internal),\n\t\t\tbounds = this._bounds;\n\t\tItem._updateBoundsCache(this._parent || this._symbol, cacheItem);\n\t\tif (cacheKey && bounds && cacheKey in bounds) {\n\t\t\tvar cached = bounds[cacheKey];\n\t\t\treturn {\n\t\t\t\trect: cached.rect.clone(),\n\t\t\t\tnonscaling: cached.nonscaling\n\t\t\t};\n\t\t}\n\t\tvar res = this._getBounds(matrix || _matrix, options),\n\t\t\trect = res.rect || res,\n\t\t\tstyle = this._style,\n\t\t\tnonscaling = res.nonscaling || style.hasStroke()\n\t\t\t\t&& !style.getStrokeScaling();\n\t\tif (cacheKey) {\n\t\t\tif (!bounds) {\n\t\t\t\tthis._bounds = bounds = {};\n\t\t\t}\n\t\t\tvar cached = bounds[cacheKey] = {\n\t\t\t\trect: rect.clone(),\n\t\t\t\tnonscaling: nonscaling,\n\t\t\t\tinternal: internal\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trect: rect,\n\t\t\tnonscaling: nonscaling\n\t\t};\n\t},\n\n\t_getStrokeMatrix: function(matrix, options) {\n\t\tvar parent = this.getStrokeScaling() ? null\n\t\t\t\t: options && options.internal ? this\n\t\t\t\t\t: this._parent || this._symbol && this._symbol._item,\n\t\t\tmx = parent ? parent.getViewMatrix().invert() : matrix;\n\t\treturn mx && mx._shiftless();\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent && item) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getBounds: function(items, matrix, options) {\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2,\n\t\t\t\tnonscaling = false;\n\t\t\toptions = options || {};\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._visible && !item.isEmpty()) {\n\t\t\t\t\tvar bounds = item._getCachedBounds(\n\t\t\t\t\t\tmatrix && matrix.appended(item._matrix), options, true),\n\t\t\t\t\t\trect = bounds.rect;\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t\tif (bounds.nonscaling)\n\t\t\t\t\t\tnonscaling = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\trect: isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle(),\n\t\t\t\tnonscaling: nonscaling\n\t\t\t};\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._applyMatrix\n\t\t\t? null\n\t\t\t: this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed ? decomposed.rotation : 0;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\ts = decomposed && decomposed.scaling;\n\t\treturn new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling && !current.equals(scaling)) {\n\t\t\tvar rotation = this.getRotation(),\n\t\t\t\tdecomposed = this._decomposed,\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tcenter = this.getPosition(true);\n\t\t\tmatrix.translate(center);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(rotation);\n\t\t\tmatrix.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(-rotation);\n\t\t\tmatrix.translate(center.negate());\n\t\t\tthis.transform(matrix);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix,\n\t\t\tupdateVersion = this._project._updateVersion;\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\tmatrix = null;\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.prepend(parent.getGlobalMatrix(true));\n\t\t\tmatrix._updateVersion = updateVersion;\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetViewMatrix: function() {\n\t\treturn this.getGlobalMatrix().prepend(this.getView()._matrix);\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\t_getOwner: '#getParent',\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(options) {\n\t\tvar copy = new this.constructor(Item.NO_INSERT),\n\t\t\tchildren = this._children,\n\t\t\tinsert = Base.pick(options ? options.insert : undefined,\n\t\t\t\t\toptions === undefined || options === true),\n\t\t\tdeep = Base.pick(options ? options.deep : undefined, true);\n\t\tif (children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (!children || deep)\n\t\t\tcopy.copyContent(this);\n\t\tif (!children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (insert)\n\t\t\tcopy.insertAbove(this);\n\t\tvar name = this._name,\n\t\t\tparent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\tif (name !== orig)\n\t\t\t\tcopy.setName(name);\n\t\t}\n\t\treturn copy;\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar children = source._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tthis.addChild(children[i].clone(false), true);\n\t\t}\n\t},\n\n\tcopyAttributes: function(source, excludeMatrix) {\n\t\tthis.setStyle(source._style);\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (source.hasOwnProperty(key))\n\t\t\t\tthis[key] = source[key];\n\t\t}\n\t\tif (!excludeMatrix)\n\t\t\tthis._matrix.set(source._matrix, true);\n\t\tthis.setApplyMatrix(source._applyMatrix);\n\t\tthis.setPivot(source._pivot);\n\t\tthis.setSelection(source._selection);\n\t\tvar data = source._data,\n\t\t\tname = source._name;\n\t\tthis._data = data ? Base.clone(data) : null;\n\t\tif (name)\n\t\t\tthis.setName(name);\n\t},\n\n\trasterize: function(resolution, insert) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\tif (!size.isZero()) {\n\t\t\tvar canvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t\traster.setCanvas(canvas);\n\t\t}\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t.scale(1 / scale));\n\t\tif (insert === undefined || insert)\n\t\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\treturn !!this._contains(\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t},\n\n\t_contains: function(point) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tif (children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix, true).length > 0;\n\t}\n},\nnew function() {\n\tfunction hitTest() {\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(arguments),\n\t\t\t\tHitResult.getOptions(arguments));\n\t}\n\n\tfunction hitTestAll() {\n\t\tvar point = Point.read(arguments),\n\t\t\toptions = HitResult.getOptions(arguments),\n\t\t\tall = [];\n\t\tthis._hitTest(point, Base.set({ all: all }, options));\n\t\treturn all;\n\t}\n\n\tfunction hitTestChildren(point, options, viewMatrix, _exclude) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar res = child !== _exclude && child._hitTest(point, options,\n\t\t\t\t\t\tviewMatrix);\n\t\t\t\tif (res && !options.all)\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tProject.inject({\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTest: hitTestChildren\n\t});\n\n\treturn {\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTestChildren: hitTestChildren,\n\t};\n}, {\n\n\t_hitTest: function(point, options, parentViewMatrix) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar matrix = this._matrix,\n\t\t\tviewMatrix = parentViewMatrix\n\t\t\t\t\t? parentViewMatrix.appended(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().prepend(this.getView()._matrix),\n\t\t\ttolerance = Math.max(options.tolerance, 1e-12),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\tPath._getStrokePadding(tolerance,\n\t\t\t\t\t\tmatrix._shiftless().invert()));\n\t\tpoint = matrix._inverseTransform(point);\n\t\tif (!point || !this._children &&\n\t\t\t!this.getBounds({ internal: true, stroke: true, handle: true })\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this.isSelected()\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tmatch = options.match,\n\t\t\tthat = this,\n\t\t\tbounds,\n\t\t\tres;\n\n\t\tfunction filter(hit) {\n\t\t\tif (hit && match && !match(hit))\n\t\t\t\thit = null;\n\t\t\tif (hit && options.all)\n\t\t\t\toptions.all.push(hit);\n\t\t\treturn hit;\n\t\t}\n\n\t\tfunction checkPoint(type, part) {\n\t\t\tvar pt = part ? bounds['get' + part]() : that.getPosition();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1) {\n\t\t\t\treturn new HitResult(type, that, {\n\t\t\t\t\tname: part ? Base.hyphenate(part) : type,\n\t\t\t\t\tpoint: pt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar checkPosition = options.position,\n\t\t\tcheckCenter = options.center,\n\t\t\tcheckBounds = options.bounds;\n\t\tif (checkSelf && this._parent\n\t\t\t\t&& (checkPosition || checkCenter || checkBounds)) {\n\t\t\tif (checkCenter || checkBounds) {\n\t\t\t\tbounds = this.getInternalBounds();\n\t\t\t}\n\t\t\tres = checkPosition && checkPoint('position') ||\n\t\t\t\t\tcheckCenter && checkPoint('center', 'Center');\n\t\t\tif (!res && checkBounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++) {\n\t\t\t\t\tres = checkPoint('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = filter(res);\n\t\t}\n\n\t\tif (!res) {\n\t\t\tres = this._hitTestChildren(point, options, viewMatrix)\n\t\t\t\t|| checkSelf\n\t\t\t\t\t&& filter(this._hitTestSelf(point, options, viewMatrix,\n\t\t\t\t\t\tthis.getStrokeScaling() ? null\n\t\t\t\t\t\t\t: viewMatrix._shiftless().invert()))\n\t\t\t\t|| null;\n\t\t}\n\t\tif (res && res.point) {\n\t\t\tres.point = matrix.transform(res.point);\n\t\t}\n\t\treturn res;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else if (name === 'match') {\n\t\t\treturn compare(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (name === 'class') {\n\t\t\t\tif (typeof compare === 'function')\n\t\t\t\t\treturn this instanceof compare;\n\t\t\t\tvalue = this._class;\n\t\t\t}\n\t\t\tif (typeof compare === 'function') {\n\t\t\t\treturn !!compare(value);\n\t\t\t} else if (compare) {\n\t\t\t\tif (compare.test) {\n\t\t\t\t\treturn compare.test(value);\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\treturn matchObject(compare, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Base.equals(value, compare);\n\t\t}\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix, null, true)[0]\n\t\t\t\t|| null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(item, options, matrix, param, firstOnly) {\n\t\t\tif (!param) {\n\t\t\t\tvar obj = typeof options === 'object' && options,\n\t\t\t\t\toverlapping = obj && obj.overlapping,\n\t\t\t\t\tinside = obj && obj.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\trecursive: obj && obj.recursive !== false,\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (obj) {\n\t\t\t\t\toptions = Base.filter({}, options, {\n\t\t\t\t\t\trecursive: true, inside: true, overlapping: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = item._children,\n\t\t\t\titems = param.items,\n\t\t\t\trect = param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.appended(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(rect.contains(bounds)\n\t\t\t\t\t\t\t|| param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(options)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (param.recursive !== false) {\n\t\t\t\t\t_getItems(child, options, childMatrix, param, firstOnly);\n\t\t\t\t}\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this ? this.addChild(res) : res;\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tvar res = item ? this.insertChildren(index, [item]) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items) {\n\t\treturn this.insertChildren(this._children.length, items);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Base.slice(items);\n\t\t\tvar inserted = {};\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tid = item && item._id;\n\t\t\t\tif (!item || inserted[id]) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\titem._remove(false, true);\n\t\t\t\t\tinserted[id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tname = item._name;\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(project, true);\n\t\t\t\tif (name)\n\t\t\t\t\titem.setName(name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\titem._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertItem: '#insertChild',\n\n\t_insertAt: function(item, offset) {\n\t\tvar owner = item && item._getOwner(),\n\t\t\tres = item !== this && owner ? this : null;\n\t\tif (res) {\n\t\t\tres._remove(false, true);\n\t\t\towner._insertItem(item._index + offset, res);\n\t\t}\n\t\treturn res;\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn this._insertAt(item, 1);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn this._insertAt(item, 0);\n\t},\n\n\tsendToBack: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(0, this) : null;\n\t},\n\n\tbringToFront: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(undefined, this) : null;\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\taddTo: function(owner) {\n\t\treturn owner._insertItem(undefined, this);\n\t},\n\n\tcopyTo: function(owner) {\n\t\treturn this.clone(false).addTo(owner);\n\t},\n\n\treduce: function(options) {\n\t\tvar children = this._children;\n\t\tif (children && children.length === 1) {\n\t\t\tvar child = children[0].reduce(options);\n\t\t\tif (this._parent) {\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tthis.remove();\n\t\t\t} else {\n\t\t\t\tchild.remove();\n\t\t\t}\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar owner = this._getOwner();\n\t\tif (owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[0];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar owner = this._getOwner(),\n\t\t\tproject = this._project,\n\t\t\tindex = this._index;\n\t\tif (owner) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (index != null) {\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(owner._children, null, index, 1);\n\t\t\t}\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent)\n\t\t\t\towner._changed(11, this);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(start, end) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, start, end - start);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function() {\n\t\tvar children = this._children;\n\t\treturn !children || !children.length;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent === item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t_setApplyMatrix) {\n\t\tvar _matrix = this._matrix,\n\t\t\ttransform = matrix && !matrix.isIdentity(),\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t&& ((!_matrix.isIdentity() || transform)\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\tif (!transform && !applyMatrix)\n\t\t\treturn this;\n\t\tif (transform) {\n\t\t\tif (!matrix.isInvertible() && _matrix.isInvertible())\n\t\t\t\t_matrix._backup = _matrix.getValues();\n\t\t\t_matrix.prepend(matrix, true);\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\t\tif (applyMatrix && (applyMatrix = this._transformContent(_matrix,\n\t\t\t\t_applyRecursively, _setApplyMatrix))) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tif (transform || applyMatrix) {\n\t\t\tthis._changed(9);\n\t\t}\n\t\tvar decomp = transform && bounds && matrix.decompose();\n\t\tif (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar cache = bounds[key];\n\t\t\t\tif (cache.nonscaling) {\n\t\t\t\t\tdelete bounds[key];\n\t\t\t\t} else if (applyMatrix || !cache.internal) {\n\t\t\t\t\tvar rect = cache.rect;\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bounds = bounds;\n\t\t\tvar cached = bounds[this._getBoundsCacheKey(\n\t\t\t\t\tthis._boundsOptions || {})];\n\t\t\tif (cached) {\n\t\t\t\tthis._position = cached.rect.getCenter(true);\n\t\t\t}\n\t\t} else if (transform && position && this._pivot) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\tsetApplyMatrix);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t}\n}), {\n\n\t_setStyles: function(ctx, param, viewMatrix) {\n\t\tvar style = this._style,\n\t\t\tmatrix = this._matrix;\n\t\tif (style.hasFill()) {\n\t\t\tctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n\t\t}\n\t\tif (style.hasStroke()) {\n\t\t\tctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n\t\t\tctx.lineWidth = style.getStrokeWidth();\n\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\tif (strokeJoin)\n\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\tif (strokeCap)\n\t\t\t\tctx.lineCap = strokeCap;\n\t\t\tif (miterLimit)\n\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\tif (paper.support.nativeDash) {\n\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (style.hasShadow()) {\n\t\t\tvar pixelRatio = param.pixelRatio || 1,\n\t\t\t\tmx = viewMatrix._shiftless().prepend(\n\t\t\t\t\tnew Matrix().scale(pixelRatio, pixelRatio)),\n\t\t\t\tblur = mx.transform(new Point(style.getShadowBlur(), 0)),\n\t\t\t\toffset = mx.transform(this.getShadowOffset());\n\t\t\tctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n\t\t\tctx.shadowBlur = blur.getLength();\n\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\tctx.shadowOffsetY = offset.y;\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].appended(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tviewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)\n\t\t\t\t: globalMatrix;\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = this._opacity,\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(viewMatrix);\n\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\treturn;\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.appended(matrix)\n\t\t\t\t: this._canScaleStroke && !this.getStrokeScaling(true)\n\t\t\t\t\t&& viewMatrix,\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform) {\n\t\t\t(direct ? matrix : viewMatrix).applyToContext(ctx);\n\t\t}\n\t\tif (clip) {\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, viewMatrix, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish)\n\t\t\tctx.clip();\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n\t\tvar selection = this._selection,\n\t\t\titemSelected = selection & 1,\n\t\t\tboundsSelected = selection & 2\n\t\t\t\t\t|| itemSelected && this._selectBounds,\n\t\t\tpositionSelected = selection & 4;\n\t\tif (!this._drawSelected)\n\t\t\titemSelected = false;\n\t\tif ((itemSelected || boundsSelected || positionSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar layer,\n\t\t\t\tcolor = this.getSelectedColor(true) || (layer = this.getLayer())\n\t\t\t\t\t&& layer.getSelectedColor(true),\n\t\t\t\tmx = matrix.appended(this.getGlobalMatrix(true)),\n\t\t\t\thalf = size / 2;\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (itemSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectionItems);\n\t\t\tif (positionSelected) {\n\t\t\t\tvar point = this.getPosition(true),\n\t\t\t\t\tx = point.x,\n\t\t\t\t\ty = point.y;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.stroke();\n\t\t\t\tvar deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],\n\t\t\t\t\tstart = half,\n\t\t\t\t\tend = size + 1;\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar delta = deltas[i],\n\t\t\t\t\t\tdx = delta[0],\n\t\t\t\t\t\tdy = delta[1];\n\t\t\t\t\tctx.moveTo(x + dx * start, y + dy * start);\n\t\t\t\t\tctx.lineTo(x + dx * end, y + dy * end);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (boundsSelected) {\n\t\t\t\tvar coords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(key) {\n\tthis['removeOn' + Base.capitalize(key)] = function() {\n\t\tvar hash = {};\n\t\thash[key] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}));\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectBounds: false,\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 1026) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i]._clipMask) {\n\t\t\t\t\tclipItem = children[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_getBounds: function _getBounds(matrix, options) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn clipItem\n\t\t\t? clipItem._getCachedBounds(\n\t\t\t\tmatrix && matrix.appended(clipItem._matrix),\n\t\t\t\tBase.set({}, options, { stroke: false }))\n\t\t\t: _getBounds.base.call(this, matrix, options);\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn (!clipItem || clipItem.contains(point))\n\t\t\t\t&& _hitTestChildren.base.call(this, point, options, viewMatrix,\n\t\t\t\t\tclipItem);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem();\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tctx.beginPath();\n\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar item = children[i];\n\t\t\tif (item !== clipItem)\n\t\t\t\titem.draw(ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer() {\n\t\tGroup.apply(this, arguments);\n\t},\n\n\t_getOwner: function() {\n\t\treturn this._parent || this._index != null && this._project;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_hitTestSelf: function() {\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_canScaleStroke: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props, point) {\n\t\tthis._initialize(props, point);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setType(source._type);\n\t\tthis.setSize(source._size);\n\t\tthis.setRadius(source._radius);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tthis._radius.set(Size.min(this._radius, size.divide(2)));\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius._set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size._set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size._set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size._set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t});\n\t\tpath.copyAttributes(this);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\tif (insert === undefined || insert)\n\t\t\tpath.insertAbove(this);\n\t\treturn path;\n\t},\n\n\ttoShape: '#clone',\n\n\t_asPathItem: function() {\n\t\treturn this.toPath(false);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\tstyle = this._style,\n\t\t\tstrokeWidth = options.stroke && style.hasStroke()\n\t\t\t\t\t&& style.getStrokeWidth();\n\t\tif (matrix)\n\t\t\trect = matrix._transformBounds(rect);\n\t\treturn strokeWidth\n\t\t\t\t? rect.expand(Path._getStrokePadding(strokeWidth,\n\t\t\t\t\tthis._getStrokeMatrix(matrix, options)))\n\t\t\t\t: rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var q = 1; q <= 4; q++) {\n\t\t\t\tvar dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(\n\t\t\t\t\t\t\texpand ? corner.add(dir.multiply(expand)) : corner,\n\t\t\t\t\t\t\tcenter);\n\t\t\t\tif (rect.contains(point))\n\t\t\t\t\treturn { point: center, quadrant: q };\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isOnEllipseStroke(point, radius, padding, quadrant) {\n\t\tvar vector = point.divide(radius);\n\t\treturn (!quadrant || vector.isInQuadrant(quadrant)) &&\n\t\t\t\tvector.subtract(vector.normalize()).multiply(radius)\n\t\t\t\t\t.divide(padding).length <= 1;\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center.point).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,\n\t\t\t\tstrokeMatrix) {\n\t\t\tvar hit = false,\n\t\t\t\tstyle = this._style,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill();\n\t\t\tif (hitStroke || hitFill) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\t\tstrokePadding = options._tolerancePadding.add(\n\t\t\t\t\t\tPath._getStrokePadding(strokeRadius,\n\t\t\t\t\t\t\t!style.getStrokeScaling() && strokeMatrix));\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar padding = strokePadding.multiply(2),\n\t\t\t\t\t\tcenter = getCornerCenter(this, point, padding);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\thit = isOnEllipseStroke(point.subtract(center.point),\n\t\t\t\t\t\t\t\tradius, strokePadding, center.quadrant);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(padding),\n\t\t\t\t\t\t\tinner = rect.expand(padding.negate());\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thit = isOnEllipseStroke(point, radius, strokePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = new Shape(Base.getNamed(args), point);\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\treturn item;\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targuments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, arguments);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: false, handle: false },\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\t_prioritize: ['crossOrigin'],\n\n\tinitialize: function Raster(object, position) {\n\t\tif (!this._initialize(object,\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\tvar image = typeof object === 'string'\n\t\t\t\t\t? document.getElementById(object) : object;\n\t\t\tif (image) {\n\t\t\t\tthis.setImage(image);\n\t\t\t} else {\n\t\t\t\tthis.setSource(object);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar image = source._image,\n\t\t\tcanvas = source._canvas;\n\t\tif (image) {\n\t\t\tthis._setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(source._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tthis._setImage(copyCanvas);\n\t\t}\n\t\tthis._crossOrigin = source._crossOrigin;\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = this.getElement();\n\t\t\t\tthis._setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element)\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tgetLoaded: function() {\n\t\treturn this._loaded;\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tvar that = this;\n\n\t\tfunction emit(event) {\n\t\t\tvar view = that.getView(),\n\t\t\t\ttype = event && event.type || 'load';\n\t\t\tif (view && that.responds(type)) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.emit(type, new Event(event));\n\t\t\t}\n\t\t}\n\n\t\tthis._setImage(image);\n\t\tif (this._loaded) {\n\t\t\tsetTimeout(emit, 0);\n\t\t} else if (image) {\n\t\t\tDomEvent.add(image, {\n\t\t\t\tload: function(event) {\n\t\t\t\t\tthat._setImage(image);\n\t\t\t\t\temit(event);\n\t\t\t\t},\n\t\t\t\terror: emit\n\t\t\t});\n\t\t}\n\t},\n\n\t_setImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = !!(image && image.src && image.complete);\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(521);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(modify) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (modify) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(513);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar image = new self.Image(),\n\t\t\tcrossOrigin = this._crossOrigin;\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\timage.src = src;\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tvar image = this._image;\n\t\tif (image)\n\t\t\timage.crossOrigin = crossOrigin;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster._setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.prepend(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar image = this._image,\n\t\t\tsrc = image && image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (typeof object === 'object') {\n\t\t\tif ('width' in object) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if ('x' in object) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t}\n\t\tif (!bounds)\n\t\t\treturn null;\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcolor = Color.read(arguments),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx) {\n\t\tvar element = this.getElement();\n\t\tif (element) {\n\t\t\tctx.globalAlpha = this._opacity;\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar SymbolItem = Item.extend({\n\t_class: 'SymbolItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: true },\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function SymbolItem(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setDefinition(arg0 instanceof SymbolDefinition ?\n\t\t\t\t\targ0 : new SymbolDefinition(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._definition === item._definition;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setDefinition(source._definition);\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(definition) {\n\t\tthis._definition = definition;\n\t\tthis._changed(9);\n\t},\n\n\tgetSymbol: '#getDefinition',\n\tsetSymbol: '#setDefinition',\n\n\tisEmpty: function() {\n\t\treturn this._definition._item.isEmpty();\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar item = this._definition._item;\n\t\treturn item._getCachedBounds(item._matrix.prepended(matrix), options);\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix) {\n\t\tvar res = this._definition._item._hitTest(point, options, viewMatrix);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis._definition._item.draw(ctx, param);\n\t}\n\n});\n\nvar SymbolDefinition = Base.extend({\n\t_class: 'SymbolDefinition',\n\n\tinitialize: function SymbolDefinition(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tif (item)\n\t\t\tthis.setItem(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._item],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8)\n\t\t\tItem._clearBoundsCache(this);\n\t\tif (flags & 1)\n\t\t\tthis.project._changed(flags);\n\t},\n\n\tgetItem: function() {\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item, _dontCenter) {\n\t\tif (item._symbol)\n\t\t\titem = item.clone();\n\t\tif (this._item)\n\t\t\tthis._item._symbol = null;\n\t\tthis._item = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._symbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tgetDefinition: '#getItem',\n\tsetDefinition: '#setItem',\n\n\tplace: function(position) {\n\t\treturn new SymbolItem(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new SymbolDefinition(this._item.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this._item.equals(symbol._item)\n\t\t\t\t|| false;\n\t}\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values)\n\t\t\tthis.inject(values);\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(args) {\n\t\t\tvar options = args && Base.read(args);\n\t\t\treturn Base.set({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tposition: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\t_selection: 0,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut, selection;\n\t\tif (count > 0) {\n\t\t\tif (arg0 == null || typeof arg0 === 'object') {\n\t\t\t\tif (count === 1 && arg0 && 'point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t\tselection = arg0.selection;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t\thandleIn = arg1;\n\t\t\t\t\thandleOut = arg2;\n\t\t\t\t\tselection = arg3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\tif (selection)\n\t\t\tthis.setSelection(selection);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar point = this._point,\n\t\t\tselection = this._selection,\n\t\t\tobj = selection || this.hasHandles()\n\t\t\t\t\t? [point, this._handleIn, this._handleOut]\n\t\t\t\t\t: point;\n\t\tif (selection)\n\t\t\tobj.push(selection);\n\t\treturn Base.serialize(obj, options, true, dictionary);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(25);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tthis._point.set(Point.read(arguments));\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tthis._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tthis._handleOut.set(Point.read(arguments));\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tisSmooth: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut;\n\t\treturn !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t&& handleIn.isCollinear(handleOut);\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn._set(0, 0);\n\t\tthis._handleOut._set(0, 0);\n\t},\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tvar oldSelection = this._selection,\n\t\t\tpath = this._path;\n\t\tthis._selection = selection = selection || 0;\n\t\tif (path && selection !== oldSelection) {\n\t\t\tpath._updateSelection(this, oldSelection, selection);\n\t\t\tpath._changed(129);\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._selection & 7);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._changeSelection(7, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tsmooth: function(options, _first, _last) {\n\t\tvar opts = options || {},\n\t\t\ttype = opts.type,\n\t\t\tfactor = opts.factor,\n\t\t\tprev = this.getPrevious(),\n\t\t\tnext = this.getNext(),\n\t\t\tp0 = (prev || this)._point,\n\t\t\tp1 = this._point,\n\t\t\tp2 = (next || this)._point,\n\t\t\td1 = p0.getDistance(p1),\n\t\t\td2 = p1.getDistance(p2);\n\t\tif (!type || type === 'catmull-rom') {\n\t\t\tvar a = factor === undefined ? 0.5 : factor,\n\t\t\t\td1_a = Math.pow(d1, a),\n\t\t\t\td1_2a = d1_a * d1_a,\n\t\t\t\td2_a = Math.pow(d2, a),\n\t\t\t\td2_2a = d2_a * d2_a;\n\t\t\tif (!_first && prev) {\n\t\t\t\tvar A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,\n\t\t\t\t\tN = 3 * d2_a * (d2_a + d1_a);\n\t\t\t\tthis.setHandleIn(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,\n\t\t\t\t\t\t(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t\tif (!_last && next) {\n\t\t\t\tvar A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,\n\t\t\t\t\tN = 3 * d1_a * (d1_a + d2_a);\n\t\t\t\tthis.setHandleOut(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,\n\t\t\t\t\t\t(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t} else if (type === 'geometric') {\n\t\t\tif (prev && next) {\n\t\t\t\tvar vector = p0.subtract(p2),\n\t\t\t\t\tt = factor === undefined ? 0.4 : factor,\n\t\t\t\t\tk = t * d1 / (d1 + d2);\n\t\t\t\tif (!_first)\n\t\t\t\t\tthis.setHandleIn(vector.multiply(k));\n\t\t\t\tif (!_last)\n\t\t\t\t\tthis.setHandleOut(vector.multiply(k - t));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Smoothing method \\'' + type + '\\' not supported.');\n\t\t}\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\ttmp = handleIn.clone();\n\t\thandleIn.set(handleOut);\n\t\thandleOut.set(tmp);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar u = 1 - factor,\n\t\t\tv = factor,\n\t\t\tpoint1 = from._point,\n\t\t\tpoint2 = to._point,\n\t\t\thandleIn1 = from._handleIn,\n\t\t\thandleIn2 = to._handleIn,\n\t\t\thandleOut2 = to._handleOut,\n\t\t\thandleOut1 = from._handleOut;\n\t\tthis._point._set(\n\t\t\t\tu * point1._x + v * point2._x,\n\t\t\t\tu * point1._y + v * point2._y, true);\n\t\tthis._handleIn._set(\n\t\t\t\tu * handleIn1._x + v * handleIn2._x,\n\t\t\t\tu * handleIn1._y + v * handleIn2._y, true);\n\t\tthis._handleOut._set(\n\t\t\t\tu * handleOut1._x + v * handleOut2._x,\n\t\t\t\tu * handleOut1._y + v * handleOut2._y, true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y,\n\t\t\tselected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\t_set: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this._x) && isZero(this._y);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\tvar owner = this._owner;\n\t\treturn this === owner._point ? 1\n\t\t\t: this === owner._handleIn ? 2\n\t\t\t: this === owner._handleOut ? 4\n\t\t\t: 0;\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\tbeans: true,\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (!count) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tclassify: function() {\n\t\treturn Curve.classify(this.getValues());\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tthis._segment1._point.set(Point.read(arguments));\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tthis._segment2._point.set(Point.read(arguments));\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tthis._segment1._handleOut.set(Point.read(arguments));\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tthis._segment2._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._segment1._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t}\n}, {\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tdivideAt: function(location) {\n\t\treturn this.divideAtTime(location && location.curve === this\n\t\t\t\t? location.time : this.getTimeAt(location));\n\t},\n\n\tdivideAtTime: function(time, _setHandles) {\n\t\tvar tMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (time >= tMin && time <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), time),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tseg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tseg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n\t\t\t\tseg2._handleIn._set(right[4] - right[6],right[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(seg1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tthis._changed();\n\t\t\t\tres = new Curve(segment, seg2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar path = this._path;\n\t\treturn path ? path.splitAt(location) : null;\n\t},\n\n\tsplitAtTime: function(time) {\n\t\treturn this.splitAt(this.getLocationAtTime(time));\n\t},\n\n\tdivide: function(offset, isTime) {\n\t\treturn this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\tsplit: function(offset, isTime) {\n\t\treturn this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut._set(0, 0);\n\t\tthis._segment2._handleIn._set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix, straight) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tx1 = p1.x, y1 = p1.y,\n\t\t\tx2 = p2.x, y2 = p2.y,\n\t\t\tvalues = straight\n\t\t\t\t? [ x1, y1, x1, y1, x2, y2, x2, y2 ]\n\t\t\t\t: [\n\t\t\t\t\tx1, y1,\n\t\t\t\t\tx1 + h1._x, y1 + h1._y,\n\t\t\t\t\tx2 + h2._x, y2 + h2._y,\n\t\t\t\t\tx2, y2\n\t\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tx4 = u * x0 + t * x1, y4 = u * y0 + t * y1,\n\t\t\tx5 = u * x1 + t * x2, y5 = u * y1 + t * y2,\n\t\t\tx6 = u * x2 + t * x3, y6 = u * y2 + t * y3,\n\t\t\tx7 = u * x4 + t * x5, y7 = u * y4 + t * y5,\n\t\t\tx8 = u * x5 + t * x6, y8 = u * y5 + t * y6,\n\t\t\tx9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n\t\treturn [\n\t\t\t[x0, y0, x4, y4, x7, y7, x9, y9],\n\t\t\t[x9, y9, x8, y8, x6, y6, x3, y3]\n\t\t];\n\t},\n\n\tgetMonoCurves: function(v, dir) {\n\t\tvar curves = [],\n\t\t\tio = dir ? 0 : 1,\n\t\t\to0 = v[io + 0],\n\t\t\to1 = v[io + 2],\n\t\t\to2 = v[io + 4],\n\t\t\to3 = v[io + 6];\n\t\tif ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)\n\t\t\t\t|| Curve.isStraight(v)) {\n\t\t\tcurves.push(v);\n\t\t} else {\n\t\t\tvar a = 3 * (o1 - o2) - o0 + o3,\n\t\t\t\tb = 2 * (o0 + o2) - 4 * o1,\n\t\t\t\tc = o1 - o0,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [],\n\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\tif (!n) {\n\t\t\t\tcurves.push(v);\n\t\t\t} else {\n\t\t\t\troots.sort();\n\t\t\t\tvar t = roots[0],\n\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\tcurves.push(parts[0]);\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\tcurves.push(parts[0]);\n\t\t\t\t}\n\t\t\t\tcurves.push(parts[1]);\n\t\t\t}\n\t\t}\n\t\treturn curves;\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar v0 = v[coord],\n\t\t\tv1 = v[coord + 2],\n\t\t\tv2 = v[coord + 4],\n\t\t\tv3 = v[coord + 6],\n\t\t\tres = 0;\n\t\tif (  !(v0 < val && v3 < val && v1 < val && v2 < val ||\n\t\t\t\tv0 > val && v3 > val && v1 > val && v2 > val)) {\n\t\t\tvar c = 3 * (v1 - v0),\n\t\t\t\tb = 3 * (v2 - v1) - c,\n\t\t\t\ta = v3 - v0 - c - b;\n\t\t\tres = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n\t\t}\n\t\treturn res;\n\t},\n\n\tgetTimeOf: function(v, point) {\n\t\tvar p0 = new Point(v[0], v[1]),\n\t\t\tp3 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tt = point.isClose(p0, epsilon) ? 0\n\t\t\t  : point.isClose(p3, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t === null) {\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [];\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar u = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, u), geomEpsilon))\n\t\t\t\t\t\treturn u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p0, geomEpsilon) ? 0\n\t\t\t : point.isClose(p3, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestTime: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tvx = x3 - x0, vy = y3 - y0,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getTimeOf(v,\n\t\t\t\t\tnew Point(x0 + u * vx, y0 + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 1e-8) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\tisFlatEnough: function(v, flatness) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tux = 3 * x1 - 2 * x0 - x3,\n\t\t\tuy = 3 * y1 - 2 * y0 - y3,\n\t\t\tvx = 3 * x2 - 2 * x3 - x0,\n\t\t\tvy = 3 * y2 - 2 * y3 - y0;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t<= 16 * flatness * flatness;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)\n\t\t\t\t+ y1 * (x0 - x2) - x1 * (y0 - y2)\n\t\t\t\t+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\n\t\tpadding /= 2;\n\t\tvar minPad = min[coord] - padding,\n\t\t\tmaxPad = max[coord] + padding;\n\t\tif (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||\n\t\t\t\tv0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n\t\t\tif (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n\t\t\t\tadd(v0, padding);\n\t\t\t\tadd(v3, padding);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0,\n\t\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\t\ttMin = 1e-8,\n\t\t\t\t\ttMax = 1 - tMin;\n\t\t\t\tadd(v3, 0);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar t = roots[i],\n\t\t\t\t\t\tu = 1 - t;\n\t\t\t\t\tif (tMin <= t && t <= tMax)\n\t\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\t\tpadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false, this._path);\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(p1, h1, h2, p2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar v = p2.subtract(p1);\n\t\t\tif (v.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n\t\t\t\tvar l = new Line(p1, p2),\n\t\t\t\t\tepsilon = 1e-7;\n\t\t\t\tif (l.getDistance(p1.add(h1)) < epsilon &&\n\t\t\t\t\tl.getDistance(p2.add(h2)) < epsilon) {\n\t\t\t\t\tvar div = v.dot(v),\n\t\t\t\t\t\ts1 = v.dot(h1) / div,\n\t\t\t\t\t\ts2 = v.dot(h2) / div;\n\t\t\t\t\treturn s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(p1, h1, h2, p2) {\n\t\tvar third = p2.subtract(p1).divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function(epsilon) {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,\n\t\t\t\tepsilon);\n\t};\n\n\tthis.statics[name] = function(v, epsilon) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn test(\n\t\t\t\tnew Point(x0, y0),\n\t\t\t\tnew Point(v[2] - x0, v[3] - y0),\n\t\t\t\tnew Point(v[4] - x3, v[5] - y3),\n\t\t\t\tnew Point(x3, y3), epsilon);\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\thasLength: function(epsilon) {\n\t\treturn (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())\n\t\t\t\t&& this.getLength() > (epsilon || 0);\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)\n\t\t\t\t< 1e-8;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)\n\t\t\t\t< 1e-8;\n\t}\n}), {\n\tbeans: false,\n\n\tgetLocationAt: function(offset, _isTime) {\n\t\treturn this.getLocationAtTime(\n\t\t\t\t_isTime ? offset : this.getTimeAt(offset));\n\t},\n\n\tgetLocationAtTime: function(t) {\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetTimeAt: function(offset, start) {\n\t\treturn Curve.getTimeAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterAt: '#getTimeAt',\n\n\tgetOffsetAtTime: function(t) {\n\t\treturn this.getPartLength(0, t);\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetTimeOf: function() {\n\t\treturn Curve.getTimeOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetParameterOf: '#getTimeOf',\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestTime(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(location, _isTime) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, _isTime ? location\n\t\t\t\t\t\t: Curve.getTimeAt(values, location));\n\t\t\t};\n\n\t\t\tthis[name + 'AtTime'] = function(time) {\n\t\t\t\treturn Curve[name](this.getValues(), time);\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\t_evaluateMethods: methods\n\t\t\t}\n\t\t}\n\t);\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\n\t\t\tax = 9 * (x1 - x2) + 3 * (x3 - x0),\n\t\t\tbx = 6 * (x0 + x2) - 12 * x1,\n\t\t\tcx = 3 * (x1 - x0),\n\n\t\t\tay = 9 * (y1 - y2) + 3 * (y3 - y0),\n\t\t\tby = 6 * (y0 + y2) - 12 * y1,\n\t\t\tcy = 3 * (y1 - y0);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tisZero = Numerical.isZero;\n\t\tif (isZero(x1 - x0) && isZero(y1 - y0)) {\n\t\t\tx1 = x0;\n\t\t\ty1 = y0;\n\t\t}\n\t\tif (isZero(x2 - x3) && isZero(y2 - y3)) {\n\t\t\tx2 = x3;\n\t\t\ty2 = y3;\n\t\t}\n\t\tvar cx = 3 * (x1 - x0),\n\t\t\tbx = 3 * (x2 - x1) - cx,\n\t\t\tax = x3 - x0 - cx - bx,\n\t\t\tcy = 3 * (y1 - y0),\n\t\t\tby = 3 * (y2 - y1) - cy,\n\t\t\tay = y3 - y0 - cy - by,\n\t\t\tx, y;\n\t\tif (type === 0) {\n\t\t\tx = t === 0 ? x0 : t === 1 ? x3\n\t\t\t\t\t: ((ax * t + bx) * t + cx) * t + x0;\n\t\t\ty = t === 0 ? y0 : t === 1 ? y3\n\t\t\t\t\t: ((ay * t + by) * t + cy) * t + y0;\n\t\t} else {\n\t\t\tvar tMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t < tMin) {\n\t\t\t\tx = cx;\n\t\t\t\ty = cy;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tx = 3 * (x3 - x2);\n\t\t\t\ty = 3 * (y3 - y2);\n\t\t\t} else {\n\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t}\n\t\t\tif (normalized) {\n\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\tx = x2 - x1;\n\t\t\t\t\ty = y2 - y1;\n\t\t\t\t}\n\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\tif (len) {\n\t\t\t\t\tx /= len;\n\t\t\t\t\ty /= len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type === 3) {\n\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tclassify: function(v) {\n\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\ta1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,\n\t\t\t\ta2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,\n\t\t\t\ta3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,\n\t\t\t\td3 = 3 * a3,\n\t\t\t\td2 = d3 - a2,\n\t\t\t\td1 = d2 - a2 + a1,\n\t\t\t\tl = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),\n\t\t\t\ts = l !== 0 ? 1 / l : 0,\n\t\t\t\tisZero = Numerical.isZero,\n\t\t\t\tserpentine = 'serpentine';\n\t\t\td1 *= s;\n\t\t\td2 *= s;\n\t\t\td3 *= s;\n\n\t\t\tfunction type(type, t1, t2) {\n\t\t\t\tvar hasRoots = t1 !== undefined,\n\t\t\t\t\tt1Ok = hasRoots && t1 > 0 && t1 < 1,\n\t\t\t\t\tt2Ok = hasRoots && t2 > 0 && t2 < 1;\n\t\t\t\tif (hasRoots && (!(t1Ok || t2Ok)\n\t\t\t\t\t\t|| type === 'loop' && !(t1Ok && t2Ok))) {\n\t\t\t\t\ttype = 'arch';\n\t\t\t\t\tt1Ok = t2Ok = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: type,\n\t\t\t\t\troots: t1Ok || t2Ok\n\t\t\t\t\t\t\t? t1Ok && t2Ok\n\t\t\t\t\t\t\t\t? t1 < t2 ? [t1, t2] : [t2, t1]\n\t\t\t\t\t\t\t\t: [t1Ok ? t1 : t2]\n\t\t\t\t\t\t\t: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isZero(d1)) {\n\t\t\t\treturn isZero(d2)\n\t\t\t\t\t\t? type(isZero(d3) ? 'line' : 'quadratic')\n\t\t\t\t\t\t: type(serpentine, d3 / (3 * d2));\n\t\t\t}\n\t\t\tvar d = 3 * d2 * d2 - 4 * d1 * d3;\n\t\t\tif (isZero(d)) {\n\t\t\t\treturn type('cusp', d2 / (2 * d1));\n\t\t\t}\n\t\t\tvar f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),\n\t\t\t\tf2 = 2 * d1;\n\t\t\treturn type(d > 0 ? serpentine : 'loop',\n\t\t\t\t\t(d2 + f1) / f2,\n\t\t\t\t\t(d2 - f1) / f2);\n\t\t},\n\n\t\tgetLength: function(v, a, b, ds) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar c = v;\n\t\t\t\tif (b < 1) {\n\t\t\t\t\tc = Curve.subdivide(c, b)[0];\n\t\t\t\t\ta /= b;\n\t\t\t\t}\n\t\t\t\tif (a > 0) {\n\t\t\t\t\tc = Curve.subdivide(c, a)[1];\n\t\t\t\t}\n\t\t\t\tvar dx = c[6] - c[0],\n\t\t\t\t\tdy = c[7] - c[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\treturn Numerical.integrate(ds || getLengthIntegrand(v), a, b,\n\t\t\t\t\tgetIterations(a, b));\n\t\t},\n\n\t\tgetTimeAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0;\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Curve.getLength(v, a, b, ds),\n\t\t\t\tdiff = abs(offset) - rangeLength;\n\t\t\tif (abs(diff) < epsilon) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (diff > epsilon) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t},\n\n\t\tgetPeaks: function(v) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tax =     -x0 + 3 * x1 - 3 * x2 + x3,\n\t\t\t\tbx =  3 * x0 - 6 * x1 + 3 * x2,\n\t\t\t\tcx = -3 * x0 + 3 * x1,\n\t\t\t\tay =     -y0 + 3 * y1 - 3 * y2 + y3,\n\t\t\t\tby =  3 * y0 - 6 * y1 + 3 * y2,\n\t\t\t\tcy = -3 * y0 + 3 * y1,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [];\n\t\t\tNumerical.solveCubic(\n\t\t\t\t\t9 * (ax * ax + ay * ay),\n\t\t\t\t\t9 * (ax * bx + by * ay),\n\t\t\t\t\t2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),\n\t\t\t\t\t(cx * bx + by * cy),\n\t\t\t\t\troots, tMin, tMax);\n\t\t\treturn roots.sort();\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, include, c1, t1, c2, t2, overlap) {\n\t\tvar excludeStart = !overlap && c1.getPrevious() === c2,\n\t\t\texcludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&\n\t\t\tt1 <= (excludeEnd ? tMax : 1)) {\n\t\t\tif (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&\n\t\t\t\tt2 <= (excludeStart ? tMax : 1)) {\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1, null, overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2, null, overlap);\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc1)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc1, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, include, flip,\n\t\t\trecursion, calls, tMin, tMax, uMin, uMax) {\n\t\tif (++calls >= 4096 || ++recursion >= 40)\n\t\t\treturn calls;\n\t\tvar fatLineEpsilon = 1e-9,\n\t\t\tq0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif (d1 === 0 && d2 === 0\n\t\t\t\t&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0\n\t\t\t|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null\n\t\t\t|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn calls;\n\t\tvar tMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n\t\t\tvar t = (tMinNew + tMaxNew) / 2,\n\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tflip ? c2 : c1, flip ? u : t,\n\t\t\t\t\tflip ? c1 : c2, flip ? t : u);\n\t\t} else {\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tif (tMaxClip - tMinClip > 0.8) {\n\t\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = (tMinNew + tMaxNew) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[0], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, t);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[1], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, t, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[0], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, u, tMinNew, tMaxNew);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[1], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, u, uMax, tMinNew, tMaxNew);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (uMax - uMin >= fatLineEpsilon) {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, include, flip,\n\t\t\t\t\t\t\trecursion, calls, tMinNew, tMaxNew, uMin, uMax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn calls;\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= 0.5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getCurveLineIntersections(v, px, py, vx, vy) {\n\t\tvar isZero = Numerical.isZero;\n\t\tif (isZero(vx) && isZero(vy)) {\n\t\t\tvar t = Curve.getTimeOf(v, new Point(px, py));\n\t\t\treturn t === null ? [] : [t];\n\t\t}\n\t\tvar angle = Math.atan2(-vy, vx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trv = [],\n\t\t\troots = [];\n\t\tfor (var i = 0; i < 8; i += 2) {\n\t\t\tvar x = v[i] - px,\n\t\t\t\ty = v[i + 1] - py;\n\t\t\trv.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tCurve.solveCubic(rv, 1, 0, roots, 0, 1);\n\t\treturn roots;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, include,\n\t\t\tflip) {\n\t\tvar x1 = v2[0], y1 = v2[1],\n\t\t\tx2 = v2[6], y2 = v2[7],\n\t\t\troots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n\t\tfor (var i = 0, l = roots.length; i < l; i++) {\n\t\t\tvar t1 = roots[i],\n\t\t\t\tp1 = Curve.getPoint(v1, t1),\n\t\t\t\tt2 = Curve.getTimeOf(v2, p1);\n\t\t\tif (t2 !== null) {\n\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\tflip ? c2 : c1, flip ? t2 : t1,\n\t\t\t\t\t\tflip ? c1 : c2, flip ? t1 : t2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, include) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, Curve.getTimeOf(v1, pt),\n\t\t\t\t\tc2, Curve.getTimeOf(v2, pt));\n\t\t}\n\t}\n\n\tfunction getCurveIntersections(v1, v2, c1, c2, locations, include) {\n\t\tvar epsilon = 1e-12,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max;\n\n\t\tif (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >\n\t\t\tmin(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmin(v1[0], v1[2], v1[4], v1[6]) - epsilon <\n\t\t\tmax(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmax(v1[1], v1[3], v1[5], v1[7]) + epsilon >\n\t\t\tmin(v2[1], v2[3], v2[5], v2[7]) &&\n\t\t\tmin(v1[1], v1[3], v1[5], v1[7]) - epsilon <\n\t\t\tmax(v2[1], v2[3], v2[5], v2[7])) {\n\t\t\tvar overlaps = getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\tc1, overlap[0],\n\t\t\t\t\t\t\tc2, overlap[1], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tflip = straight1 && !straight2,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tflip ? v2 : v1, flip ? v1 : v2,\n\t\t\t\t\t\t\tflip ? c2 : c1, flip ? c1 : c2,\n\t\t\t\t\t\t\tlocations, include, flip,\n\t\t\t\t\t\t\t0, 0, 0, 1, 0, 1);\n\t\t\t\tif (!straight || locations.length === before) {\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tvar t1 = i >> 1,\n\t\t\t\t\t\t\tt2 = i & 1,\n\t\t\t\t\t\t\ti1 = t1 * 6,\n\t\t\t\t\t\t\ti2 = t2 * 6,\n\t\t\t\t\t\t\tp1 = new Point(v1[i1], v1[i1 + 1]),\n\t\t\t\t\t\t\tp2 = new Point(v2[i2], v2[i2 + 1]);\n\t\t\t\t\t\tif (p1.isClose(p2, epsilon)) {\n\t\t\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\t\t\tc1, t1,\n\t\t\t\t\t\t\t\t\tc2, t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getLoopIntersection(v1, c1, locations, include) {\n\t\tvar info = Curve.classify(v1);\n\t\tif (info.type === 'loop') {\n\t\t\tvar roots = info.roots;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, roots[0],\n\t\t\t\t\tc1, roots[1]);\n\t\t}\n\t  return locations;\n\t}\n\n\tfunction getIntersections(curves1, curves2, include, matrix1, matrix2,\n\t\t\t_returnFirst) {\n\t\tvar self = !curves2;\n\t\tif (self)\n\t\t\tcurves2 = curves1;\n\t\tvar length1 = curves1.length,\n\t\t\tlength2 = curves2.length,\n\t\t\tvalues2 = [],\n\t\t\tarrays = [],\n\t\t\tlocations,\n\t\t\tcurrent;\n\t\tfor (var i = 0; i < length2; i++)\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvar curve1 = curves1[i],\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\tpath1 = curve1.getPath();\n\t\t\tif (path1 !== current) {\n\t\t\t\tcurrent = path1;\n\t\t\t\tlocations = [];\n\t\t\t\tarrays.push(locations);\n\t\t\t}\n\t\t\tif (self) {\n\t\t\t\tgetLoopIntersection(values1, curve1, locations, include);\n\t\t\t}\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\treturn locations;\n\t\t\t\tgetCurveIntersections(values1, values2[j], curve1, curves2[j],\n\t\t\t\t\t\tlocations, include);\n\t\t\t}\n\t\t}\n\t\tlocations = [];\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getOverlaps(v1, v2) {\n\n\t\tfunction getSquaredLineLength(v) {\n\t\t\tvar x = v[6] - v[0],\n\t\t\t\ty = v[7] - v[1];\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tvar abs = Math.abs,\n\t\t\tgetDistance = Line.getDistance,\n\t\t\ttimeEpsilon = 1e-8,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\tstraightBoth = straight1 && straight2,\n\t\t\tflip = getSquaredLineLength(v1) < getSquaredLineLength(v2),\n\t\t\tl1 = flip ? v2 : v1,\n\t\t\tl2 = flip ? v1 : v2,\n\t\t\tpx = l1[0], py = l1[1],\n\t\t\tvx = l1[6] - px, vy = l1[7] - py;\n\t\tif (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&\n\t\t\tgetDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n\t\t\tif (!straightBoth &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {\n\t\t\t\tstraight1 = straight2 = straightBoth = true;\n\t\t\t}\n\t\t} else if (straightBoth) {\n\t\t\treturn null;\n\t\t}\n\t\tif (straight1 ^ straight2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar v = [v1, v2],\n\t\t\tpairs = [];\n\t\tfor (var i = 0; i < 4 && pairs.length < 2; i++) {\n\t\t\tvar i1 = i & 1,\n\t\t\t\ti2 = i1 ^ 1,\n\t\t\t\tt1 = i >> 1,\n\t\t\t\tt2 = Curve.getTimeOf(v[i1], new Point(\n\t\t\t\t\tv[i2][t1 ? 6 : 0],\n\t\t\t\t\tv[i2][t1 ? 7 : 1]));\n\t\t\tif (t2 != null) {\n\t\t\t\tvar pair = i1 ? [t1, t2] : [t2, t1];\n\t\t\t\tif (!pairs.length ||\n\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon) {\n\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && !pairs.length)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pairs.length !== 2) {\n\t\t\tpairs = null;\n\t\t} else if (!straightBoth) {\n\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\tpairs = null;\n\t\t}\n\t\treturn pairs;\n\t}\n\n\treturn {\n\t\tgetIntersections: function(curve) {\n\t\t\tvar v1 = this.getValues(),\n\t\t\t\tv2 = curve && curve !== this && curve.getValues();\n\t\t\treturn v2 ? getCurveIntersections(v1, v2, this, curve, [])\n\t\t\t\t\t  : getLoopIntersection(v1, this, []);\n\t\t},\n\n\t\tstatics: {\n\t\t\tgetOverlaps: getOverlaps,\n\t\t\tgetIntersections: getIntersections,\n\t\t\tgetCurveLineIntersections: getCurveLineIntersections\n\t\t}\n\t};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\n\tinitialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n\t\tif (time >= 0.99999999) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\ttime = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._setCurve(curve);\n\t\tthis._time = time;\n\t\tthis._point = point || curve.getPointAtTime(time);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._previous = null;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tvar path = curve._path;\n\t\tthis._path = path;\n\t\tthis._version = path ? path._version : 0;\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tthis._setCurve(segment.getCurve());\n\t\tthis._segment = segment;\n\t\tthis._time = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar segment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tif (time === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (time != null) {\n\t\t\t\tsegment = curve.getPartLength(0, time)\n\t\t\t\t\t< curve.getPartLength(time, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tthis._time = this._offset = this._curveOffset = this._curve = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn this._curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetTime: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this._time;\n\t\treturn curve && time == null\n\t\t\t? this._time = curve.getTimeOf(this._point)\n\t\t\t: time;\n\t},\n\n\tgetParameter: '#getTime',\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar offset = this._curveOffset;\n\t\tif (offset == null) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tthis._curveOffset = offset = time != null && curve\n\t\t\t\t\t&& curve.getPartLength(0, time);\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = curve && curve.divideAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tpath = curve._path,\n\t\t\tres = curve && curve.splitAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(path.getLastSegment());\n\t\t}\n\t\treturn  res;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc;\n\t\tif (!res && loc instanceof CurveLocation) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tp1 = c1._path,\n\t\t\t\tp2 = c2._path;\n\t\t\tif (p1 === p2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tepsilon = 1e-7,\n\t\t\t\t\tdiff = abs(this.getOffset() - loc.getOffset()),\n\t\t\t\t\ti1 = !_ignoreOther && this._intersection,\n\t\t\t\t\ti2 = !_ignoreOther && loc._intersection;\n\t\t\t\tres = (diff < epsilon\n\t\t\t\t\t\t|| p1 && abs(p1.getLength() - diff) < epsilon)\n\t\t\t\t\t&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar time = this.getTime();\n\t\tif (time != null)\n\t\t\tparts.push('time: ' + f.number(time));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getTime(),\n\t\t\tt2 = inter.getTime(),\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tt1Inside = t1 >= tMin && t1 <= tMax,\n\t\t\tt2Inside = t2 >= tMin && t2 <= tMax;\n\t\tif (t1Inside && t2Inside)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = t1 < tMin ? c2.getPrevious() : c2,\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = t2 < tMin ? c4.getPrevious() : c4;\n\t\tif (t1 > tMax)\n\t\t\tc2 = c2.getNext();\n\t\tif (t2 > tMax)\n\t\t\tc4 = c4.getNext();\n\t\tif (!c1 || !c2 || !c3 || !c4)\n\t\t\treturn false;\n\n\t\tvar offsets = [];\n\n\t\tfunction addOffsets(curve, end) {\n\t\t\tvar v = curve.getValues(),\n\t\t\t\troots = Curve.classify(v).roots || Curve.getPeaks(v),\n\t\t\t\tcount = roots.length,\n\t\t\t\tt = end && count > 1 ? roots[count - 1]\n\t\t\t\t\t\t: count > 0 ? roots[0]\n\t\t\t\t\t\t: 0.5;\n\t\t\toffsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);\n\t\t}\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min || angle < max;\n\t\t}\n\n\t\tif (!t1Inside) {\n\t\t\taddOffsets(c1, true);\n\t\t\taddOffsets(c2, false);\n\t\t}\n\t\tif (!t2Inside) {\n\t\t\taddOffsets(c3, true);\n\t\t\taddOffsets(c4, false);\n\t\t}\n\t\tvar pt = this.getPoint(),\n\t\t\toffset = Math.min.apply(Math, offsets),\n\t\t\tv2 = t1Inside ? c2.getTangentAtTime(t1)\n\t\t\t\t\t: c2.getPointAt(offset).subtract(pt),\n\t\t\tv1 = t1Inside ? v2.negate()\n\t\t\t\t\t: c1.getPointAt(-offset).subtract(pt),\n\t\t\tv4 = t2Inside ? c4.getTangentAtTime(t2)\n\t\t\t\t\t: c4.getPointAt(offset).subtract(pt),\n\t\t\tv3 = t2Inside ? v4.negate()\n\t\t\t\t\t: c3.getPointAt(-offset).subtract(pt),\n\t\t\ta1 = v1.getAngle(),\n\t\t\ta2 = v2.getAngle(),\n\t\t\ta3 = v3.getAngle(),\n\t\t\ta4 = v4.getAngle();\n\t\treturn !!(t1Inside\n\t\t\t\t? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&\n\t\t\t\t  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))\n\t\t\t\t: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&\n\t\t\t\t  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));\n\t},\n\n\thasOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve._evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this.getTime();\n\t\treturn time != null && curve && curve[get](time, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t1e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 !== path2\n\t\t\t\t? path1._id - path2._id\n\t\t\t\t: (loc.getIndex() + loc.getTime())\n\t\t\t\t- (loc2.getIndex() + loc2.getTime());\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\t_selectBounds: false,\n\t_canScaleStroke: true,\n\tbeans: true,\n\n\tinitialize: function PathItem() {\n\t},\n\n\tstatics: {\n\t\tcreate: function(arg) {\n\t\t\tvar data,\n\t\t\t\tsegments,\n\t\t\t\tcompound;\n\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\tsegments = arg.segments;\n\t\t\t\tdata = arg.pathData;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tsegments = arg;\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tdata = arg;\n\t\t\t}\n\t\t\tif (segments) {\n\t\t\t\tvar first = segments[0];\n\t\t\t\tcompound = first && Array.isArray(first[0]);\n\t\t\t} else if (data) {\n\t\t\t\tcompound = (data.match(/m/gi) || []).length > 1\n\t\t\t\t\t\t|| /z\\s*\\S+/i.test(data);\n\t\t\t}\n\t\t\tvar ctor = compound ? CompoundPath : Path;\n\t\t\treturn new ctor(arg);\n\t\t}\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tisClockwise: function() {\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis[move ? 'moveTo' : 'lineTo'](current = getPoint(j));\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\t\tmove = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tcurrent = current.clone();\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(1e-12);\n\t\t\t\tcurrent = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = point.isInside(\n\t\t\t\tthis.getBounds({ internal: true, handle: true }))\n\t\t\t\t\t? this._getWinding(point)\n\t\t\t\t\t: {};\n\t\treturn winding.onPath || !!(this.getFillRule() === 'evenodd'\n\t\t\t\t? winding.windingL & 1 || winding.windingR & 1\n\t\t\t\t: winding.winding);\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix._orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix)._orNullIfIdentity();\n\t\treturn self || this.getBounds(matrix1).intersects(\n\t\t\t\tpath.getBounds(matrix2), 1e-12)\n\t\t\t\t? Curve.getIntersections(\n\t\t\t\t\t\tthis.getCurves(), !self && path.getCurves(), include,\n\t\t\t\t\t\tmatrix1, matrix2, _returnFirst)\n\t\t\t\t: [];\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.hasOverlap() || inter.isCrossing();\n\t\t});\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar isPath = !this._children,\n\t\t\tname = isPath ? '_segments' : '_children',\n\t\t\titemsFrom = from[name],\n\t\t\titemsTo = to[name],\n\t\t\titems = this[name];\n\t\tif (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {\n\t\t\tthrow new Error('Invalid operands in interpolate() call: ' +\n\t\t\t\t\tfrom + ', ' + to);\n\t\t}\n\t\tvar current = items.length,\n\t\t\tlength = itemsTo.length;\n\t\tif (current < length) {\n\t\t\tvar ctor = isPath ? Segment : Path;\n\t\t\tfor (var i = current; i < length; i++) {\n\t\t\t\tthis.add(new ctor());\n\t\t\t}\n\t\t} else if (current > length) {\n\t\t\tthis[isPath ? 'removeSegments' : 'removeChildren'](length, current);\n\t\t}\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titems[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n\t\t}\n\t\tif (isPath) {\n\t\t\tthis.setClosed(from._closed);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tcompare: function(path) {\n\t\tvar ok = false;\n\t\tif (path) {\n\t\t\tvar paths1 = this._children || [this],\n\t\t\t\tpaths2 = path._children ? path._children.slice() : [path],\n\t\t\t\tlength1 = paths1.length,\n\t\t\t\tlength2 = paths2.length,\n\t\t\t\tmatched = [],\n\t\t\t\tcount = 0;\n\t\t\tok = true;\n\t\t\tfor (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {\n\t\t\t\tvar path1 = paths1[i1];\n\t\t\t\tok = false;\n\t\t\t\tfor (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {\n\t\t\t\t\tif (path1.compare(paths2[i2])) {\n\t\t\t\t\t\tif (!matched[i2]) {\n\t\t\t\t\t\t\tmatched[i2] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = ok && count === length2;\n\t\t}\n\t\treturn ok;\n\t},\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar segments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: arguments\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? arguments\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._segmentSelection = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setSegments(source._segments);\n\t\tthis._closed = source._closed;\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tthis._length = this._area = undefined;\n\t\t\tif (flags & 16) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 32) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected(),\n\t\t\tlength = segments && segments.length;\n\t\tthis._segments.length = 0;\n\t\tthis._segmentSelection = 0;\n\t\tthis._curves = undefined;\n\t\tif (length) {\n\t\t\tvar last = segments[length - 1];\n\t\t\tif (typeof last === 'boolean') {\n\t\t\t\tthis.setClosed(last);\n\t\t\t\tlength--;\n\t\t\t}\n\t\t\tthis._add(Segment.readList(segments, 0, {}, length));\n\t\t}\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine) {\n\t\t\t\t\t\tvar dx = curX - prevX,\n\t\t\t\t\t\t\tdy = curY - prevY;\n\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t  dx === 0 ? 'v' + f.number(dy)\n\t\t\t\t\t\t\t: dy === 0 ? 'h' + f.number(dx)\n\t\t\t\t\t\t\t: 'l' + f.pair(dx, dy));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair( inX - prevX,  inY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (!length)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._segments.length;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar segments = this._segments,\n\t\t\tcoords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selection);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tstart = index > 0 && index + amount - 1 === total ? index - 1\n\t\t\t\t\t: index,\n\t\t\t\tinsert = start,\n\t\t\t\tend = Math.min(start + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [start, 0].concat(segs._curves));\n\t\t\t\tinsert += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = insert; i < end; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(start, end);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(start, end) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && !start ? segments.length - 1\n\t\t\t\t: start - 1]) {\n\t\t\tcurve._segment2 = segments[start] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[end]) {\n\t\t\tcurve._segment1 = segments[end];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readList(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readList(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(start, end, _includeCurves) {\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(start, end - start),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, segment._selection, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = start, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = start > 0 && end === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? start - 1\n\t\t\t\t\t: start,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\t\tcurves[i]._path = null;\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tvar area = this._area;\n\t\tif (area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tclosed = this._closed;\n\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar last = i + 1 === l;\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[last ? 0 : i + 1],\n\t\t\t\t\t\tnull, last && !closed));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn area;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this.isSelected() && length > 0 && this._segmentSelection\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelection: function setSelection(selection) {\n\t\tif (!(selection & 1))\n\t\t\tthis._selectSegments(false);\n\t\tsetSelection.base.call(this, selection);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tselection = selected ? 7 : 0;\n\t\tthis._segmentSelection = selection * length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tsegments[i]._selection = selection;\n\t},\n\n\t_updateSelection: function(segment, oldSelection, newSelection) {\n\t\tsegment._selection = newSelection;\n\t\tvar selection = this._segmentSelection += newSelection - oldSelection;\n\t\tif (selection > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tdivideAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tcurve;\n\t\treturn loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))\n\t\t\t\t? curve._segment1\n\t\t\t\t: null;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tindex = loc && loc.index,\n\t\t\ttime = loc && loc.time,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (time > tMax) {\n\t\t\tindex++;\n\t\t\ttime = 0;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (time >= tMin) {\n\t\t\t\tcurves[index++].divideAtTime(time);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.copyAttributes(this);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\tsplit: function(index, time) {\n\t\tvar curve,\n\t\t\tlocation = time === undefined ? index\n\t\t\t\t: (curve = this.getCurves()[index])\n\t\t\t\t\t&& curve.getLocationAtTime(time);\n\t\treturn location != null ? this.splitAt(location) : null;\n\t},\n\n\tjoin: function(path, tolerance) {\n\t\tvar epsilon = tolerance || 0;\n\t\tif (path && path !== this) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.isClose(last2._point, epsilon))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.isClose(first2._point, epsilon)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.isClose(first2._point, epsilon))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.isClose(last2._point, epsilon)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.isClose(last._point, epsilon)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\treduce: function(options) {\n\t\tvar curves = this.getCurves(),\n\t\t\tsimplify = options && options.simplify,\n\t\t\ttolerance = simplify ? 1e-7 : 0;\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (!curve.hasLength(tolerance)\n\t\t\t\t\t|| simplify && curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tthis._changed(9);\n\t},\n\n\tflatten: function(flatness) {\n\t\tvar flattener = new PathFlattener(this, flatness || 0.25, 256, true),\n\t\t\tparts = flattener.parts,\n\t\t\tlength = parts.length,\n\t\t\tsegments = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tsegments.push(new Segment(parts[i].curve.slice(0, 2)));\n\t\t}\n\t\tif (!this._closed && length > 0) {\n\t\t\tsegments.push(new Segment(parts[length - 1].curve.slice(6)));\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tvar segments = new PathFitter(this).fit(tolerance || 2.5);\n\t\tif (segments)\n\t\t\tthis.setSegments(segments);\n\t\treturn !!segments;\n\t},\n\n\tsmooth: function(options) {\n\t\tvar that = this,\n\t\t\topts = options || {},\n\t\t\ttype = opts.type || 'asymmetric',\n\t\t\tsegments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tclosed = this._closed;\n\n\t\tfunction getIndex(value, _default) {\n\t\t\tvar index = value && value.index;\n\t\t\tif (index != null) {\n\t\t\t\tvar path = value.path;\n\t\t\t\tif (path && path !== that)\n\t\t\t\t\tthrow new Error(value._class + ' ' + index + ' of ' + path\n\t\t\t\t\t\t\t+ ' is not part of ' + that);\n\t\t\t\tif (_default && value instanceof Curve)\n\t\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tindex = typeof value === 'number' ? value : _default;\n\t\t\t}\n\t\t\treturn Math.min(index < 0 && closed\n\t\t\t\t\t? index % length\n\t\t\t\t\t: index < 0 ? index + length : index, length - 1);\n\t\t}\n\n\t\tvar loop = closed && opts.from === undefined && opts.to === undefined,\n\t\t\tfrom = getIndex(opts.from, 0),\n\t\t\tto = getIndex(opts.to, length - 1);\n\n\t\tif (from > to) {\n\t\t\tif (closed) {\n\t\t\t\tfrom -= length;\n\t\t\t} else {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t}\n\t\tif (/^(?:asymmetric|continuous)$/.test(type)) {\n\t\t\tvar asymmetric = type === 'asymmetric',\n\t\t\t\tmin = Math.min,\n\t\t\t\tamount = to - from + 1,\n\t\t\t\tn = amount - 1,\n\t\t\t\tpadding = loop ? min(amount, 4) : 1,\n\t\t\t\tpaddingLeft = padding,\n\t\t\t\tpaddingRight = padding,\n\t\t\t\tknots = [];\n\t\t\tif (!closed) {\n\t\t\t\tpaddingLeft = min(1, from);\n\t\t\t\tpaddingRight = min(1, length - to - 1);\n\t\t\t}\n\t\t\tn += paddingLeft + paddingRight;\n\t\t\tif (n <= 1)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {\n\t\t\t\tknots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n\t\t\t}\n\n\t\t\tvar x = knots[0]._x + 2 * knots[1]._x,\n\t\t\t\ty = knots[0]._y + 2 * knots[1]._y,\n\t\t\t\tf = 2,\n\t\t\t\tn_1 = n - 1,\n\t\t\t\trx = [x],\n\t\t\t\try = [y],\n\t\t\t\trf = [f],\n\t\t\t\tpx = [],\n\t\t\t\tpy = [];\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tvar internal = i < n_1,\n\t\t\t\t\ta = internal ? 1 : asymmetric ? 1 : 2,\n\t\t\t\t\tb = internal ? 4 : asymmetric ? 2 : 7,\n\t\t\t\t\tu = internal ? 4 : asymmetric ? 3 : 8,\n\t\t\t\t\tv = internal ? 2 : asymmetric ? 0 : 1,\n\t\t\t\t\tm = a / f;\n\t\t\t\tf = rf[i] = b - m;\n\t\t\t\tx = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n\t\t\t\ty = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n\t\t\t}\n\n\t\t\tpx[n_1] = rx[n_1] / rf[n_1];\n\t\t\tpy[n_1] = ry[n_1] / rf[n_1];\n\t\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\t\tpx[i] = (rx[i] - px[i + 1]) / rf[i];\n\t\t\t\tpy[i] = (ry[i] - py[i + 1]) / rf[i];\n\t\t\t}\n\t\t\tpx[n] = (3 * knots[n]._x - px[n_1]) / 2;\n\t\t\tpy[n] = (3 * knots[n]._y - py[n_1]) / 2;\n\n\t\t\tfor (var i = paddingLeft, max = n - paddingRight, j = from;\n\t\t\t\t\ti <= max; i++, j++) {\n\t\t\t\tvar segment = segments[j < 0 ? j + length : j],\n\t\t\t\t\tpt = segment._point,\n\t\t\t\t\thx = px[i] - pt._x,\n\t\t\t\t\thy = py[i] - pt._y;\n\t\t\t\tif (loop || i < max)\n\t\t\t\t\tsegment.setHandleOut(hx, hy);\n\t\t\t\tif (loop || i > paddingLeft)\n\t\t\t\t\tsegment.setHandleIn(-hx, -hy);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = from; i <= to; i++) {\n\t\t\t\tsegments[i < 0 ? i + length : i].smooth(opts,\n\t\t\t\t\t\t!loop && i === from, !loop && i === to);\n\t\t\t}\n\t\t}\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t});\n\t\t\tshape.copyAttributes(this, true);\n\t\t\tshape._matrix.prepend(this._matrix);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\tif (insert === undefined || insert)\n\t\t\t\tshape.insertAbove(this);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\ttoPath: '#clone',\n\n\tcompare: function compare(path) {\n\t\tif (!path || path instanceof CompoundPath)\n\t\t\treturn compare.base.call(this, path);\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = curves2.length;\n\t\tif (!length1 || !length2) {\n\t\t\treturn length1 == length2;\n\t\t}\n\t\tvar v1 = curves1[0].getValues(),\n\t\t\tvalues2 = [],\n\t\t\tpos1 = 0, pos2,\n\t\t\tend1 = 0, end2;\n\t\tfor (var i = 0; i < length2; i++) {\n\t\t\tvar v2 = curves2[i].getValues();\n\t\t\tvalues2.push(v2);\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tpos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n\t\t\t\tend2 = overlaps[0][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar abs = Math.abs,\n\t\t\tepsilon = 1e-8,\n\t\t\tv2 = values2[pos2],\n\t\t\tstart2;\n\t\twhile (v1 && v2) {\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tvar t1 = overlaps[0][0];\n\t\t\t\tif (abs(t1 - end1) < epsilon) {\n\t\t\t\t\tend1 = overlaps[1][0];\n\t\t\t\t\tif (end1 === 1) {\n\t\t\t\t\t\tv1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n\t\t\t\t\t\tend1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = overlaps[0][1];\n\t\t\t\t\tif (abs(t2 - end2) < epsilon) {\n\t\t\t\t\t\tif (!start2)\n\t\t\t\t\t\t\tstart2 = [pos2, t2];\n\t\t\t\t\t\tend2 = overlaps[1][1];\n\t\t\t\t\t\tif (end2 === 1) {\n\t\t\t\t\t\t\tif (++pos2 >= length2)\n\t\t\t\t\t\t\t\tpos2 = 0;\n\t\t\t\t\t\t\tv2 = values2[pos2] || curves2[pos2].getValues();\n\t\t\t\t\t\t\tend2 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v1) {\n\t\t\t\t\t\t\treturn start2[0] === pos2 && start2[1] === end2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tstrokeRadius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (strokeRadius !== null) {\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tstrokePadding = strokePadding.add(\n\t\t\t\t\tPath._getStrokePadding(strokeRadius, strokeMatrix));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tvar isJoin = closed || segment._index > 0\n\t\t\t\t\t&& segment._index < numSegments - 1;\n\t\t\tif ((isJoin ? join : cap) === 'round') {\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t} else {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (isJoin) {\n\t\t\t\t\tif (!segment.isSmooth()) {\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius,\n\t\t\t\t\t\t\t   miterLimit, null, strokeMatrix, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t} else if (cap === 'square') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, null,\n\t\t\t\t\t\t\tstrokeMatrix, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (strokeRadius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar time = loc.getTime();\n\t\t\t\tif (time === 0 || time === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point)\n\t\t\t\t\t\t\t<= miterLimit * strokeRadius\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar loc = this.getLocationAt(offset);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset) {\n\t\tif (typeof offset === 'number') {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength()) {\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\t}\n\t\t} else if (offset && offset.getPath && offset.getPath() === this) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn null;\n\t}\n\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tvar half = size / 2,\n\t\t\tcoords = new Array(6),\n\t\t\tpX, pY;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tselection = segment._selection;\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tpX = coords[0];\n\t\t\tpY = coords[1];\n\t\t\tif (selection & 2)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (selection & 4)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (!(selection & 1)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar flattener = new PathFlattener(this, 0.25, 32, false,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = flattener.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\tflattener.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (!segments.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar abs = Math.abs,\n\t\t\t\tsqrt = Math.sqrt,\n\t\t\t\tcurrent = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(arguments);\n\t\t\t} else {\n\t\t\t\tvar radius = Size.read(arguments),\n\t\t\t\t\tisZero = Numerical.isZero;\n\t\t\t\tif (isZero(radius.width) || isZero(radius.height))\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq = x * x,\n\t\t\t\t\tySq = y * y;\n\t\t\t\tvar factor = sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1) * sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar epsilon = 1e-7,\n\t\t\t\text = abs(extent),\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = to,\n\t\t\t\t\tout = null;\n\t\t\t\tif (i < count) {\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t}\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(tolerance) {\n\t\t\tthis.setClosed(true);\n\t\t\tthis.join(this, tolerance);\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(matrix, options) {\n\t\tvar method = options.handle\n\t\t\t\t? 'getHandleBounds'\n\t\t\t\t: options.stroke\n\t\t\t\t? 'getStrokeBounds'\n\t\t\t\t: 'getBounds';\n\t\treturn Path[method](this._segments, this._closed, this, matrix, options);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, path, matrix, options, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6)),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = style.hasStroke(),\n\t\t\tstrokeWidth = style.getStrokeWidth(),\n\t\t\tstrokeMatrix = stroke && path._getStrokeMatrix(matrix, options),\n\t\t\tstrokePadding = stroke && Path._getStrokePadding(strokeWidth,\n\t\t\t\tstrokeMatrix),\n\t\t\tbounds = Path.getBounds(segments, closed, path, matrix, options,\n\t\t\t\tstrokePadding);\n\t\tif (!stroke)\n\t\t\treturn bounds;\n\t\tvar strokeRadius = strokeWidth / 2,\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = style.getMiterLimit(),\n\t\t\tjoinBounds = new Rectangle(new Size(strokePadding));\n\n\t\tfunction addPoint(point) {\n\t\t\tbounds = bounds.include(point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(\n\t\t\t\t\tjoinBounds.setCenter(segment._point.transform(matrix)));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tif (join === 'round' || segment.isSmooth()) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius, miterLimit,\n\t\t\t\t\t\tmatrix, strokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, matrix,\n\t\t\t\t\t\tstrokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tvar length = segments.length - (closed ? 0 : 1);\n\t\tfor (var i = 1; i < length; i++)\n\t\t\taddJoin(segments[i], join);\n\t\tif (closed) {\n\t\t\taddJoin(segments[0], join);\n\t\t} else if (length > 0) {\n\t\t\taddCap(segments[0], cap);\n\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getStrokePadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar hor = new Point(radius, 0).transform(matrix),\n\t\t\tver = new Point(0, radius).transform(matrix),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = Math.atan2(b * tan, a),\n\t\t\tty = Math.atan2(b, tan * a);\n\t\treturn [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, matrix,\n\t\t\tstrokeMatrix, addPoint, isArea) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPoint1().transform(matrix),\n\t\t\tnormal1 = curve1.getNormalAtTime(1).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\tnormal2 = curve2.getNormalAtTime(0).multiply(radius)\n\t\t\t\t.transform(strokeMatrix);\n\t\tif (normal1.getDirectedAngle(normal2) < 0) {\n\t\t\tnormal1 = normal1.negate();\n\t\t\tnormal2 = normal2.negate();\n\t\t}\n\t\tif (isArea)\n\t\t\taddPoint(point);\n\t\taddPoint(point.add(normal1));\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(point.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(point.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit * radius) {\n\t\t\t\taddPoint(corner);\n\t\t\t}\n\t\t}\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,\n\t\t\taddPoint, isArea) {\n\t\tvar point = segment._point.transform(matrix),\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal()\n\t\t\t\t\t.multiply(loc.getTime() === 0 ? radius : -radius)\n\t\t\t\t\t.transform(strokeMatrix);\n\t\tif (cap === 'square') {\n\t\t\tif (isArea) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tpoint = point.add(normal.rotate(-90));\n\t\t}\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = options.stroke && style.hasStroke(),\n\t\t\tstrokePadding,\n\t\t\tjoinPadding;\n\t\tif (stroke) {\n\t\t\tvar strokeMatrix = path._getStrokeMatrix(matrix, options),\n\t\t\t\tstrokeRadius = style.getStrokeWidth() / 2,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n\t\t\tstrokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n\t\t\tjoinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n\t\t}\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = !j ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && props.insert == false && Item.NO_INSERT);\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props, { insert: true });\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t], false, arguments);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\tpath = new Path(props && props.insert == false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = sides % 3 === 0,\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\tbeans: true,\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items) {\n\t\tvar list = items,\n\t\t\tfirst = list[0];\n\t\tif (first && typeof first[0] === 'number')\n\t\t\tlist = [list];\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = list[i];\n\t\t\tif (list === items && !(item instanceof Path))\n\t\t\t\tlist = Base.slice(list);\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tlist[i] = new Path({ segments: item, insert: false });\n\t\t\t} else if (item instanceof CompoundPath) {\n\t\t\t\tlist.splice.apply(list, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\treturn insertChildren.base.call(this, index, list);\n\t},\n\n\treduce: function reduce(options) {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce(options);\n\t\t\tif (path.isEmpty())\n\t\t\t\tpath.remove();\n\t\t}\n\t\tif (!children.length) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.copyAttributes(this);\n\t\t\tpath.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClosed: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tif (!children[i]._closed)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].setClosed(closed);\n\t\t}\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t},\n\n\tgetLength: function() {\n\t\tvar children = this._children,\n\t\t\tlength = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tlength += children[i].getLength();\n\t\treturn length;\n\t},\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.appended(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join('');\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\treturn _hitTestChildren.base.call(this, point,\n\t\t\t\toptions.class === Path || options.type === 'path' ? options\n\t\t\t\t\t: Base.set({}, options, { fill: false }),\n\t\t\t\tviewMatrix);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (!children.length)\n\t\t\treturn;\n\n\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\tctx.beginPath();\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectionItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectionItems[child._id]) {\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.appended(mx));\n\t\t\t}\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && !children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\treturn Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',\n\t\t\t'arcBy'],\n\t\tfunction(key) {\n\t\t\tthis[key] = function() {\n\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t};\n\t\t}, {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\n\t\t\tclosePath: function(tolerance) {\n\t\t\t\tgetCurrentPath(this, true).closePath(tolerance);\n\t\t\t}\n\t\t}\n\t);\n}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {\n\tthis[key] = function(param) {\n\t\tvar children = this._children,\n\t\t\tres;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tres = children[i][key](param) || res;\n\t\t}\n\t\treturn res;\n\t};\n}, {}));\n\nPathItem.inject(new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\toperators = {\n\t\t\tunite:     { '1': true, '2': true },\n\t\t\tintersect: { '2': true },\n\t\t\tsubtract:  { '1': true },\n\t\t\texclude:   { '1': true, '-1': true }\n\t\t};\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path.clone(false).reduce({ simplify: true })\n\t\t\t\t.transform(null, true, true);\n\t\treturn resolve\n\t\t\t\t? res.resolveCrossings().reorient(\n\t\t\t\t\tres.getFillRule() === 'nonzero', true)\n\t\t\t\t: res;\n\t}\n\n\tfunction createResult(paths, simplify, path1, path2, options) {\n\t\tvar result = new CompoundPath(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tresult = result.reduce({ simplify: simplify });\n\t\tif (!(options && options.insert == false)) {\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex() ? path2 : path1);\n\t\t}\n\t\tresult.copyAttributes(path1, true);\n\t\treturn result;\n\t}\n\n\tfunction traceBoolean(path1, path2, operation, options) {\n\t\tif (options && (options.trace == false || options.stroke) &&\n\t\t\t\t/^(subtract|intersect)$/.test(operation))\n\t\t\treturn splitBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true),\n\t\t\toperator = operators[operation];\n\t\toperator[operation] = true;\n\t\tif (_path2 && (operator.subtract || operator.exclude)\n\t\t\t\t^ (_path2.isClockwise() ^ _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar crossings = divideLocations(\n\t\t\t\tCurveLocation.expand(_path1.getCrossings(_path2))),\n\t\t\tpaths1 = _path1._children || [_path1],\n\t\t\tpaths2 = _path2 && (_path2._children || [_path2]),\n\t\t\tsegments = [],\n\t\t\tcurves = [],\n\t\t\tpaths;\n\n\t\tfunction collect(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\tcurves.push.apply(curves, path.getCurves());\n\t\t\t\tpath._overlapsOnly = true;\n\t\t\t}\n\t\t}\n\n\t\tif (crossings.length) {\n\t\t\tcollect(paths1);\n\t\t\tif (paths2)\n\t\t\t\tcollect(paths2);\n\t\t\tfor (var i = 0, l = crossings.length; i < l; i++) {\n\t\t\t\tpropagateWinding(crossings[i]._segment, _path1, _path2, curves,\n\t\t\t\t\t\toperator);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i],\n\t\t\t\t\tinter = segment._intersection;\n\t\t\t\tif (!segment._winding) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2, curves, operator);\n\t\t\t\t}\n\t\t\t\tif (!(inter && inter._overlap))\n\t\t\t\t\tsegment._path._overlapsOnly = false;\n\t\t\t}\n\t\t\tpaths = tracePaths(segments, operator);\n\t\t} else {\n\t\t\tpaths = reorientPaths(\n\t\t\t\t\tpaths2 ? paths1.concat(paths2) : paths1.slice(),\n\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\treturn !!operator[w];\n\t\t\t\t\t});\n\t\t}\n\n\t\treturn createResult(paths, true, path1, path2, options);\n\t}\n\n\tfunction splitBoolean(path1, path2, operation) {\n\t\tvar _path1 = preparePath(path1),\n\t\t\t_path2 = preparePath(path2),\n\t\t\tcrossings = _path1.getCrossings(_path2),\n\t\t\tsubtract = operation === 'subtract',\n\t\t\tdivide = operation === 'divide',\n\t\t\tadded = {},\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (!added[path._id] && (divide ||\n\t\t\t\t\t_path2.contains(path.getPointAt(path.getLength() / 2))\n\t\t\t\t\t\t^ subtract)) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn added[path._id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = crossings.length - 1; i >= 0; i--) {\n\t\t\tvar path = crossings[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn createResult(paths, false, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._previous;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._previous)\n\t\t\t\tto = to._previous;\n\t\t\tfrom._next = to;\n\t\t\tto._previous = from;\n\t\t}\n\t}\n\n\tfunction clearCurveHandles(curves) {\n\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\tcurves[i].clearHandles();\n\t}\n\n\tfunction reorientPaths(paths, isInside, clockwise) {\n\t\tvar length = paths && paths.length;\n\t\tif (length) {\n\t\t\tvar lookup = Base.each(paths, function (path, i) {\n\t\t\t\t\tthis[path._id] = {\n\t\t\t\t\t\tcontainer: null,\n\t\t\t\t\t\twinding: path.isClockwise() ? 1 : -1,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t};\n\t\t\t\t}, {}),\n\t\t\t\tsorted = paths.slice().sort(function (a, b) {\n\t\t\t\t\treturn abs(b.getArea()) - abs(a.getArea());\n\t\t\t\t}),\n\t\t\t\tfirst = sorted[0];\n\t\t\tif (clockwise == null)\n\t\t\t\tclockwise = first.isClockwise();\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar path1 = sorted[i],\n\t\t\t\t\tentry1 = lookup[path1._id],\n\t\t\t\t\tpoint = path1.getInteriorPoint(),\n\t\t\t\t\tcontainerWinding = 0;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tvar path2 = sorted[j];\n\t\t\t\t\tif (path2.contains(point)) {\n\t\t\t\t\t\tvar entry2 = lookup[path2._id];\n\t\t\t\t\t\tcontainerWinding = entry2.winding;\n\t\t\t\t\t\tentry1.winding += containerWinding;\n\t\t\t\t\t\tentry1.container = entry2.exclude ? entry2.container\n\t\t\t\t\t\t\t\t: path2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isInside(entry1.winding) === isInside(containerWinding)) {\n\t\t\t\t\tentry1.exclude = true;\n\t\t\t\t\tpaths[entry1.index] = null;\n\t\t\t\t} else {\n\t\t\t\t\tvar container = entry1.container;\n\t\t\t\t\tpath1.setClockwise(container ? !container.isClockwise()\n\t\t\t\t\t\t\t: clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\tfunction divideLocations(locations, include, clearLater) {\n\t\tvar results = include && [],\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tclearHandles = false,\n\t\t\tclearCurves = clearLater || [],\n\t\t\tclearLookup = clearLater && {},\n\t\t\trenormalizeLocs,\n\t\t\tprevCurve,\n\t\t\tprevTime;\n\n\t\tfunction getId(curve) {\n\t\t\treturn curve._path._id + '.' + curve._segment1._index;\n\t\t}\n\n\t\tfor (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {\n\t\t\tvar curve = clearLater[i];\n\t\t\tif (curve._path)\n\t\t\t\tclearLookup[getId(curve)] = true;\n\t\t}\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\ttime = loc._time,\n\t\t\t\torigTime = time,\n\t\t\t\texclude = include && !include(loc),\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tsegment;\n\t\t\tif (curve) {\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tclearHandles = !curve.hasHandles()\n\t\t\t\t\t\t\t|| clearLookup && clearLookup[getId(curve)];\n\t\t\t\t\trenormalizeLocs = [];\n\t\t\t\t\tprevTime = null;\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t} else if (prevTime >= tMin) {\n\t\t\t\t\ttime /= prevTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exclude) {\n\t\t\t\tif (renormalizeLocs)\n\t\t\t\t\trenormalizeLocs.push(loc);\n\t\t\t\tcontinue;\n\t\t\t} else if (include) {\n\t\t\t\tresults.unshift(loc);\n\t\t\t}\n\t\t\tprevTime = origTime;\n\t\t\tif (time < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tvar newCurve = curve.divideAtTime(time, true);\n\t\t\t\tif (clearHandles)\n\t\t\t\t\tclearCurves.push(curve, newCurve);\n\t\t\t\tsegment = newCurve._segment1;\n\t\t\t\tfor (var j = renormalizeLocs.length - 1; j >= 0; j--) {\n\t\t\t\t\tvar l = renormalizeLocs[j];\n\t\t\t\t\tl._time = (l._time - time) / (1 - time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t}\n\t\tif (!clearLater)\n\t\t\tclearCurveHandles(clearCurves);\n\t\treturn results || locations;\n\t}\n\n\tfunction getWinding(point, curves, dir, closed, dontFlip) {\n\t\tvar ia = dir ? 1 : 0,\n\t\t\tio = ia ^ 1,\n\t\t\tpv = [point.x, point.y],\n\t\t\tpa = pv[ia],\n\t\t\tpo = pv[io],\n\t\t\twindingEpsilon = 1e-9,\n\t\t\tqualityEpsilon = 1e-6,\n\t\t\tpaL = pa - windingEpsilon,\n\t\t\tpaR = pa + windingEpsilon,\n\t\t\twindingL = 0,\n\t\t\twindingR = 0,\n\t\t\tpathWindingL = 0,\n\t\t\tpathWindingR = 0,\n\t\t\tonPath = false,\n\t\t\tonAnyPath = false,\n\t\t\tquality = 1,\n\t\t\troots = [],\n\t\t\tvPrev,\n\t\t\tvClose;\n\n\t\tfunction addWinding(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po < min(o0, o3) || po > max(o0, o3)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar a0 = v[ia + 0],\n\t\t\t\ta1 = v[ia + 2],\n\t\t\t\ta2 = v[ia + 4],\n\t\t\t\ta3 = v[ia + 6];\n\t\t\tif (o0 === o3) {\n\t\t\t\tif (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t =   po === o0 ? 0\n\t\t\t\t\t: po === o3 ? 1\n\t\t\t\t\t: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Curve.solveCubic(v, io, po, roots, 0, 1) > 0\n\t\t\t\t\t\t? roots[0]\n\t\t\t\t\t\t: 1,\n\t\t\t\ta =   t === 0 ? a0\n\t\t\t\t\t: t === 1 ? a3\n\t\t\t\t\t: Curve.getPoint(v, t)[dir ? 'y' : 'x'],\n\t\t\t\twinding = o0 > o3 ? 1 : -1,\n\t\t\t\twindingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,\n\t\t\t\ta3Prev = vPrev[ia + 6];\n\t\t\tif (po !== o0) {\n\t\t\t\tif (a < paL) {\n\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t} else if (a > paR) {\n\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t} else {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\tif (a > pa - qualityEpsilon && a < pa + qualityEpsilon)\n\t\t\t\t\tquality /= 2;\n\t\t\t} else {\n\t\t\t\tif (winding !== windingPrev) {\n\t\t\t\t\tif (a0 < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t} else if (a0 > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t}\n\t\t\t\t} else if (a0 != a3Prev) {\n\t\t\t\t\tif (a3Prev < paR && a > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t} else if (a3Prev > paL && a < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquality = 0;\n\t\t\t}\n\t\t\tvPrev = v;\n\t\t\treturn !dontFlip && a > paL && a < paR\n\t\t\t\t\t&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0\n\t\t\t\t\t&& getWinding(point, curves, !dir, closed, true);\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to1 = v[io + 2],\n\t\t\t\to2 = v[io + 4],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n\t\t\t\tvar a0 = v[ia + 0],\n\t\t\t\t\ta1 = v[ia + 2],\n\t\t\t\t\ta2 = v[ia + 4],\n\t\t\t\t\ta3 = v[ia + 6],\n\t\t\t\t\tmonoCurves = paL > max(a0, a1, a2, a3) ||\n\t\t\t\t\t\t\t\t paR < min(a0, a1, a2, a3)\n\t\t\t\t\t\t\t? [v] : Curve.getMonoCurves(v, dir),\n\t\t\t\t\tres;\n\t\t\t\tfor (var i = 0, l = monoCurves.length; i < l; i++) {\n\t\t\t\t\tif (res = addWinding(monoCurves[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i],\n\t\t\t\tpath = curve._path,\n\t\t\t\tv = curve.getValues(),\n\t\t\t\tres;\n\t\t\tif (!i || curves[i - 1]._path !== path) {\n\t\t\t\tvPrev = null;\n\t\t\t\tif (!path._closed) {\n\t\t\t\t\tvClose = Curve.getValues(\n\t\t\t\t\t\t\tpath.getLastCurve().getSegment2(),\n\t\t\t\t\t\t\tcurve.getSegment1(),\n\t\t\t\t\t\t\tnull, !closed);\n\t\t\t\t\tif (vClose[io] !== vClose[io + 6]) {\n\t\t\t\t\t\tvPrev = vClose;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!vPrev) {\n\t\t\t\t\tvPrev = v;\n\t\t\t\t\tvar prev = path.getLastCurve();\n\t\t\t\t\twhile (prev && prev !== curve) {\n\t\t\t\t\t\tvar v2 = prev.getValues();\n\t\t\t\t\t\tif (v2[io] !== v2[io + 6]) {\n\t\t\t\t\t\t\tvPrev = v2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = prev.getPrevious();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res = handleCurve(v))\n\t\t\t\treturn res;\n\n\t\t\tif (i + 1 === l || curves[i + 1]._path !== path) {\n\t\t\t\tif (vClose && (res = handleCurve(vClose)))\n\t\t\t\t\treturn res;\n\t\t\t\tif (onPath && !pathWindingL && !pathWindingR) {\n\t\t\t\t\tpathWindingL = pathWindingR = path.isClockwise(closed) ^ dir\n\t\t\t\t\t\t\t? 1 : -1;\n\t\t\t\t}\n\t\t\t\twindingL += pathWindingL;\n\t\t\t\twindingR += pathWindingR;\n\t\t\t\tpathWindingL = pathWindingR = 0;\n\t\t\t\tif (onPath) {\n\t\t\t\t\tonAnyPath = true;\n\t\t\t\t\tonPath = false;\n\t\t\t\t}\n\t\t\t\tvClose = null;\n\t\t\t}\n\t\t}\n\t\twindingL = abs(windingL);\n\t\twindingR = abs(windingR);\n\t\treturn {\n\t\t\twinding: max(windingL, windingR),\n\t\t\twindingL: windingL,\n\t\t\twindingR: windingR,\n\t\t\tquality: quality,\n\t\t\tonPath: onAnyPath\n\t\t};\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, curves, operator) {\n\t\tvar chain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twinding;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve(),\n\t\t\t\tlength = curve.getLength();\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\ttotalLength += length;\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tvar offsets = [0.5, 0.25, 0.75],\n\t\t\twinding = { winding: 0, quality: -1 },\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tfor (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {\n\t\t\tvar length = totalLength * offsets[i];\n\t\t\tfor (var j = 0, l = chain.length; j < l; j++) {\n\t\t\t\tvar entry = chain[j],\n\t\t\t\t\tcurveLength = entry.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tvar curve = entry.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\toperand = parent instanceof CompoundPath ? parent : path,\n\t\t\t\t\t\tt = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),\n\t\t\t\t\t\tpt = curve.getPointAtTime(t),\n\t\t\t\t\t\tdir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n\t\t\t\t\tvar wind = !(operator.subtract && path2 && (\n\t\t\t\t\t\t\toperand === path1 &&\n\t\t\t\t\t\t\t\tpath2._getWinding(pt, dir, true).winding ||\n\t\t\t\t\t\t\toperand === path2 &&\n\t\t\t\t\t\t\t\t!path1._getWinding(pt, dir, true).winding))\n\t\t\t\t\t\t\t? getWinding(pt, curves, dir, true)\n\t\t\t\t\t\t\t: { winding: 0, quality: 1 };\n\t\t\t\t\tif (wind.quality > winding.quality)\n\t\t\t\t\t\twinding = wind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tfor (var j = chain.length - 1; j >= 0; j--) {\n\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t}\n\n\tfunction tracePaths(segments, operator) {\n\t\tvar paths = [],\n\t\t\tstarts;\n\n\t\tfunction isValid(seg) {\n\t\t\tvar winding;\n\t\t\treturn !!(seg && !seg._visited && (!operator\n\t\t\t\t\t|| operator[(winding = seg._winding || {}).winding]\n\t\t\t\t\t\t&& !(operator.unite && winding.winding === 2\n\t\t\t\t\t\t\t&& winding.windingL && winding.windingR)));\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\tif (seg) {\n\t\t\t\tfor (var i = 0, l = starts.length; i < l; i++) {\n\t\t\t\t\tif (seg === starts[i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction visitPath(path) {\n\t\t\tvar segments = path._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._visited = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCrossingSegments(segment, collectStarts) {\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tstart = inter,\n\t\t\t\tcrossings = [];\n\t\t\tif (collectStarts)\n\t\t\t\tstarts = [segment];\n\n\t\t\tfunction collect(inter, end) {\n\t\t\t\twhile (inter && inter !== end) {\n\t\t\t\t\tvar other = inter._segment,\n\t\t\t\t\t\tpath = other._path,\n\t\t\t\t\t\tnext = other.getNext() || path && path.getFirstSegment(),\n\t\t\t\t\t\tnextInter = next && next._intersection;\n\t\t\t\t\tif (other !== segment && (isStart(other) || isStart(next)\n\t\t\t\t\t\t|| next && (isValid(other) && (isValid(next)\n\t\t\t\t\t\t\t|| nextInter && isValid(nextInter._segment))))) {\n\t\t\t\t\t\tcrossings.push(other);\n\t\t\t\t\t}\n\t\t\t\t\tif (collectStarts)\n\t\t\t\t\t\tstarts.push(other);\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inter) {\n\t\t\t\tcollect(inter);\n\t\t\t\twhile (inter && inter._prev)\n\t\t\t\t\tinter = inter._prev;\n\t\t\t\tcollect(inter, start);\n\t\t\t}\n\t\t\treturn crossings;\n\t\t}\n\n\t\tsegments.sort(function(seg1, seg2) {\n\t\t\tvar inter1 = seg1._intersection,\n\t\t\t\tinter2 = seg2._intersection,\n\t\t\t\tover1 = !!(inter1 && inter1._overlap),\n\t\t\t\tover2 = !!(inter2 && inter2._overlap),\n\t\t\t\tpath1 = seg1._path,\n\t\t\t\tpath2 = seg2._path;\n\t\t\treturn over1 ^ over2\n\t\t\t\t\t? over1 ? 1 : -1\n\t\t\t\t\t: !inter1 ^ !inter2\n\t\t\t\t\t\t? inter1 ? 1 : -1\n\t\t\t\t\t\t: path1 !== path2\n\t\t\t\t\t\t\t? path1._id - path2._id\n\t\t\t\t\t\t\t: seg1._index - seg2._index;\n\t\t});\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tvalid = isValid(seg),\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false,\n\t\t\t\tclosed = true,\n\t\t\t\tbranches = [],\n\t\t\t\tbranch,\n\t\t\t\tvisited,\n\t\t\t\thandleIn;\n\t\t\tif (valid && seg._path._overlapsOnly) {\n\t\t\t\tvar path1 = seg._path,\n\t\t\t\t\tpath2 = seg._intersection._segment._path;\n\t\t\t\tif (path1.compare(path2)) {\n\t\t\t\t\tif (path1.getArea())\n\t\t\t\t\t\tpaths.push(path1.clone(false));\n\t\t\t\t\tvisitPath(path1);\n\t\t\t\t\tvisitPath(path2);\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (valid) {\n\t\t\t\tvar first = !path,\n\t\t\t\t\tcrossings = getCrossingSegments(seg, first),\n\t\t\t\t\tother = crossings.shift(),\n\t\t\t\t\tfinished = !first && (isStart(seg) || isStart(other)),\n\t\t\t\t\tcross = !finished && other;\n\t\t\t\tif (first) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tif (seg.isFirst() || seg.isLast())\n\t\t\t\t\t\tclosed = seg._path._closed;\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cross && branch) {\n\t\t\t\t\tbranches.push(branch);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (!branch) {\n\t\t\t\t\tif (cross)\n\t\t\t\t\t\tcrossings.push(seg);\n\t\t\t\t\tbranch = {\n\t\t\t\t\t\tstart: path._segments.length,\n\t\t\t\t\t\tcrossings: crossings,\n\t\t\t\t\t\tvisited: visited = [],\n\t\t\t\t\t\thandleIn: handleIn\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (cross)\n\t\t\t\t\tseg = other;\n\t\t\t\tif (!isValid(seg)) {\n\t\t\t\t\tpath.removeSegments(branch.start);\n\t\t\t\t\tfor (var j = 0, k = visited.length; j < k; j++) {\n\t\t\t\t\t\tvisited[j]._visited = false;\n\t\t\t\t\t}\n\t\t\t\t\tvisited.length = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tseg = branch && branch.crossings.shift();\n\t\t\t\t\t\tif (!seg) {\n\t\t\t\t\t\t\tbranch = branches.pop();\n\t\t\t\t\t\t\tif (branch) {\n\t\t\t\t\t\t\t\tvisited = branch.visited;\n\t\t\t\t\t\t\t\thandleIn = branch.handleIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (branch && !isValid(seg));\n\t\t\t\t\tif (!seg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar next = seg.getNext();\n\t\t\t\tpath.add(new Segment(seg._point, handleIn,\n\t\t\t\t\t\tnext && seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tvisited.push(seg);\n\t\t\t\tseg = next || seg._path.getFirstSegment();\n\t\t\t\thandleIn = next && next._handleIn;\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(handleIn);\n\t\t\t\t\tpath.setClosed(closed);\n\t\t\t\t}\n\t\t\t\tif (path.getArea() !== 0) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, dir, closed) {\n\t\t\treturn getWinding(point, this.getCurves(), dir, closed);\n\t\t},\n\n\t\tunite: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'unite', options);\n\t\t},\n\n\t\tintersect: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'intersect', options);\n\t\t},\n\n\t\tsubtract: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'subtract', options);\n\t\t},\n\n\t\texclude: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'exclude', options);\n\t\t},\n\n\t\tdivide: function(path, options) {\n\t\t\treturn options && (options.trace == false || options.stroke)\n\t\t\t\t\t? splitBoolean(this, path, 'divide')\n\t\t\t\t\t: createResult([\n\t\t\t\t\t\tthis.subtract(path, options),\n\t\t\t\t\t\tthis.intersect(path, options)\n\t\t\t\t\t], true, this, path, options);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = children || [this];\n\n\t\t\tfunction hasOverlap(seg) {\n\t\t\t\tvar inter = seg && seg._intersection;\n\t\t\t\treturn inter && inter._overlap;\n\t\t\t}\n\n\t\t\tvar hasOverlaps = false,\n\t\t\t\thasCrossings = false,\n\t\t\t\tintersections = this.getIntersections(null, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap() && (hasOverlaps = true) ||\n\t\t\t\t\t\t\tinter.isCrossing() && (hasCrossings = true);\n\t\t\t\t}),\n\t\t\t\tclearCurves = hasOverlaps && hasCrossings && [];\n\t\t\tintersections = CurveLocation.expand(intersections);\n\t\t\tif (hasOverlaps) {\n\t\t\t\tvar overlaps = divideLocations(intersections, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap();\n\t\t\t\t}, clearCurves);\n\t\t\t\tfor (var i = overlaps.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar seg = overlaps[i]._segment,\n\t\t\t\t\t\tprev = seg.getPrevious(),\n\t\t\t\t\t\tnext = seg.getNext();\n\t\t\t\t\tif (hasOverlap(prev) && hasOverlap(next)) {\n\t\t\t\t\t\tseg.remove();\n\t\t\t\t\t\tprev._handleOut._set(0, 0);\n\t\t\t\t\t\tnext._handleIn._set(0, 0);\n\t\t\t\t\t\tif (prev !== seg && !prev.getCurve().hasLength()) {\n\t\t\t\t\t\t\tnext._handleIn.set(prev._handleIn);\n\t\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCrossings) {\n\t\t\t\tdivideLocations(intersections, hasOverlaps && function(inter) {\n\t\t\t\t\tvar curve1 = inter.getCurve(),\n\t\t\t\t\t\tseg1 = inter.getSegment(),\n\t\t\t\t\t\tother = inter._intersection,\n\t\t\t\t\t\tcurve2 = other._curve,\n\t\t\t\t\t\tseg2 = other._segment;\n\t\t\t\t\tif (curve1 && curve2 && curve1._path && curve2._path)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (seg1)\n\t\t\t\t\t\tseg1._intersection = null;\n\t\t\t\t\tif (seg2)\n\t\t\t\t\t\tseg2._intersection = null;\n\t\t\t\t}, clearCurves);\n\t\t\t\tif (clearCurves)\n\t\t\t\t\tclearCurveHandles(clearCurves);\n\t\t\t\tpaths = tracePaths(Base.each(paths, function(path) {\n\t\t\t\t\tthis.push.apply(this, path._segments);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\tvar length = paths.length,\n\t\t\t\titem;\n\t\t\tif (length > 1 && children) {\n\t\t\t\tif (paths !== children)\n\t\t\t\t\tthis.setChildren(paths);\n\t\t\t\titem = this;\n\t\t\t} else if (length === 1 && !children) {\n\t\t\t\tif (paths[0] !== this)\n\t\t\t\t\tthis.setSegments(paths[0].removeSegments());\n\t\t\t\titem = this;\n\t\t\t}\n\t\t\tif (!item) {\n\t\t\t\titem = new CompoundPath(Item.NO_INSERT);\n\t\t\t\titem.addChildren(paths);\n\t\t\t\titem = item.reduce();\n\t\t\t\titem.copyAttributes(this);\n\t\t\t\tthis.replaceWith(item);\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\n\t\treorient: function(nonZero, clockwise) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && children.length) {\n\t\t\t\tthis.setChildren(reorientPaths(this.removeChildren(),\n\t\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\t\treturn !!(nonZero ? w : w & 1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclockwise));\n\t\t\t} else if (clockwise !== undefined) {\n\t\t\t\tthis.setClockwise(clockwise);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\ty = point.y,\n\t\t\t\t\tintercepts = [],\n\t\t\t\t\troots = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar v = curves[i].getValues(),\n\t\t\t\t\t\to0 = v[1],\n\t\t\t\t\t\to1 = v[3],\n\t\t\t\t\t\to2 = v[5],\n\t\t\t\t\t\to3 = v[7];\n\t\t\t\t\tif (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n\t\t\t\t\t\tvar monoCurves = Curve.getMonoCurves(v);\n\t\t\t\t\t\tfor (var j = 0, m = monoCurves.length; j < m; j++) {\n\t\t\t\t\t\t\tvar mv = monoCurves[j],\n\t\t\t\t\t\t\t\tmo0 = mv[1],\n\t\t\t\t\t\t\t\tmo3 = mv[7];\n\t\t\t\t\t\t\tif ((mo0 !== mo3) &&\n\t\t\t\t\t\t\t\t(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){\n\t\t\t\t\t\t\t\tvar x = y === mo0 ? mv[0]\n\t\t\t\t\t\t\t\t\t: y === mo3 ? mv[6]\n\t\t\t\t\t\t\t\t\t: Curve.solveCubic(mv, 1, y, roots, 0, 1)\n\t\t\t\t\t\t\t\t\t\t=== 1\n\t\t\t\t\t\t\t\t\t\t? Curve.getPoint(mv, roots[0]).x\n\t\t\t\t\t\t\t\t\t\t: (mv[0] + mv[6]) / 2;\n\t\t\t\t\t\t\t\tintercepts.push(x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (intercepts.length > 1) {\n\t\t\t\t\tintercepts.sort(function(a, b) { return a - b; });\n\t\t\t\t\tpoint.x = (intercepts[0] + intercepts[1]) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point;\n\t\t}\n\t};\n});\n\nvar PathFlattener = Base.extend({\n\t_class: 'PathFlattener',\n\n\tinitialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminSpan = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, t1, t2) {\n\t\t\tif ((t2 - t1) > minSpan\n\t\t\t\t\t&& !(ignoreStraight && Curve.isStraight(curve))\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, flatness || 0.25)) {\n\t\t\t\tvar halves = Curve.subdivide(curve, 0.5),\n\t\t\t\t\ttMid = (t1 + t2) / 2;\n\t\t\t\tcomputeParts(halves[0], index, t1, tMid);\n\t\t\t\tcomputeParts(halves[1], index, tMid, t2);\n\t\t\t} else {\n\t\t\t\tvar dx = curve[6] - curve[0],\n\t\t\t\t\tdy = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tif (dist > 0) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tcurve: curve,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttime: t2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\t_get: function(offset) {\n\t\tvar parts = this.parts,\n\t\t\tlength = parts.length,\n\t\t\tstart,\n\t\t\ti, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (!j || parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\tvar part = parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = parts[i - 1],\n\t\t\t\t\tprevTime = prev && prev.index === part.index ? prev.time : 0,\n\t\t\t\t\tprevOffset = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tindex: part.index,\n\t\t\t\t\ttime: prevTime + (part.time - prevTime)\n\t\t\t\t\t\t* (offset - prevOffset) / (part.offset - prevOffset)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tindex: parts[length - 1].index,\n\t\t\ttime: 1\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tvar start = this._get(from),\n\t\t\tend = this._get(to);\n\t\tfor (var i = start.index, l = end.index; i <= l; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti === start.index ? start.time : 0,\n\t\t\t\t\ti === end.index ? end.time : 1);\n\t\t\tif (i === start.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar param = this._get(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.time);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tclosed = path._closed;\n\t\tfor (var i = 0, prev, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point;\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(prev = point.clone());\n\t\t\t}\n\t\t}\n\t\tif (closed) {\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\t\tthis.closed = closed;\n\t},\n\n\tfit: function(error) {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = null;\n\t\tif (length > 0) {\n\t\t\tsegments = [new Segment(points[0])];\n\t\t\tif (length > 1) {\n\t\t\t\tthis.fitCubic(segments, error, 0, length - 1,\n\t\t\t\t\t\tpoints[1].subtract(points[0]),\n\t\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]));\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tsegments.shift();\n\t\t\t\t\tsegments.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(segments, error, first, last, tan1, tan2) {\n\t\tvar points = this.points;\n\t\tif (last - first === 1) {\n\t\t\tvar pt1 = points[first],\n\t\t\t\tpt2 = points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(error, error * error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < error && parametersInOrder) {\n\t\t\t\tthis.addCurve(segments, curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar tanCenter = points[split - 1].subtract(points[split + 1]);\n\t\tthis.fitCubic(segments, error, first, split, tan1, tanCenter);\n\t\tthis.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(segments, curve) {\n\t\tvar prev = segments[segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tsegments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tabs = Math.abs,\n\t\t\tpoints = this.points,\n\t\t\tpt1 = points[first],\n\t\t\tpt2 = points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1,\n\t\t\talpha2;\n\t\tif (abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\talpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0\n\t\t\t\t\t\t\t: abs(c1) > epsilon ? X[1] / c1\n\t\t\t\t\t\t\t: 0;\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1,\n\t\t\t\tpt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)),\n\t\t\t\tpt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\treturn Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsOptions: { stroke: false, handle: false },\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setContent(source._content);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(265);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\tvar lines = this._lines,\n\t\t\tstyle = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar rect = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(rect, rect) : rect;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tcolorCache = {},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tcomponents = [0, 0, 0];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\tcomponents = match[1].split(',');\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar value = +components[i];\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t}\n\t\t} else if (window) {\n\t\t\tvar cached = colorCache[string];\n\t\t\tif (!cached) {\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\tdata[2] / 255\n\t\t\t\t];\n\t\t\t}\n\t\t\tcomponents = cached.slice();\n\t\t} else {\n\t\t\tcomponents = [0, 0, 0];\n\t\t}\n\t\treturn components;\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t? function(value) {\n\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t};\n\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar args = arguments,\n\t\t\t\treading = this.__read,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (reading)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = Base.slice(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (reading) {\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = Base.slice(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && !i && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (reading && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (reading)\n\t\t\t\tthis.__read = read;\n\t\t\treturn this;\n\t\t},\n\n\t\tset: '#initialize',\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this.getAlpha() === col.getAlpha()\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx, matrix) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\thighlight = components[3],\n\t\t\t\tinverse = matrix && matrix.inverted(),\n\t\t\t\tcanvasGradient;\n\t\t\tif (inverse) {\n\t\t\t\torigin = inverse._transformPoint(origin);\n\t\t\t\tdestination = inverse._transformPoint(destination);\n\t\t\t\tif (highlight)\n\t\t\t\t\thighlight = inverse._transformPoint(highlight);\n\t\t\t}\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin);\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tcanvasGradient.addColorStop(\n\t\t\t\t\t\toffset == null ? i / (l - 1) : offset,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && Base.isPlainObject(stops)) {\n\t\t\tthis.set(stops);\n\t\t\tstops = radial = null;\n\t\t}\n\t\tif (this._stops == null) {\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t}\n\t\tif (this._radial == null) {\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t\t}\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++) {\n\t\t\tthis._owners[i]._changed();\n\t\t}\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (!this._owners.length)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tstops[i] = this._stops[i].clone();\n\t\t}\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t}\n\t\tvar _stops = this._stops;\n\t\tif (_stops) {\n\t\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t\t_stops[i]._owner = undefined;\n\t\t}\n\t\t_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t_stops[i]._owner = this;\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class) {\n\t\t\tvar stops1 = this._stops,\n\t\t\t\tstops2 = gradient._stops,\n\t\t\t\tlength = stops1.length;\n\t\t\tif (length === stops2.length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (!stops1[i].equals(stops2[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tvar color = arg0,\n\t\t\toffset = arg1;\n\t\tif (typeof arg0 === 'object' && arg1 === undefined) {\n\t\t\tif (Array.isArray(arg0) && typeof arg0[0] !== 'number') {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\toffset = arg0[1];\n\t\t\t} else if ('color' in arg0 || 'offset' in arg0\n\t\t\t\t\t|| 'rampPoint' in arg0) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\toffset = arg0.offset || arg0.rampPoint || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setColor(color);\n\t\tthis.setOffset(offset);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._offset);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar color = this._color,\n\t\t\toffset = this._offset;\n\t\treturn Base.serialize(offset == null ? [color] : [color, offset],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(65);\n\t},\n\n\tgetOffset: function() {\n\t\treturn this._offset;\n\t},\n\n\tsetOffset: function(offset) {\n\t\tthis._offset = offset;\n\t\tthis._changed();\n\t},\n\n\tgetRampPoint: '#getOffset',\n\tsetRampPoint: '#setOffset',\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function() {\n\t\tvar color = Color.read(arguments, 0, { clone: true });\n\t\tif (color)\n\t\t\tcolor._owner = this;\n\t\tthis._color = color;\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._offset == stop._offset\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar itemDefaults = {\n\t\tfillColor: null,\n\t\tfillRule: 'nonzero',\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\tshadowColor: null,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: null\n\t},\n\tgroupDefaults = Base.set({}, itemDefaults, {\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tleading: null,\n\t\tjustification: 'left'\n\t}),\n\ttextDefaults = Base.set({}, groupDefaults, {\n\t\tfillColor: new Color()\n\t}),\n\tflags = {\n\t\tstrokeWidth: 97,\n\t\tstrokeCap: 97,\n\t\tstrokeJoin: 97,\n\t\tstrokeScaling: 105,\n\t\tmiterLimit: 97,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t},\n\titem = {\n\t\tbeans: true\n\t},\n\tfields = {\n\t\t_class: 'Style',\n\t\tbeans: true,\n\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project\n\t\t\t\t\t|| paper.project;\n\t\t\tthis._defaults = !_owner || _owner instanceof Group ? groupDefaults\n\t\t\t\t\t: _owner instanceof TextItem ? textDefaults\n\t\t\t\t\t: itemDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t}\n\t};\n\n\tBase.each(groupDefaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children;\n\t\t\tif (children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t} else if (key in this._defaults) {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old && old._owner !== undefined)\n\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tvalue;\n\t\t\tif (key in this._defaults && (!children || !children.length\n\t\t\t\t\t|| _dontMerge || owner instanceof CompoundPath)) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tBase.each({\n\t\tFont: 'FontFamily',\n\t\tWindingRule: 'FillRule'\n\t}, function(value, key) {\n\t\tvar get = 'get' + key,\n\t\t\tset = 'set' + key;\n\t\tfields[get] = item[get] = '#get' + value;\n\t\tfields[set] = item[set] = '#set' + value;\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\tfunction compare(style1, style2, secondary) {\n\t\t\tvar values1 = style1._values,\n\t\t\t\tvalues2 = style2._values,\n\t\t\t\tdefaults2 = style2._defaults;\n\t\t\tfor (var key in values1) {\n\t\t\t\tvar value1 = values1[key],\n\t\t\t\t\tvalue2 = values2[key];\n\t\t\t\tif (!(secondary && key in values2) && !Base.equals(value1,\n\t\t\t\t\t\tvalue2 === undefined ? defaults2[key] : value2))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& compare(this, style)\n\t\t\t\t&& compare(style, this, true)\n\t\t\t\t|| false;\n\t},\n\n\thasFill: function() {\n\t\tvar color = this.getFillColor();\n\t\treturn !!color && color.alpha > 0;\n\t},\n\n\thasStroke: function() {\n\t\tvar color = this.getStrokeColor();\n\t\treturn !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\tvar color = this.getShadowColor();\n\t\treturn !!color && color.alpha > 0 && (this.getShadowBlur() > 0\n\t\t\t\t|| !this.getShadowOffset().isZero());\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tisInserted: function(el) {\n\t\t\treturn document.body.contains(el);\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn el && handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\ttimer;\n\n\tfunction handleCallbacks() {\n\t\tvar functions = callbacks;\n\t\tcallbacks = [];\n\t\tfor (var i = 0, l = functions.length; i < l; i++)\n\t\t\tfunctions[i]();\n\t\trequested = nativeRequest && callbacks.length;\n\t\tif (requested)\n\t\t\tnativeRequest(handleCallbacks);\n\t}\n\n\treturn function(callback) {\n\t\tcallbacks.push(callback);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t}\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t}\n\n\t\tvar size;\n\t\tif (window && element) {\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserDrag: none,\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsize = getCanvasSize();\n\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = new Size(element);\n\t\t\telement = null;\n\t\t}\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window && window.devicePixelRatio || 1;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize = size;\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t\tthis._itemEvents = { native: {}, virtual: {} };\n\t\tthis._autoUpdate = !paper.agent.node;\n\t\tthis._needsUpdate = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tvar project = this._project;\n\t\tif (project._view === this)\n\t\t\tproject._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(\n\t\tItem._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),\n\t\tfunction(name) {\n\t\t\tthis[name] = {};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\tgetAutoUpdate: function() {\n\t\treturn this._autoUpdate;\n\t},\n\n\tsetAutoUpdate: function(autoUpdate) {\n\t\tthis._autoUpdate = autoUpdate;\n\t\tif (autoUpdate)\n\t\t\tthis.requestUpdate();\n\t},\n\n\tupdate: function() {\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\trequestUpdate: function() {\n\t\tif (!this._requested) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (that._animate) {\n\t\t\t\t\tthat.requestUpdate();\n\t\t\t\t\tvar element = that._element;\n\t\t\t\t\tif ((!DomElement.getPrefixed(document, 'hidden')\n\t\t\t\t\t\t\t|| PaperScope.getAttribute(element, 'keepalive')\n\t\t\t\t\t\t\t\t=== 'true') && DomElement.isInView(element)) {\n\t\t\t\t\t\tthat._handleFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (that._autoUpdate)\n\t\t\t\t\tthat.update();\n\t\t\t});\n\t\t\tthis._requested = true;\n\t\t}\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tthis.requestUpdate();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._last ? now - this._last : 0;\n\t\tthis._last = now;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tthis._project._changed(2049);\n\t\tthis._bounds = this._decomposed = undefined;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize.set(size);\n\t\tthis._changed();\n\t\tthis.emit('resize', { size: size, delta: delta });\n\t\tif (this._autoUpdate) {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_setElementSize: function(width, height) {\n\t\tvar element = this._element;\n\t\tif (element) {\n\t\t\tif (element.width !== width)\n\t\t\t\telement.width = width;\n\t\t\tif (element.height !== height)\n\t\t\t\telement.height = height;\n\t\t}\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tisInserted: function() {\n\t\treturn DomElement.isInserted(this._element);\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixels;\n\t\tif (element) {\n\t\t\tvar parent = element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tpixels = parseFloat(pixels);\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\treturn 0;\n\t}\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getCenter(true)));\n\t};\n}, {\n\t_decompose: function() {\n\t\treturn this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.translate(this.getCenter().subtract(center));\n\t},\n\n\tgetZoom: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling ? (scaling.x + scaling.y) / 2 : 0;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis.transform(new Matrix().scale(zoom / this.getZoom(),\n\t\t\tthis.getCenter()));\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed && decomposed.rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tthis.rotate(rotation - current);\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling\n\t\t\t\t? new LinkedPoint(scaling.x, scaling.y, this, 'setScaling')\n\t\t\t\t: undefined;\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling) {\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._matrix.append(matrix);\n\t},\n\n\tscrollBy: function() {\n\t\tthis.translate(Point.read(arguments).negate());\n\t}\n}), {\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tgetEventPoint: function(event) {\n\t\treturn this.viewToProject(DomEvent.getOffset(event, this._element));\n\t},\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (document && typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\tvar ctor = window ? CanvasView : View;\n\t\t\treturn new ctor(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tif (!window)\n\t\treturn;\n\tvar prevFocus,\n\t\ttempFocus,\n\t\tdragging = false,\n\t\tmouseDown = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[\n\t\t\t\ttarget.getAttribute('id')];\n\t}\n\n\tfunction updateFocus() {\n\t\tvar view = View._focused;\n\t\tif (!view || !view.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tif ((view = View._views[i]).isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, event, point) {\n\t\tview._handleMouseEvent('mousemove', event, point);\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {},\n\t\tdocEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML')) {\n\t\t\t\t\tvar offset = DomEvent.getOffset(event, view._element),\n\t\t\t\t\t\tx = offset.x,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\tax = abs(x),\n\t\t\t\t\t\tmax = 1 << 25,\n\t\t\t\t\t\tdiff = ax - max;\n\t\t\t\t\toffset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n\t\t\t\t\thandleMouseMove(view, event, view.viewToProject(offset));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tscroll: updateFocus\n\t\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event);\n\t\tif (!dragging) {\n\t\t\tdragging = true;\n\t\t\tview._handleMouseEvent('mousedown', event);\n\t\t}\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!mouseDown) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target) {\n\t\t\t\t\tif (view)\n\t\t\t\t\t\thandleMouseMove(view, event);\n\t\t\t\t\tif (!prevFocus)\n\t\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t}\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tif (prevFocus && !prevFocus.isInserted())\n\t\t\t\t\tprevFocus = null;\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tprevFocus = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view)\n\t\t\thandleMouseMove(view, event);\n\t};\n\n\tdocEvents[mousedown] = function() {\n\t\tmouseDown = true;\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (view && dragging)\n\t\t\tview._handleMouseEvent('mouseup', event);\n\t\tmouseDown = dragging = false;\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar called = false,\n\t\tprevented = false,\n\t\tfallbacks = {\n\t\t\tdoubleclick: 'click',\n\t\t\tmousedrag: 'mousemove'\n\t\t},\n\t\twasInView = false,\n\t\toverView,\n\t\tdownPoint,\n\t\tlastPoint,\n\t\tdownItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tclickItem,\n\t\tclickTime,\n\t\tdblClick;\n\n\tfunction emitMouseEvent(obj, target, type, event, point, prevPoint,\n\t\t\tstopItem) {\n\t\tvar stopped = false,\n\t\t\tmouseEvent;\n\n\t\tfunction emit(obj, type) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point,\n\t\t\t\t\t\t\ttarget || obj,\n\t\t\t\t\t\t\tprevPoint ? point.subtract(prevPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent)) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif (mouseEvent.prevented)\n\t\t\t\t\t\tprevented = true;\n\t\t\t\t\tif (mouseEvent.stopped)\n\t\t\t\t\t\treturn stopped = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar fallback = fallbacks[type];\n\t\t\t\tif (fallback)\n\t\t\t\t\treturn emit(obj, fallback);\n\t\t\t}\n\t\t}\n\n\t\twhile (obj && obj !== stopItem) {\n\t\t\tif (emit(obj, type))\n\t\t\t\tbreak;\n\t\t\tobj = obj._parent;\n\t\t}\n\t\treturn stopped;\n\t}\n\n\tfunction emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n\t\tview._project.removeOn(type);\n\t\tprevented = called = false;\n\t\treturn (dragItem && emitMouseEvent(dragItem, null, type, event,\n\t\t\t\t\tpoint, prevPoint)\n\t\t\t|| hitItem && hitItem !== dragItem\n\t\t\t\t&& !hitItem.isDescendant(dragItem)\n\t\t\t\t&& emitMouseEvent(hitItem, null, type, event, point, prevPoint,\n\t\t\t\t\tdragItem)\n\t\t\t|| emitMouseEvent(view, dragItem || hitItem || view, type, event,\n\t\t\t\t\tpoint, prevPoint));\n\t}\n\n\tvar itemEventsMap = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleMouseEvent: function(type, event, point) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\thitItems = itemEvents.native[type],\n\t\t\t\tnativeMove = type === 'mousemove',\n\t\t\t\ttool = this._scope.tool,\n\t\t\t\tview = this;\n\n\t\t\tfunction responds(type) {\n\t\t\t\treturn itemEvents.virtual[type] || view.responds(type)\n\t\t\t\t\t\t|| tool && tool.responds(type);\n\t\t\t}\n\n\t\t\tif (nativeMove && dragging && responds('mousedrag'))\n\t\t\t\ttype = 'mousedrag';\n\t\t\tif (!point)\n\t\t\t\tpoint = this.getEventPoint(event);\n\n\t\t\tvar inView = this.getBounds().contains(point),\n\t\t\t\thit = hitItems && inView && view._project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\thitItem = hit && hit.item || null,\n\t\t\t\thandle = false,\n\t\t\t\tmouse = {};\n\t\t\tmouse[type.substr(5)] = true;\n\n\t\t\tif (hitItems && hitItem !== overItem) {\n\t\t\t\tif (overItem) {\n\t\t\t\t\temitMouseEvent(overItem, null, 'mouseleave', event, point);\n\t\t\t\t}\n\t\t\t\tif (hitItem) {\n\t\t\t\t\temitMouseEvent(hitItem, null, 'mouseenter', event, point);\n\t\t\t\t}\n\t\t\t\toverItem = hitItem;\n\t\t\t}\n\t\t\tif (wasInView ^ inView) {\n\t\t\t\temitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',\n\t\t\t\t\t\tevent, point);\n\t\t\t\toverView = inView ? this : null;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tif ((inView || mouse.drag) && !point.equals(lastPoint)) {\n\t\t\t\temitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',\n\t\t\t\t\t\tevent, point, lastPoint);\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\twasInView = inView;\n\t\t\tif (mouse.down && inView || mouse.up && downPoint) {\n\t\t\t\temitMouseEvents(this, hitItem, type, event, point, downPoint);\n\t\t\t\tif (mouse.down) {\n\t\t\t\t\tdblClick = hitItem === clickItem\n\t\t\t\t\t\t&& (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = clickItem = hitItem;\n\t\t\t\t\tif (!prevented && hitItem) {\n\t\t\t\t\t\tvar item = hitItem;\n\t\t\t\t\t\twhile (item && !item.responds('mousedrag'))\n\t\t\t\t\t\t\titem = item._parent;\n\t\t\t\t\t\tif (item)\n\t\t\t\t\t\t\tdragItem = hitItem;\n\t\t\t\t\t}\n\t\t\t\t\tdownPoint = point;\n\t\t\t\t} else if (mouse.up) {\n\t\t\t\t\tif (!prevented && hitItem === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\temitMouseEvents(this, hitItem, dblClick ? 'doubleclick'\n\t\t\t\t\t\t\t\t: 'click', event, point, downPoint);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t}\n\t\t\t\twasInView = false;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tlastPoint = point;\n\t\t\tif (handle && tool) {\n\t\t\t\tcalled = tool._handleMouseEvent(type, event, point, mouse)\n\t\t\t\t\t|| called;\n\t\t\t}\n\n\t\t\tif (called && !mouse.move || mouse.down && responds('mouseup'))\n\t\t\t\tevent.preventDefault();\n\t\t},\n\n\t\t_handleKeyEvent: function(type, event, key, character) {\n\t\t\tvar scope = this._scope,\n\t\t\t\ttool = scope.tool,\n\t\t\t\tkeyEvent;\n\n\t\t\tfunction emit(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tpaper = scope;\n\t\t\t\t\tobj.emit(type, keyEvent = keyEvent\n\t\t\t\t\t\t\t|| new KeyEvent(type, event, key, character));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isVisible()) {\n\t\t\t\temit(this);\n\t\t\t\tif (tool && tool.responds(type))\n\t\t\t\t\temit(tool);\n\t\t\t}\n\t\t},\n\n\t\t_countItemEvent: function(type, sign) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\tnative = itemEvents.native,\n\t\t\t\tvirtual = itemEvents.virtual;\n\t\t\tfor (var key in itemEventsMap) {\n\t\t\t\tnative[key] = (native[key] || 0)\n\t\t\t\t\t\t+ (itemEventsMap[key][type] || 0) * sign;\n\t\t\t}\n\t\t\tvirtual[type] = (virtual[type] || 0) + sign;\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof window.HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ Base.slice(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tvar ctx = this._context = canvas.getContext('2d');\n\t\tctx.save();\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(ctx,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t\tthis._needsUpdate = true;\n\t},\n\n\tremove: function remove() {\n\t\tthis._context.restore();\n\t\treturn remove.base.call(this);\n\t},\n\n\t_setElementSize: function _setElementSize(width, height) {\n\t\tvar pixelRatio = this._pixelRatio;\n\t\t_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n\t\tif (pixelRatio !== 1) {\n\t\t\tvar element = this._element,\n\t\t\t\tctx = this._context;\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\tctx.save();\n\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetPixelSize: function getPixelSize(size) {\n\t\tvar agent = paper.agent,\n\t\t\tpixels;\n\t\tif (agent && agent.firefox) {\n\t\t\tpixels = getPixelSize.base.call(this, size);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function() {\n\t\tif (!this._needsUpdate)\n\t\t\treturn false;\n\t\tvar project = this._project,\n\t\t\tctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tif (project)\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tthis._needsUpdate = false;\n\t\treturn true;\n\t}\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t\tthis.type = event && event.type;\n\t},\n\n\tprevented: false,\n\tstopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.prevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.stopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetTimeStamp: function() {\n\t\treturn this.event.timeStamp;\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(type, event, key, character) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\tvar keyLookup = {\n\t\t\t'\\t': 'tab',\n\t\t\t' ': 'space',\n\t\t\t'\\b': 'backspace',\n\t\t\t'\\x7f': 'delete',\n\t\t\t'Spacebar': 'space',\n\t\t\t'Del': 'delete',\n\t\t\t'Win': 'meta',\n\t\t\t'Esc': 'escape'\n\t\t},\n\n\t\tcharLookup = {\n\t\t\t'tab': '\\t',\n\t\t\t'space': ' ',\n\t\t\t'enter': '\\r'\n\t\t},\n\n\t\tkeyMap = {},\n\t\tcharMap = {},\n\t\tmetaFixMap,\n\t\tdownKey,\n\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\talt: false,\n\t\t\tmeta: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}).inject({\n\t\t\toption: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.alt;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcommand: {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar agent = paper && paper.agent;\n\t\t\t\t\treturn agent && agent.mac ? this.meta : this.control;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tfunction getKey(event) {\n\t\tvar key = event.key || event.keyIdentifier;\n\t\tkey = /^U\\+/.test(key)\n\t\t\t\t? String.fromCharCode(parseInt(key.substr(2), 16))\n\t\t\t\t: /^Arrow[A-Z]/.test(key) ? key.substr(5)\n\t\t\t\t: key === 'Unidentified' ? String.fromCharCode(event.keyCode)\n\t\t\t\t: key;\n\t\treturn keyLookup[key] ||\n\t\t\t\t(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n\t}\n\n\tfunction handleKey(down, key, character, event) {\n\t\tvar type = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharMap[key] = character;\n\t\t} else {\n\t\t\tdelete charMap[key];\n\t\t}\n\t\tif (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar agent = paper && paper.agent;\n\t\t\tif (name === 'meta' && agent && agent.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tmetaFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var k in metaFixMap) {\n\t\t\t\t\t\tif (k in charMap)\n\t\t\t\t\t\t\thandleKey(false, k, metaFixMap[k], event);\n\t\t\t\t\t}\n\t\t\t\t\tmetaFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && metaFixMap) {\n\t\t\tmetaFixMap[key] = character;\n\t\t}\n\t\tif (view) {\n\t\t\tview._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,\n\t\t\t\t\tcharacter);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar key = getKey(event),\n\t\t\t\tagent = paper && paper.agent;\n\t\t\tif (key.length > 1 || agent && (agent.chrome && (event.altKey\n\t\t\t\t\t\t|| agent.mac && event.metaKey\n\t\t\t\t\t\t|| !agent.mac && event.ctrlKey))) {\n\t\t\t\thandleKey(true, key,\n\t\t\t\t\t\tcharLookup[key] || (key.length > 1 ? '' : key), event);\n\t\t\t} else {\n\t\t\t\tdownKey = key;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downKey) {\n\t\t\t\tvar key = getKey(event),\n\t\t\t\t\tcode = event.charCode,\n\t\t\t\t\tcharacter = code >= 32 ? String.fromCharCode(code)\n\t\t\t\t\t\t: key.length > 1 ? '' : key;\n\t\t\t\tif (key !== downKey) {\n\t\t\t\t\tkey = character.toLowerCase();\n\t\t\t\t}\n\t\t\t\thandleKey(true, key, character, event);\n\t\t\t\tdownKey = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar key = getKey(event);\n\t\t\tif (key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn this.tool[/^mouse(down|up)$/.test(this.type)\n\t\t\t\t? '_downCount' : '_moveCount'];\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',\n\t\t\t'onKeyUp'],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._moveCount = -1;\n\t\tthis._downCount = -1;\n\t\tthis.set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_handleMouseEvent: function(type, event, point, mouse) {\n\t\tpaper = this._scope;\n\t\tif (mouse.drag && !this.responds(type))\n\t\t\ttype = 'mousemove';\n\t\tvar move = mouse.move || mouse.drag,\n\t\t\tresponds = this.responds(type),\n\t\t\tminDistance = this.minDistance,\n\t\t\tmaxDistance = this.maxDistance,\n\t\t\tcalled = false,\n\t\t\ttool = this;\n\t\tfunction update(minDistance, maxDistance) {\n\t\t\tvar pt = point,\n\t\t\t\ttoolPoint = move ? tool._point : (tool._downPoint || pt);\n\t\t\tif (move) {\n\t\t\t\tif (tool._moveCount && pt.equals(toolPoint)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (toolPoint && (minDistance != null || maxDistance != null)) {\n\t\t\t\t\tvar vector = pt.subtract(toolPoint),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < (minDistance || 0))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance) {\n\t\t\t\t\t\tpt = toolPoint.add(vector.normalize(\n\t\t\t\t\t\t\t\tMath.min(distance, maxDistance)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttool._moveCount++;\n\t\t\t}\n\t\t\ttool._point = pt;\n\t\t\ttool._lastPoint = toolPoint || pt;\n\t\t\tif (mouse.down) {\n\t\t\t\ttool._moveCount = -1;\n\t\t\t\ttool._downPoint = pt;\n\t\t\t\ttool._downCount++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction emit() {\n\t\t\tif (responds) {\n\t\t\t\tcalled = tool.emit(type, new ToolEvent(tool, type, event))\n\t\t\t\t\t\t|| called;\n\t\t\t}\n\t\t}\n\n\t\tif (mouse.down) {\n\t\t\tupdate();\n\t\t\temit();\n\t\t} else if (mouse.up) {\n\t\t\tupdate(null, maxDistance);\n\t\t\temit();\n\t\t} else if (responds) {\n\t\t\twhile (update(minDistance, maxDistance))\n\t\t\t\temit();\n\t\t}\n\t\treturn called;\n\t}\n\n});\n\nvar Http = {\n\trequest: function(options) {\n\t\tvar xhr = new self.XMLHttpRequest();\n\t\txhr.open((options.method || 'get').toUpperCase(), options.url,\n\t\t\t\tBase.pick(options.async, true));\n\t\tif (options.mimeType)\n\t\t\txhr.overrideMimeType(options.mimeType);\n\t\txhr.onload = function() {\n\t\t\tvar status = xhr.status;\n\t\t\tif (status === 0 || status === 200) {\n\t\t\t\tif (options.onLoad) {\n\t\t\t\t\toptions.onLoad.call(xhr, xhr.responseText);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txhr.onerror();\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tvar status = xhr.status,\n\t\t\t\tmessage = 'Could not load \"' + options.url + '\" (Status: '\n\t\t\t\t\t\t+ status + ')';\n\t\t\tif (options.onError) {\n\t\t\t\toptions.onError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height) {\n\t\tif (!window)\n\t\t\treturn null;\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tclear = false;\n\t\t}\n\t\tvar ctx = canvas.getContext('2d');\n\t\tif (!ctx) {\n\t\t\tthrow new Error('Canvas ' + canvas +\n\t\t\t\t\t' is unable to provide a 2D context.');\n\t\t}\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height) {\n\t\tvar canvas = this.getCanvas(width, height);\n\t\treturn canvas ? canvas.getContext('2d') : null;\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj && obj.canvas ? obj.canvas : obj;\n\t\tif (canvas && canvas.getContext) {\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1);\n\tif (ctx) {\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken\n\t\t\t\t\t\t\t? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t}\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SvgElement = new function() {\n\tvar svg = 'http://www.w3.org/2000/svg',\n\t\txmlns = 'http://www.w3.org/2000/xmlns',\n\t\txlink = 'http://www.w3.org/1999/xlink',\n\t\tattributeNamespace = {\n\t\t\thref: xlink,\n\t\t\txlink: xmlns,\n\t\t\txmlns: xmlns + '/',\n\t\t\t'xmlns:xlink': xmlns + '/'\n\t\t};\n\n\tfunction create(tag, attributes, formatter) {\n\t\treturn set(document.createElementNS(svg, tag), attributes, formatter);\n\t}\n\n\tfunction get(node, name) {\n\t\tvar namespace = attributeNamespace[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\treturn value === 'null' ? null : value;\n\t}\n\n\tfunction set(node, attributes, formatter) {\n\t\tfor (var name in attributes) {\n\t\t\tvar value = attributes[name],\n\t\t\t\tnamespace = attributeNamespace[name];\n\t\t\tif (typeof value === 'number' && formatter)\n\t\t\t\tvalue = formatter.number(value);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, name, value);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\treturn {\n\t\tsvg: svg,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\n\t\tcreate: create,\n\t\tget: get,\n\t\tset: set\n\t};\n};\n\nvar SvgStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tfillRule: ['fill-rule', 'string'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'style']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nnew function() {\n\tvar formatter;\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tmatrix = matrix._shiftless();\n\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\ttrans = null;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling,\n\t\t\t\t\tskew = decomposed.skewing;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (skew.x)\n\t\t\t\t\tparts.push('skewX(' + formatter.number(skew.x) + ')');\n\t\t\t\tif (skew.y)\n\t\t\t\t\tparts.push('skewY(' + formatter.number(skew.y) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = SvgElement.create('g', attrs, formatter);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = SvgElement.create('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tSvgElement.set(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages == false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn SvgElement.create('image', attrs, formatter);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\tlength = segments.length,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (matchShapes && length >= 2 && !item.hasHandles()) {\n\t\t\tif (length > 2) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t}\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar start = segments[0]._point,\n\t\t\t\t\tend = segments[1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: end.x,\n\t\t\t\t\ty2: end.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn SvgElement.create('path', attrs, formatter);\n\t}\n\n\tfunction exportSymbolItem(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tdefinition = item._definition,\n\t\t\tnode = getDefinition(definition, 'symbol'),\n\t\t\tdefinitionItem = definition._item,\n\t\t\tbounds = definitionItem.getBounds();\n\t\tif (!node) {\n\t\t\tnode = SvgElement.create('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tnode.appendChild(exportSVG(definitionItem, options));\n\t\t\tsetDefinition(definition, node, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + node.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = bounds.width;\n\t\tattrs.height = bounds.height;\n\t\tattrs.overflow = 'visible';\n\t\treturn SvgElement.create('use', attrs, formatter);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin(),\n\t\t\t\tdestination = color.getDestination(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = SvgElement.create((radial ? 'radial' : 'linear')\n\t\t\t\t\t+ 'Gradient', attrs, formatter);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha(),\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: offset == null ? i / (l - 1) : offset\n\t\t\t\t};\n\t\t\t\tif (stopColor)\n\t\t\t\t\tattrs['stop-color'] = stopColor.toCSS(true);\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(\n\t\t\t\t\t\tSvgElement.create('stop', attrs, formatter));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = SvgElement.create('text', getTransform(item._matrix, true),\n\t\t\t\tformatter);\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tSymbolItem: exportSymbolItem,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent(),\n\t\t\tstyle = [];\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SvgStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tif (type === 'style') {\n\t\t\t\t\tstyle.push(entry.attribute + ': ' + value);\n\t\t\t\t} else {\n\t\t\t\t\tattrs[entry.attribute] = value == null ? 'none'\n\t\t\t\t\t\t\t: type === 'color' ? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array' ? value.join(',')\n\t\t\t\t\t\t\t: type === 'lookup' ? entry.toSVG[value]\n\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (style.length)\n\t\t\tattrs.style = style.join(';');\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn SvgElement.set(node, attrs, formatter);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-'\n\t\t\t\t+ (item._id || item.__id || (item.__id = UID.get('svg')))];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + typeId;\n\t\tdefinitions.svgs[type + '-' + (item._id || item.__id)] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = SvgElement.create('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(SvgElement.create('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new self.XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar children = this._children,\n\t\t\t\tview = this.getView(),\n\t\t\t\tbounds = Base.pick(options.bounds, 'view'),\n\t\t\t\tmx = options.matrix || bounds === 'view' && view._matrix,\n\t\t\t\tmatrix = mx && Matrix.read([mx]),\n\t\t\t\trect = bounds === 'view'\n\t\t\t\t\t? new Rectangle([0, 0], view.getViewSize())\n\t\t\t\t\t: bounds === 'content'\n\t\t\t\t\t\t? Item._getBounds(children, matrix, { stroke: true })\n\t\t\t\t\t\t\t.rect\n\t\t\t\t\t\t: Rectangle.read([bounds], 0, { readNull: true }),\n\t\t\t\tattrs = {\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: SvgElement.svg,\n\t\t\t\t\t'xmlns:xlink': SvgElement.xlink,\n\t\t\t\t};\n\t\t\tif (rect) {\n\t\t\t\tattrs.width = rect.width;\n\t\t\t\tattrs.height = rect.height;\n\t\t\t\tif (rect.x || rect.y)\n\t\t\t\t\tattrs.viewBox = formatter.rectangle(rect);\n\t\t\t}\n\t\t\tvar node = SvgElement.create('svg', attrs, formatter),\n\t\t\t\tparent = node;\n\t\t\tif (matrix && !matrix.isIdentity()) {\n\t\t\t\tparent = node.appendChild(SvgElement.create('g',\n\t\t\t\t\t\tgetTransform(matrix), formatter));\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tparent.appendChild(exportSVG(children[i], options, true));\n\t\t\t}\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tvar definitions = {},\n\t\trootSize;\n\n\tfunction getValue(node, name, isString, allowNull, allowPercent) {\n\t\tvar value = SvgElement.get(node, name),\n\t\t\tres = value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString ? '' : 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t\treturn /%\\s*$/.test(value)\n\t\t\t? (res / 100) * (allowPercent ? 1\n\t\t\t\t: rootSize[/x|^width/.test(name) ? 'width' : 'height'])\n\t\t\t: res;\n\t}\n\n\tfunction getPoint(node, x, y, allowNull, allowPercent) {\n\t\tx = getValue(node, x || 'x', false, allowNull, allowPercent);\n\t\ty = getValue(node, y || 'y', false, allowNull, allowPercent);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull, allowPercent) {\n\t\tw = getValue(node, w || 'width', false, allowNull, allowPercent);\n\t\th = getValue(node, h || 'height', false, allowNull, allowPercent);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none' ? null\n\t\t\t\t: type === 'number' ? parseFloat(value)\n\t\t\t\t: type === 'array' ?\n\t\t\t\t\tvalue ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t: type === 'color' ? getDefinition(value) || value\n\t\t\t\t: type === 'lookup' ? lookup[value]\n\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\tisDefs = type === 'defs',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip && !isDefs) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportNode(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& !/^defs$/i.test(childNode.nodeName)\n\t\t\t\t\t&& (child = importNode(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof SymbolDefinition))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || isDefs) {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\treturn PathItem.create(node.getAttribute('d'));\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tradial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t\tif (gradient._radial ^ radial) {\n\t\t\t\tgradient = gradient.clone();\n\t\t\t\tgradient._radial = radial;\n\t\t\t}\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, radial);\n\t\t}\n\t\tvar origin, destination, highlight,\n\t\t\tscaleToBounds = getValue(node, 'gradientUnits', true) !==\n\t\t\t\t'userSpaceOnUse';\n\t\tif (radial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy', false, scaleToBounds);\n\t\t\tdestination = origin.add(\n\t\t\t\t\tgetValue(node, 'r', false, false, scaleToBounds), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1', false, scaleToBounds);\n\t\t\tdestination = getPoint(node, 'x2', 'y2', false, scaleToBounds);\n\t\t}\n\t\tvar color = applyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\tcolor._scaleToBounds = scaleToBounds;\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\treturn importNode(child, options, isRoot);\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node);\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\tgetPoint(node).add(size.divide(2)));\n\t\t\t\tthis.translate(center);\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new SymbolDefinition(\n\t\t\t\t\timportGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node);\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof SymbolDefinition\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(\n\t\t\t\t\tgetPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\treturn new Shape.Rectangle(new Rectangle(\n\t\t\t\t\t\tgetPoint(node),\n\t\t\t\t\t\tgetSize(node)\n\t\t\t\t\t), getSize(node, 'rx', 'ry'));\n\t\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(\n\t\t\t\t\tgetPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node).add(\n\t\t\t\t\tgetPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t}\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tif (item.transform) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.append(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',\n\t\t\tcolor = item[key] && item[key]();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SvgStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\tif (item[entry.set]) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color') {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tif (color._scaleToBounds) {\n\t\t\t\t\t\t\tvar bounds = item.getBounds();\n\t\t\t\t\t\t\tcolor.transform(new Matrix()\n\t\t\t\t\t\t\t\t.translate(bounds.getPoint())\n\t\t\t\t\t\t\t\t.scale(bounds.getSize()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tif (item.setOffset) {\n\t\t\t\tvar percent = value.match(/(.*)%$/);\n\t\t\t\titem.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n\t\t\t}\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, null, null, true),\n\t\t\t\tgroup,\n\t\t\t\tmatrix;\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? size.divide(rect.getSize()) : 1,\n\t\t\t\tmatrix = new Matrix().scale(scale)\n\t\t\t\t\t\t.translate(rect.getPoint().negate());\n\t\t\t\tgroup = item;\n\t\t\t} else if (item instanceof SymbolDefinition) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tgroup = item._item;\n\t\t\t}\n\t\t\tif (group)  {\n\t\t\t\tif (getAttribute(node, 'overflow', styles) !== 'visible') {\n\t\t\t\t\tvar clip = new Shape.Rectangle(rect);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t\tif (matrix)\n\t\t\t\t\tgroup.transform(matrix);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value ? undefined\n\t\t\t\t: value === 'none' ? null\n\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tif (node.style) {\n\t\t\tvar parent = node.parentNode,\n\t\t\t\tstyles = {\n\t\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\t\tparent: !isRoot && !/^defs$/i.test(parent.tagName)\n\t\t\t\t\t\t\t&& DomElement.getStyles(parent) || {}\n\t\t\t\t};\n\t\t\tBase.each(attributes, function(apply, name) {\n\t\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\t\titem = value !== undefined\n\t\t\t\t\t\t&& apply(item, value, name, node, styles) || item;\n\t\t\t});\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/),\n\t\t\tname = match && match[1],\n\t\t\tres = name && definitions[window\n\t\t\t\t\t? name.replace(window.location.href.split('#')[0] + '#', '')\n\t\t\t\t\t: name];\n\t\tif (res && res._scaleToBounds) {\n\t\t\tres = res.clone();\n\t\t\tres._scaleToBounds = true;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction importNode(node, options, isRoot) {\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\tisElement = type !== '#document',\n\t\t\tbody = document.body,\n\t\t\tcontainer,\n\t\t\tparent,\n\t\t\tnext;\n\t\tif (isRoot && isElement) {\n\t\t\trootSize = paper.getView().getSize();\n\t\t\trootSize = getSize(node, null, null, true) || rootSize;\n\t\t\tcontainer = SvgElement.create('svg', {\n\t\t\t\tstyle: 'stroke-width: 1px; stroke-miterlimit: 10'\n\t\t\t});\n\t\t\tparent = node.parentNode;\n\t\t\tnext = node.nextSibling;\n\t\t\tcontainer.appendChild(node);\n\t\t\tbody.appendChild(container);\n\t\t}\n\t\tvar settings = paper.settings,\n\t\t\tapplyMatrix = settings.applyMatrix,\n\t\t\tinsertItems = settings.insertItems;\n\t\tsettings.applyMatrix = false;\n\t\tsettings.insertItems = false;\n\t\tvar importer = importers[type],\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.insertItems = insertItems;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (isElement && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport,\n\t\t\t\tdata = isElement && node.getAttribute('data-paper-data');\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (container) {\n\t\t\tbody.removeChild(container);\n\t\t\tif (parent) {\n\t\t\t\tif (next) {\n\t\t\t\t\tparent.insertBefore(node, next);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importSVG(source, options, owner) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\toptions = typeof options === 'function' ? { onLoad: options }\n\t\t\t\t: options || {};\n\t\tvar scope = paper,\n\t\t\titem = null;\n\n\t\tfunction onLoad(svg) {\n\t\t\ttry {\n\t\t\t\tvar node = typeof svg === 'object' ? svg : new self.DOMParser()\n\t\t\t\t\t\t.parseFromString(svg, 'image/svg+xml');\n\t\t\t\tif (!node.nodeName) {\n\t\t\t\t\tnode = null;\n\t\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\t\t}\n\t\t\t\tpaper = scope;\n\t\t\t\titem = importNode(node, options, true);\n\t\t\t\tif (!options || options.insert !== false) {\n\t\t\t\t\towner._insertItem(undefined, item);\n\t\t\t\t}\n\t\t\t\tvar onLoad = options.onLoad;\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad(item, svg);\n\t\t\t} catch (e) {\n\t\t\t\tonError(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction onError(message, status) {\n\t\t\tvar onError = options.onError;\n\t\t\tif (onError) {\n\t\t\t\tonError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\tvar node = document.getElementById(source);\n\t\t\tif (node) {\n\t\t\t\tonLoad(node);\n\t\t\t} else {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: source,\n\t\t\t\t\tasync: true,\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function() {\n\t\t\t\tonLoad(reader.result);\n\t\t\t};\n\t\t\treader.onerror = function() {\n\t\t\t\tonError(reader.error);\n\t\t\t};\n\t\t\treturn reader.readAsText(source);\n\t\t} else {\n\t\t\tonLoad(source);\n\t\t}\n\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = function() {\n\tvar global = this,\n\t\tacorn = global.acorn;\n\tif (!acorn && \"function\" !== 'undefined') {\n\t\ttry { acorn = __webpack_require__(4); } catch(e) {}\n\t}\n\tif (!acorn) {\n\t\tvar exports, module;\n\t\tacorn = exports = module = {};\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports);\n  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.acorn || (root.acorn = {}));\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.0\";\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\treturn parseTopLevel(options.program);\n  };\n\n  var defaultOptions = exports.defaultOptions = {\n\tecmaVersion: 5,\n\tstrictSemicolons: false,\n\tallowTrailingCommas: true,\n\tforbidReserved: false,\n\tallowReturnOutsideFunction: false,\n\tlocations: false,\n\tonComment: null,\n\tranges: false,\n\tprogram: null,\n\tsourceFile: null,\n\tdirectSourceFile: null\n  };\n\n  function setOptions(opts) {\n\toptions = opts || {};\n\tfor (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n\t  options[opt] = defaultOptions[opt];\n\tsourceFile = options.sourceFile || null;\n  }\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n\tfor (var line = 1, cur = 0;;) {\n\t  lineBreak.lastIndex = cur;\n\t  var match = lineBreak.exec(input);\n\t  if (match && match.index < offset) {\n\t\t++line;\n\t\tcur = match.index + match[0].length;\n\t  } else break;\n\t}\n\treturn {line: line, column: offset - cur};\n  };\n\n  exports.tokenize = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\n\tvar t = {};\n\tfunction getToken(forceRegexp) {\n\t  lastEnd = tokEnd;\n\t  readToken(forceRegexp);\n\t  t.start = tokStart; t.end = tokEnd;\n\t  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n\t  t.type = tokType; t.value = tokVal;\n\t  return t;\n\t}\n\tgetToken.jumpTo = function(pos, reAllowed) {\n\t  tokPos = pos;\n\t  if (options.locations) {\n\t\ttokCurLine = 1;\n\t\ttokLineStart = lineBreak.lastIndex = 0;\n\t\tvar match;\n\t\twhile ((match = lineBreak.exec(input)) && match.index < pos) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = match.index + match[0].length;\n\t\t}\n\t  }\n\t  tokRegexpAllowed = reAllowed;\n\t  skipSpace();\n\t};\n\treturn getToken;\n  };\n\n  var tokPos;\n\n  var tokStart, tokEnd;\n\n  var tokStartLoc, tokEndLoc;\n\n  var tokType, tokVal;\n\n  var tokRegexpAllowed;\n\n  var tokCurLine, tokLineStart;\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  var inFunction, labels, strict;\n\n  function raise(pos, message) {\n\tvar loc = getLineInfo(input, pos);\n\tmessage += \" (\" + loc.line + \":\" + loc.column + \")\";\n\tvar err = new SyntaxError(message);\n\terr.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n\tthrow err;\n  }\n\n  var empty = [];\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n\t\t\t\t\t  \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n\t\t\t\t\t  \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n\t\t\t\t\t  \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n\t\t\t\t\t  \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n\t\t\t\t\t  \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n\t\t\t\t\t  \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n\t\t\t\t\t  \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n\t\t\t\t\t  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n\t\t\t\t\t  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n\t\t\t\t\t  num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  function makePredicate(words) {\n\twords = words.split(\" \");\n\tvar f = \"\", cats = [];\n\tout: for (var i = 0; i < words.length; ++i) {\n\t  for (var j = 0; j < cats.length; ++j)\n\t\tif (cats[j][0].length == words[i].length) {\n\t\t  cats[j].push(words[i]);\n\t\t  continue out;\n\t\t}\n\t  cats.push([words[i]]);\n\t}\n\tfunction compareTo(arr) {\n\t  if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n\t  f += \"switch(str){\";\n\t  for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n\t  f += \"return true}return false;\";\n\t}\n\n\tif (cats.length > 3) {\n\t  cats.sort(function(a, b) {return b.length - a.length;});\n\t  f += \"switch(str.length){\";\n\t  for (var i = 0; i < cats.length; ++i) {\n\t\tvar cat = cats[i];\n\t\tf += \"case \" + cat[0].length + \":\";\n\t\tcompareTo(cat);\n\t  }\n\t  f += \"}\";\n\n\t} else {\n\t  compareTo(words);\n\t}\n\treturn new Function(\"str\", f);\n  }\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n\tif (code < 65) return code === 36;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n\tif (code < 48) return code === 36;\n\tif (code < 58) return true;\n\tif (code < 65) return false;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  function line_loc_t() {\n\tthis.line = tokCurLine;\n\tthis.column = tokPos - tokLineStart;\n  }\n\n  function initTokenState() {\n\ttokCurLine = 1;\n\ttokPos = tokLineStart = 0;\n\ttokRegexpAllowed = true;\n\tskipSpace();\n  }\n\n  function finishToken(type, val) {\n\ttokEnd = tokPos;\n\tif (options.locations) tokEndLoc = new line_loc_t;\n\ttokType = type;\n\tskipSpace();\n\ttokVal = val;\n\ttokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n\tif (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n\ttokPos = end + 2;\n\tif (options.locations) {\n\t  lineBreak.lastIndex = start;\n\t  var match;\n\t  while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n\t\t++tokCurLine;\n\t\ttokLineStart = match.index + match[0].length;\n\t  }\n\t}\n\tif (options.onComment)\n\t  options.onComment(true, input.slice(start + 2, end), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n\tvar start = tokPos;\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar ch = input.charCodeAt(tokPos+=2);\n\twhile (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n\t  ++tokPos;\n\t  ch = input.charCodeAt(tokPos);\n\t}\n\tif (options.onComment)\n\t  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipSpace() {\n\twhile (tokPos < inputLen) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === 32) {\n\t\t++tokPos;\n\t  } else if (ch === 13) {\n\t\t++tokPos;\n\t\tvar next = input.charCodeAt(tokPos);\n\t\tif (next === 10) {\n\t\t  ++tokPos;\n\t\t}\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch === 10 || ch === 8232 || ch === 8233) {\n\t\t++tokPos;\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch > 8 && ch < 14) {\n\t\t++tokPos;\n\t  } else if (ch === 47) {\n\t\tvar next = input.charCodeAt(tokPos + 1);\n\t\tif (next === 42) {\n\t\t  skipBlockComment();\n\t\t} else if (next === 47) {\n\t\t  skipLineComment();\n\t\t} else break;\n\t  } else if (ch === 160) {\n\t\t++tokPos;\n\t  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t\t++tokPos;\n\t  } else {\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  function readToken_dot() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next >= 48 && next <= 57) return readNumber(true);\n\t++tokPos;\n\treturn finishToken(_dot);\n  }\n\n  function readToken_slash() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (tokRegexpAllowed) {++tokPos; return readRegexp();}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) {\n\t  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n\t\t  newline.test(input.slice(lastEnd, tokPos))) {\n\t\ttokPos += 3;\n\t\tskipLineComment();\n\t\tskipSpace();\n\t\treturn readToken();\n\t  }\n\t  return finishOp(_incDec, 2);\n\t}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tvar size = 1;\n\tif (next === code) {\n\t  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n\t  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n\t  return finishOp(_bitShift, size);\n\t}\n\tif (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n\t\tinput.charCodeAt(tokPos + 3) == 45) {\n\t  tokPos += 4;\n\t  skipLineComment();\n\t  skipSpace();\n\t  return readToken();\n\t}\n\tif (next === 61)\n\t  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n\treturn finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n\treturn finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n\tswitch(code) {\n\tcase 46:\n\t  return readToken_dot();\n\n\tcase 40: ++tokPos; return finishToken(_parenL);\n\tcase 41: ++tokPos; return finishToken(_parenR);\n\tcase 59: ++tokPos; return finishToken(_semi);\n\tcase 44: ++tokPos; return finishToken(_comma);\n\tcase 91: ++tokPos; return finishToken(_bracketL);\n\tcase 93: ++tokPos; return finishToken(_bracketR);\n\tcase 123: ++tokPos; return finishToken(_braceL);\n\tcase 125: ++tokPos; return finishToken(_braceR);\n\tcase 58: ++tokPos; return finishToken(_colon);\n\tcase 63: ++tokPos; return finishToken(_question);\n\n\tcase 48:\n\t  var next = input.charCodeAt(tokPos + 1);\n\t  if (next === 120 || next === 88) return readHexNumber();\n\tcase 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:\n\t  return readNumber(false);\n\n\tcase 34: case 39:\n\t  return readString(code);\n\n\tcase 47:\n\t  return readToken_slash(code);\n\n\tcase 37: case 42:\n\t  return readToken_mult_modulo();\n\n\tcase 124: case 38:\n\t  return readToken_pipe_amp(code);\n\n\tcase 94:\n\t  return readToken_caret();\n\n\tcase 43: case 45:\n\t  return readToken_plus_min(code);\n\n\tcase 60: case 62:\n\t  return readToken_lt_gt(code);\n\n\tcase 61: case 33:\n\t  return readToken_eq_excl(code);\n\n\tcase 126:\n\t  return finishOp(_prefix, 1);\n\t}\n\n\treturn false;\n  }\n\n  function readToken(forceRegexp) {\n\tif (!forceRegexp) tokStart = tokPos;\n\telse tokPos = tokStart + 1;\n\tif (options.locations) tokStartLoc = new line_loc_t;\n\tif (forceRegexp) return readRegexp();\n\tif (tokPos >= inputLen) return finishToken(_eof);\n\n\tvar code = input.charCodeAt(tokPos);\n\tif (isIdentifierStart(code) || code === 92 ) return readWord();\n\n\tvar tok = getTokenFromCode(code);\n\n\tif (tok === false) {\n\t  var ch = String.fromCharCode(code);\n\t  if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n\t  raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n\t}\n\treturn tok;\n  }\n\n  function finishOp(type, size) {\n\tvar str = input.slice(tokPos, tokPos + size);\n\ttokPos += size;\n\tfinishToken(type, str);\n  }\n\n  function readRegexp() {\n\tvar content = \"\", escaped, inClass, start = tokPos;\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n\t  var ch = input.charAt(tokPos);\n\t  if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n\t  if (!escaped) {\n\t\tif (ch === \"[\") inClass = true;\n\t\telse if (ch === \"]\" && inClass) inClass = false;\n\t\telse if (ch === \"/\" && !inClass) break;\n\t\tescaped = ch === \"\\\\\";\n\t  } else escaped = false;\n\t  ++tokPos;\n\t}\n\tvar content = input.slice(start, tokPos);\n\t++tokPos;\n\tvar mods = readWord1();\n\tif (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n\ttry {\n\t  var value = new RegExp(content, mods);\n\t} catch (e) {\n\t  if (e instanceof SyntaxError) raise(start, e.message);\n\t  raise(e);\n\t}\n\treturn finishToken(_regexp, value);\n  }\n\n  function readInt(radix, len) {\n\tvar start = tokPos, total = 0;\n\tfor (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t  var code = input.charCodeAt(tokPos), val;\n\t  if (code >= 97) val = code - 97 + 10;\n\t  else if (code >= 65) val = code - 65 + 10;\n\t  else if (code >= 48 && code <= 57) val = code - 48;\n\t  else val = Infinity;\n\t  if (val >= radix) break;\n\t  ++tokPos;\n\t  total = total * radix + val;\n\t}\n\tif (tokPos === start || len != null && tokPos - start !== len) return null;\n\n\treturn total;\n  }\n\n  function readHexNumber() {\n\ttokPos += 2;\n\tvar val = readInt(16);\n\tif (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\treturn finishToken(_num, val);\n  }\n\n  function readNumber(startsWithDot) {\n\tvar start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n\tif (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n\tif (input.charCodeAt(tokPos) === 46) {\n\t  ++tokPos;\n\t  readInt(10);\n\t  isFloat = true;\n\t}\n\tvar next = input.charCodeAt(tokPos);\n\tif (next === 69 || next === 101) {\n\t  next = input.charCodeAt(++tokPos);\n\t  if (next === 43 || next === 45) ++tokPos;\n\t  if (readInt(10) === null) raise(start, \"Invalid number\");\n\t  isFloat = true;\n\t}\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n\tvar str = input.slice(start, tokPos), val;\n\tif (isFloat) val = parseFloat(str);\n\telse if (!octal || str.length === 1) val = parseInt(str, 10);\n\telse if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n\telse val = parseInt(str, 8);\n\treturn finishToken(_num, val);\n  }\n\n  function readString(quote) {\n\ttokPos++;\n\tvar out = \"\";\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === quote) {\n\t\t++tokPos;\n\t\treturn finishToken(_string, out);\n\t  }\n\t  if (ch === 92) {\n\t\tch = input.charCodeAt(++tokPos);\n\t\tvar octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n\t\tif (octal) octal = octal[0];\n\t\twhile (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n\t\tif (octal === \"0\") octal = null;\n\t\t++tokPos;\n\t\tif (octal) {\n\t\t  if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n\t\t  out += String.fromCharCode(parseInt(octal, 8));\n\t\t  tokPos += octal.length - 1;\n\t\t} else {\n\t\t  switch (ch) {\n\t\t  case 110: out += \"\\n\"; break;\n\t\t  case 114: out += \"\\r\"; break;\n\t\t  case 120: out += String.fromCharCode(readHexChar(2)); break;\n\t\t  case 117: out += String.fromCharCode(readHexChar(4)); break;\n\t\t  case 85: out += String.fromCharCode(readHexChar(8)); break;\n\t\t  case 116: out += \"\\t\"; break;\n\t\t  case 98: out += \"\\b\"; break;\n\t\t  case 118: out += \"\\u000b\"; break;\n\t\t  case 102: out += \"\\f\"; break;\n\t\t  case 48: out += \"\\0\"; break;\n\t\t  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;\n\t\t  case 10:\n\t\t\tif (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n\t\t\tbreak;\n\t\t  default: out += String.fromCharCode(ch); break;\n\t\t  }\n\t\t}\n\t  } else {\n\t\tif (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n\t\tout += String.fromCharCode(ch);\n\t\t++tokPos;\n\t  }\n\t}\n  }\n\n  function readHexChar(len) {\n\tvar n = readInt(16, len);\n\tif (n === null) raise(tokStart, \"Bad character escape sequence\");\n\treturn n;\n  }\n\n  var containsEsc;\n\n  function readWord1() {\n\tcontainsEsc = false;\n\tvar word, first = true, start = tokPos;\n\tfor (;;) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (isIdentifierChar(ch)) {\n\t\tif (containsEsc) word += input.charAt(tokPos);\n\t\t++tokPos;\n\t  } else if (ch === 92) {\n\t\tif (!containsEsc) word = input.slice(start, tokPos);\n\t\tcontainsEsc = true;\n\t\tif (input.charCodeAt(++tokPos) != 117)\n\t\t  raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n\t\t++tokPos;\n\t\tvar esc = readHexChar(4);\n\t\tvar escStr = String.fromCharCode(esc);\n\t\tif (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n\t\tif (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n\t\t  raise(tokPos - 4, \"Invalid Unicode escape\");\n\t\tword += escStr;\n\t  } else {\n\t\tbreak;\n\t  }\n\t  first = false;\n\t}\n\treturn containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  function readWord() {\n\tvar word = readWord1();\n\tvar type = _name;\n\tif (!containsEsc && isKeyword(word))\n\t  type = keywordTypes[word];\n\treturn finishToken(type, word);\n  }\n\n  function next() {\n\tlastStart = tokStart;\n\tlastEnd = tokEnd;\n\tlastEndLoc = tokEndLoc;\n\treadToken();\n  }\n\n  function setStrict(strct) {\n\tstrict = strct;\n\ttokPos = tokStart;\n\tif (options.locations) {\n\t  while (tokPos < tokLineStart) {\n\t\ttokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n\t\t--tokCurLine;\n\t  }\n\t}\n\tskipSpace();\n\treadToken();\n  }\n\n  function node_t() {\n\tthis.type = null;\n\tthis.start = tokStart;\n\tthis.end = null;\n  }\n\n  function node_loc_t() {\n\tthis.start = tokStartLoc;\n\tthis.end = null;\n\tif (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n\tvar node = new node_t();\n\tif (options.locations)\n\t  node.loc = new node_loc_t();\n\tif (options.directSourceFile)\n\t  node.sourceFile = options.directSourceFile;\n\tif (options.ranges)\n\t  node.range = [tokStart, 0];\n\treturn node;\n  }\n\n  function startNodeFrom(other) {\n\tvar node = new node_t();\n\tnode.start = other.start;\n\tif (options.locations) {\n\t  node.loc = new node_loc_t();\n\t  node.loc.start = other.loc.start;\n\t}\n\tif (options.ranges)\n\t  node.range = [other.range[0], 0];\n\n\treturn node;\n  }\n\n  function finishNode(node, type) {\n\tnode.type = type;\n\tnode.end = lastEnd;\n\tif (options.locations)\n\t  node.loc.end = lastEndLoc;\n\tif (options.ranges)\n\t  node.range[1] = lastEnd;\n\treturn node;\n  }\n\n  function isUseStrict(stmt) {\n\treturn options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n\t  stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  function eat(type) {\n\tif (tokType === type) {\n\t  next();\n\t  return true;\n\t}\n  }\n\n  function canInsertSemicolon() {\n\treturn !options.strictSemicolons &&\n\t  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  function semicolon() {\n\tif (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  function expect(type) {\n\tif (tokType === type) next();\n\telse unexpected();\n  }\n\n  function unexpected() {\n\traise(tokStart, \"Unexpected token\");\n  }\n\n  function checkLVal(expr) {\n\tif (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n\t  raise(expr.start, \"Assigning to rvalue\");\n\tif (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n\t  raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  function parseTopLevel(program) {\n\tlastStart = lastEnd = tokPos;\n\tif (options.locations) lastEndLoc = new line_loc_t;\n\tinFunction = strict = null;\n\tlabels = [];\n\treadToken();\n\n\tvar node = program || startNode(), first = true;\n\tif (!program) node.body = [];\n\twhile (tokType !== _eof) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && isUseStrict(stmt)) setStrict(true);\n\t  first = false;\n\t}\n\treturn finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  function parseStatement() {\n\tif (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n\t  readToken(true);\n\n\tvar starttype = tokType, node = startNode();\n\n\tswitch (starttype) {\n\tcase _break: case _continue:\n\t  next();\n\t  var isBreak = starttype === _break;\n\t  if (eat(_semi) || canInsertSemicolon()) node.label = null;\n\t  else if (tokType !== _name) unexpected();\n\t  else {\n\t\tnode.label = parseIdent();\n\t\tsemicolon();\n\t  }\n\n\t  for (var i = 0; i < labels.length; ++i) {\n\t\tvar lab = labels[i];\n\t\tif (node.label == null || lab.name === node.label.name) {\n\t\t  if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n\t\t  if (node.label && isBreak) break;\n\t\t}\n\t  }\n\t  if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n\t  return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n\tcase _debugger:\n\t  next();\n\t  semicolon();\n\t  return finishNode(node, \"DebuggerStatement\");\n\n\tcase _do:\n\t  next();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  expect(_while);\n\t  node.test = parseParenExpression();\n\t  semicolon();\n\t  return finishNode(node, \"DoWhileStatement\");\n\n\tcase _for:\n\t  next();\n\t  labels.push(loopLabel);\n\t  expect(_parenL);\n\t  if (tokType === _semi) return parseFor(node, null);\n\t  if (tokType === _var) {\n\t\tvar init = startNode();\n\t\tnext();\n\t\tparseVar(init, true);\n\t\tfinishNode(init, \"VariableDeclaration\");\n\t\tif (init.declarations.length === 1 && eat(_in))\n\t\t  return parseForIn(node, init);\n\t\treturn parseFor(node, init);\n\t  }\n\t  var init = parseExpression(false, true);\n\t  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n\t  return parseFor(node, init);\n\n\tcase _function:\n\t  next();\n\t  return parseFunction(node, true);\n\n\tcase _if:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  node.consequent = parseStatement();\n\t  node.alternate = eat(_else) ? parseStatement() : null;\n\t  return finishNode(node, \"IfStatement\");\n\n\tcase _return:\n\t  if (!inFunction && !options.allowReturnOutsideFunction)\n\t\traise(tokStart, \"'return' outside of function\");\n\t  next();\n\n\t  if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n\t  else { node.argument = parseExpression(); semicolon(); }\n\t  return finishNode(node, \"ReturnStatement\");\n\n\tcase _switch:\n\t  next();\n\t  node.discriminant = parseParenExpression();\n\t  node.cases = [];\n\t  expect(_braceL);\n\t  labels.push(switchLabel);\n\n\t  for (var cur, sawDefault; tokType != _braceR;) {\n\t\tif (tokType === _case || tokType === _default) {\n\t\t  var isCase = tokType === _case;\n\t\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t\t  node.cases.push(cur = startNode());\n\t\t  cur.consequent = [];\n\t\t  next();\n\t\t  if (isCase) cur.test = parseExpression();\n\t\t  else {\n\t\t\tif (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n\t\t\tcur.test = null;\n\t\t  }\n\t\t  expect(_colon);\n\t\t} else {\n\t\t  if (!cur) unexpected();\n\t\t  cur.consequent.push(parseStatement());\n\t\t}\n\t  }\n\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t  next();\n\t  labels.pop();\n\t  return finishNode(node, \"SwitchStatement\");\n\n\tcase _throw:\n\t  next();\n\t  if (newline.test(input.slice(lastEnd, tokStart)))\n\t\traise(lastEnd, \"Illegal newline after throw\");\n\t  node.argument = parseExpression();\n\t  semicolon();\n\t  return finishNode(node, \"ThrowStatement\");\n\n\tcase _try:\n\t  next();\n\t  node.block = parseBlock();\n\t  node.handler = null;\n\t  if (tokType === _catch) {\n\t\tvar clause = startNode();\n\t\tnext();\n\t\texpect(_parenL);\n\t\tclause.param = parseIdent();\n\t\tif (strict && isStrictBadIdWord(clause.param.name))\n\t\t  raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n\t\texpect(_parenR);\n\t\tclause.guard = null;\n\t\tclause.body = parseBlock();\n\t\tnode.handler = finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.guardedHandlers = empty;\n\t  node.finalizer = eat(_finally) ? parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t\traise(node.start, \"Missing catch or finally clause\");\n\t  return finishNode(node, \"TryStatement\");\n\n\tcase _var:\n\t  next();\n\t  parseVar(node);\n\t  semicolon();\n\t  return finishNode(node, \"VariableDeclaration\");\n\n\tcase _while:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  return finishNode(node, \"WhileStatement\");\n\n\tcase _with:\n\t  if (strict) raise(tokStart, \"'with' in strict mode\");\n\t  next();\n\t  node.object = parseParenExpression();\n\t  node.body = parseStatement();\n\t  return finishNode(node, \"WithStatement\");\n\n\tcase _braceL:\n\t  return parseBlock();\n\n\tcase _semi:\n\t  next();\n\t  return finishNode(node, \"EmptyStatement\");\n\n\tdefault:\n\t  var maybeName = tokVal, expr = parseExpression();\n\t  if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n\t\tfor (var i = 0; i < labels.length; ++i)\n\t\t  if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t\tvar kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n\t\tlabels.push({name: maybeName, kind: kind});\n\t\tnode.body = parseStatement();\n\t\tlabels.pop();\n\t\tnode.label = expr;\n\t\treturn finishNode(node, \"LabeledStatement\");\n\t  } else {\n\t\tnode.expression = expr;\n\t\tsemicolon();\n\t\treturn finishNode(node, \"ExpressionStatement\");\n\t  }\n\t}\n  }\n\n  function parseParenExpression() {\n\texpect(_parenL);\n\tvar val = parseExpression();\n\texpect(_parenR);\n\treturn val;\n  }\n\n  function parseBlock(allowStrict) {\n\tvar node = startNode(), first = true, strict = false, oldStrict;\n\tnode.body = [];\n\texpect(_braceL);\n\twhile (!eat(_braceR)) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && allowStrict && isUseStrict(stmt)) {\n\t\toldStrict = strict;\n\t\tsetStrict(strict = true);\n\t  }\n\t  first = false;\n\t}\n\tif (strict && !oldStrict) setStrict(false);\n\treturn finishNode(node, \"BlockStatement\");\n  }\n\n  function parseFor(node, init) {\n\tnode.init = init;\n\texpect(_semi);\n\tnode.test = tokType === _semi ? null : parseExpression();\n\texpect(_semi);\n\tnode.update = tokType === _parenR ? null : parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForStatement\");\n  }\n\n  function parseForIn(node, init) {\n\tnode.left = init;\n\tnode.right = parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForInStatement\");\n  }\n\n  function parseVar(node, noIn) {\n\tnode.declarations = [];\n\tnode.kind = \"var\";\n\tfor (;;) {\n\t  var decl = startNode();\n\t  decl.id = parseIdent();\n\t  if (strict && isStrictBadIdWord(decl.id.name))\n\t\traise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n\t  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n\t  node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n\t  if (!eat(_comma)) break;\n\t}\n\treturn node;\n  }\n\n  function parseExpression(noComma, noIn) {\n\tvar expr = parseMaybeAssign(noIn);\n\tif (!noComma && tokType === _comma) {\n\t  var node = startNodeFrom(expr);\n\t  node.expressions = [expr];\n\t  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n\t  return finishNode(node, \"SequenceExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseMaybeAssign(noIn) {\n\tvar left = parseMaybeConditional(noIn);\n\tif (tokType.isAssign) {\n\t  var node = startNodeFrom(left);\n\t  node.operator = tokVal;\n\t  node.left = left;\n\t  next();\n\t  node.right = parseMaybeAssign(noIn);\n\t  checkLVal(left);\n\t  return finishNode(node, \"AssignmentExpression\");\n\t}\n\treturn left;\n  }\n\n  function parseMaybeConditional(noIn) {\n\tvar expr = parseExprOps(noIn);\n\tif (eat(_question)) {\n\t  var node = startNodeFrom(expr);\n\t  node.test = expr;\n\t  node.consequent = parseExpression(true);\n\t  expect(_colon);\n\t  node.alternate = parseExpression(true, noIn);\n\t  return finishNode(node, \"ConditionalExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprOps(noIn) {\n\treturn parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  function parseExprOp(left, minPrec, noIn) {\n\tvar prec = tokType.binop;\n\tif (prec != null && (!noIn || tokType !== _in)) {\n\t  if (prec > minPrec) {\n\t\tvar node = startNodeFrom(left);\n\t\tnode.left = left;\n\t\tnode.operator = tokVal;\n\t\tvar op = tokType;\n\t\tnext();\n\t\tnode.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n\t\tvar exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n\t\treturn parseExprOp(exprNode, minPrec, noIn);\n\t  }\n\t}\n\treturn left;\n  }\n\n  function parseMaybeUnary() {\n\tif (tokType.prefix) {\n\t  var node = startNode(), update = tokType.isUpdate;\n\t  node.operator = tokVal;\n\t  node.prefix = true;\n\t  tokRegexpAllowed = true;\n\t  next();\n\t  node.argument = parseMaybeUnary();\n\t  if (update) checkLVal(node.argument);\n\t  else if (strict && node.operator === \"delete\" &&\n\t\t\t   node.argument.type === \"Identifier\")\n\t\traise(node.start, \"Deleting local variable in strict mode\");\n\t  return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t}\n\tvar expr = parseExprSubscripts();\n\twhile (tokType.postfix && !canInsertSemicolon()) {\n\t  var node = startNodeFrom(expr);\n\t  node.operator = tokVal;\n\t  node.prefix = false;\n\t  node.argument = expr;\n\t  checkLVal(expr);\n\t  next();\n\t  expr = finishNode(node, \"UpdateExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprSubscripts() {\n\treturn parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n\tif (eat(_dot)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseIdent(true);\n\t  node.computed = false;\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (eat(_bracketL)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseExpression();\n\t  node.computed = true;\n\t  expect(_bracketR);\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (!noCalls && eat(_parenL)) {\n\t  var node = startNodeFrom(base);\n\t  node.callee = base;\n\t  node.arguments = parseExprList(_parenR, false);\n\t  return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n\t} else return base;\n  }\n\n  function parseExprAtom() {\n\tswitch (tokType) {\n\tcase _this:\n\t  var node = startNode();\n\t  next();\n\t  return finishNode(node, \"ThisExpression\");\n\tcase _name:\n\t  return parseIdent();\n\tcase _num: case _string: case _regexp:\n\t  var node = startNode();\n\t  node.value = tokVal;\n\t  node.raw = input.slice(tokStart, tokEnd);\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _null: case _true: case _false:\n\t  var node = startNode();\n\t  node.value = tokType.atomValue;\n\t  node.raw = tokType.keyword;\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _parenL:\n\t  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n\t  next();\n\t  var val = parseExpression();\n\t  val.start = tokStart1;\n\t  val.end = tokEnd;\n\t  if (options.locations) {\n\t\tval.loc.start = tokStartLoc1;\n\t\tval.loc.end = tokEndLoc;\n\t  }\n\t  if (options.ranges)\n\t\tval.range = [tokStart1, tokEnd];\n\t  expect(_parenR);\n\t  return val;\n\n\tcase _bracketL:\n\t  var node = startNode();\n\t  next();\n\t  node.elements = parseExprList(_bracketR, true, true);\n\t  return finishNode(node, \"ArrayExpression\");\n\n\tcase _braceL:\n\t  return parseObj();\n\n\tcase _function:\n\t  var node = startNode();\n\t  next();\n\t  return parseFunction(node, false);\n\n\tcase _new:\n\t  return parseNew();\n\n\tdefault:\n\t  unexpected();\n\t}\n  }\n\n  function parseNew() {\n\tvar node = startNode();\n\tnext();\n\tnode.callee = parseSubscripts(parseExprAtom(), true);\n\tif (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n\telse node.arguments = empty;\n\treturn finishNode(node, \"NewExpression\");\n  }\n\n  function parseObj() {\n\tvar node = startNode(), first = true, sawGetSet = false;\n\tnode.properties = [];\n\tnext();\n\twhile (!eat(_braceR)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (options.allowTrailingCommas && eat(_braceR)) break;\n\t  } else first = false;\n\n\t  var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n\t  if (eat(_colon)) {\n\t\tprop.value = parseExpression(true);\n\t\tkind = prop.kind = \"init\";\n\t  } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n\t\t\t\t (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n\t\tisGetSet = sawGetSet = true;\n\t\tkind = prop.kind = prop.key.name;\n\t\tprop.key = parsePropertyName();\n\t\tif (tokType !== _parenL) unexpected();\n\t\tprop.value = parseFunction(startNode(), false);\n\t  } else unexpected();\n\n\t  if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n\t\tfor (var i = 0; i < node.properties.length; ++i) {\n\t\t  var other = node.properties[i];\n\t\t  if (other.key.name === prop.key.name) {\n\t\t\tvar conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n\t\t\t  kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n\t\t\tif (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n\t\t\tif (conflict) raise(prop.key.start, \"Redefinition of property\");\n\t\t  }\n\t\t}\n\t  }\n\t  node.properties.push(prop);\n\t}\n\treturn finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n\tif (tokType === _num || tokType === _string) return parseExprAtom();\n\treturn parseIdent(true);\n  }\n\n  function parseFunction(node, isStatement) {\n\tif (tokType === _name) node.id = parseIdent();\n\telse if (isStatement) unexpected();\n\telse node.id = null;\n\tnode.params = [];\n\tvar first = true;\n\texpect(_parenL);\n\twhile (!eat(_parenR)) {\n\t  if (!first) expect(_comma); else first = false;\n\t  node.params.push(parseIdent());\n\t}\n\n\tvar oldInFunc = inFunction, oldLabels = labels;\n\tinFunction = true; labels = [];\n\tnode.body = parseBlock(true);\n\tinFunction = oldInFunc; labels = oldLabels;\n\n\tif (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n\t  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n\t\tvar id = i < 0 ? node.id : node.params[i];\n\t\tif (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n\t\t  raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n\t\tif (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n\t\t  raise(id.start, \"Argument name clash in strict mode\");\n\t  }\n\t}\n\n\treturn finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n\tvar elts = [], first = true;\n\twhile (!eat(close)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n\t  } else first = false;\n\n\t  if (allowEmpty && tokType === _comma) elts.push(null);\n\t  else elts.push(parseExpression(true));\n\t}\n\treturn elts;\n  }\n\n  function parseIdent(liberal) {\n\tvar node = startNode();\n\tif (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n\tif (tokType === _name) {\n\t  if (!liberal &&\n\t\t  (options.forbidReserved &&\n\t\t   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||\n\t\t   strict && isStrictReservedWord(tokVal)) &&\n\t\t  input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n\t\traise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n\t  node.name = tokVal;\n\t} else if (liberal && tokType.keyword) {\n\t  node.name = tokType.keyword;\n\t} else {\n\t  unexpected();\n\t}\n\ttokRegexpAllowed = false;\n\tnext();\n\treturn finishNode(node, \"Identifier\");\n  }\n\n});\n\n\t\tif (!acorn.version)\n\t\t\tacorn = null;\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn (global.acorn || acorn).parse(code, options);\n\t}\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': '__equals',\n\t\t'!=': '__equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': '__self'\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{\n\t\t\t__self: function() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction compile(code, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction walkAST(node, parent) {\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tfor (var key in node) {\n\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar value = node[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\twalkAST(value, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\t\texp = left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')';\n\t\t\t\t\t\t\treplaceCode(node, /^\\(.*\\)$/.test(getCode(node))\n\t\t\t\t\t\t\t\t\t? '(' + exp + ')' : exp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction encodeVLQ(value) {\n\t\t\tvar res = '',\n\t\t\t\tbase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\tvalue = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n\t\t\twhile (value || !res) {\n\t\t\t\tvar next = value & (32 - 1);\n\t\t\t\tvalue >>= 5;\n\t\t\t\tif (value)\n\t\t\t\t\tnext |= 32;\n\t\t\t\tres += base64[next];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar url = options.url || '',\n\t\t\tagent = paper.agent,\n\t\t\tversion = agent.versionNumber,\n\t\t\toffsetCode = false,\n\t\t\tsourceMaps = options.sourceMaps,\n\t\t\tsource = options.source || code,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg,\n\t\t\toffset = options.offset || 0,\n\t\t\tmap;\n\t\tif (sourceMaps && (agent.chrome && version >= 30\n\t\t\t\t|| agent.webkit && version >= 537.76\n\t\t\t\t|| agent.firefox && version >= 23\n\t\t\t\t|| agent.node)) {\n\t\t\tif (agent.node) {\n\t\t\t\toffset -= 2;\n\t\t\t} else if (window && url && !window.location.href.indexOf(url)) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\toffsetCode = offset > 0 && !(\n\t\t\t\t\tagent.chrome && version >= 36 ||\n\t\t\t\t\tagent.safari && version >= 600 ||\n\t\t\t\t\tagent.firefox && version >= 40 ||\n\t\t\t\t\tagent.node);\n\t\t\tvar mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1\n\t\t\t\t\t+ (offsetCode ? offset : 0);\n\t\t\tmap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url],\n\t\t\t\tsourcesContent: [source]\n\t\t\t};\n\t\t}\n\t\twalkAST(parse(code, { ranges: true, preserveParens: true }));\n\t\tif (map) {\n\t\t\tif (offsetCode) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code;\n\t\t\t}\n\t\t\tif (/^(inline|both)$/.test(sourceMaps)) {\n\t\t\t\tcode += \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ self.btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(map))));\n\t\t\t}\n\t\t\tcode += \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn {\n\t\t\turl: url,\n\t\t\tsource: source,\n\t\t\tcode: code,\n\t\t\tmap: map\n\t\t};\n\t}\n\n\tfunction execute(code, scope, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/\n\t\t\t\t\t.test(code) && !/\\bnew\\s+Tool\\b/.test(code)\n\t\t\t\t\t\t? new Tool() : null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc,\n\t\t\tcompiled = typeof code === 'object' ? code : compile(code, options);\n\t\tcode = compiled.code;\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\thandlers = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t}\n\t\t}, []).join(', ');\n\t\tif (handlers)\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\tvar agent = paper.agent;\n\t\tif (document && (agent.chrome\n\t\t\t\t|| agent.firefox && agent.versionNumber < 40)) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (agent.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = paper._execute;\n\t\t\tdelete paper._execute;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar res = func.apply(scope, args) || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = res[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (res.onResize)\n\t\t\t\tview.setOnResize(res.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (res.onFrame)\n\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\tview.requestUpdate();\n\t\t}\n\t\treturn compiled;\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: src,\n\t\t\t\t\tasync: async,\n\t\t\t\t\tmimeType: 'text/plain',\n\t\t\t\t\tonLoad: function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document && document.getElementsByTagName('script'),\n\t\t\t\tloadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (window) {\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse\n\t};\n\n}.call(this);\n\npaper = new (PaperScope.inject(Base.exports, {\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key,\n\tDomEvent: DomEvent,\n\tDomElement: DomElement,\n\tdocument: document,\n\twindow: window,\n\tSymbol: SymbolDefinition,\n\tPlacedSymbol: SymbolItem\n}))();\n\nif (paper.agent.node) {\n\t__webpack_require__(24)(paper);\n}\n\nif (true) {\n\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else if (typeof module === 'object' && module) {\n\tmodule.exports = paper;\n}\n\nreturn paper;\n}.call(this, typeof self === 'object' ? self : null);\n\n\n/***/ }),\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n/* 26 */,\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n\n/***/ })\n],[27]);\n\n\n// WEBPACK FOOTER //\n// js/app.patterns.js","import { domReady } from './utilities/helpers';\nimport { confetti, background } from './modules/patterns';\n\nconst app = {\n\n  init() {\n    confetti('#pattern-cover');\n    background('#pattern-reference', 'cyan');\n    background('#pattern-availability', 'yellow');\n    background('#pattern-resume', 'purple');\n  }\n\n};\n\ndomReady(app.init);\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.patterns.js","// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType == \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^']|\\.)*)'|\"((?:[^\"]|\\.)*)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) == \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(types.name)\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;\n  if (!andThrow) { return pos >= 0 }\n  if (pos > -1) { this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != \"let\") { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!this.isKeyword(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind != \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) { return this.parseFor(node, null) }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      { return this.parseForIn(node, init$1) }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init);\n    this.checkLVal(init);\n    this.checkPatternErrors(refDestructuringErrors, true);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.isFunction = function() {\n  return this.type === types._function || this.isAsyncFunction()\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction());\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type != types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    this.expect(types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.enterLexicalScope();\n    this.checkLVal(clause.param, \"let\");\n    this.expect(types.parenR);\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart == node.start) {\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type == types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (this$1.eat(types.semi)) { continue }\n    var method = this$1.startNode();\n    var isGenerator = this$1.eat(types.star);\n    var isAsync = false;\n    var isMaybeStatic = this$1.type === types.name && this$1.value === \"static\";\n    this$1.parsePropertyName(method);\n    method.static = isMaybeStatic && this$1.type !== types.parenL;\n    if (method.static) {\n      if (isGenerator) { this$1.unexpected(); }\n      isGenerator = this$1.eat(types.star);\n      this$1.parsePropertyName(method);\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== types.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true;\n      this$1.parsePropertyName(method);\n    }\n    method.kind = \"method\";\n    var isGetSet = false;\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== types.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true;\n        method.kind = key.name;\n        key = this$1.parsePropertyName(method);\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) { this$1.raise(key.start, \"Duplicate constructor in the same class\"); }\n        if (isGetSet) { this$1.raise(key.start, \"Constructor can't have get/set modifier\"); }\n        if (isGenerator) { this$1.raise(key.start, \"Constructor can't be a generator\"); }\n        if (isAsync) { this$1.raise(key.start, \"Constructor can't be an async method\"); }\n        method.kind = \"constructor\";\n        hadConstructor = true;\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync);\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1;\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start;\n        if (method.kind === \"get\")\n          { this$1.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this$1.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          { this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type == \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type == \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop.value);\n      } }\n  else if (type == \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type == \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type == \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      if (prop.kind !== \"init\") { this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\"); }\n        this$1.toAssignable(prop.value, isBinding);\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type == \"RestElement\") {\n      --end;\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding);\n      --end;\n    }\n\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) { return this.parseIdent() }\n  switch (this.type) {\n  case types.name:\n    return this.parseIdent()\n\n  case types.bracketL:\n    var node = this.startNode();\n    this.next();\n    node.elements = this.parseBindingList(types.bracketR, true, true);\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case types.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop.value, bindingType, checkClashes);\n  }\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type == types.parenL || this.type == types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left) : left;\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors);\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon();\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n\n  case types._this:\n    var type = this.type === types._this ? \"ThisExpression\" : \"Super\";\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, type)\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        if (this$1.type === types.parenL && !innerParenStart) {\n          innerParenStart = this$1.start;\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (innerParenStart) { this.unexpected(innerParenStart); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), startPos = (void 0), startLoc = (void 0);\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start;\n        startLoc = this$1.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this$1.eat(types.star); }\n    }\n    this$1.parsePropertyName(prop);\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && this$1.isAsyncProp(prop)) {\n      isAsync = true;\n      this$1.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);\n    this$1.checkPropClash(prop, propHash);\n    node.properties.push(this$1.finishNode(prop, \"Property\"));\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != types.comma && this.type != types.braceR)) {\n    if (isGenerator || isAsync || isPattern) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") != -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name))\n    { this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\")); }\n};\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved == \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType == types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)\n    { return true }\n  if (prevType == types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType == types._var || prevType == types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType == types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType == types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6) {\n    if (this.value == \"of\" && !this.exprAllowed ||\n        this.value == \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\";\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) { this.unexpected(); }\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) { parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message); }\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\");\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var content = this.input.slice(start, this.pos);\n  ++this.pos;\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1();\n  var tmp = content, tmpFlags = \"\";\n  if (mods) {\n    var validFlags = /^[gim]*$/;\n    if (this.options.ecmaVersion >= 6) { validFlags = /^[gimuy]*$/; }\n    if (!validFlags.test(mods)) { this.raise(start, \"Invalid regular expression flag\"); }\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\";\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code);\n          if (code > 0x10FFFF) { this$1.raise(start + offset + 3, \"Code point out of bounds\"); }\n          return \"x\"\n        });\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n        tmpFlags = tmpFlags.replace(\"u\", \"\");\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null;\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this);\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods);\n  }\n  return this.finishToken(types.regexp, {pattern: content, flags: mods, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  if (octal && this.pos == start + 1) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    isFloat = true;\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    isFloat = true;\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos), val;\n  if (isFloat) { val = parseFloat(str); }\n  else if (!octal || str.length === 1) { val = parseInt(str, 10); }\n  else if (this.strict) { this.raise(start, \"Invalid number\"); }\n  else if (/[89]/.test(str)) { val = parseInt(str, 10); }\n  else { val = parseInt(str, 8); }\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.invalidStringToken(this.pos - 2, \"Octal literal in strict mode\");\n      }\n      this.pos += octalStr.length - 1;\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.1.1\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\nexport { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/acorn/dist/acorn.es.js\n// module id = 4\n// module chunks = 1","import paper from 'paper';\nimport { randNumber } from '../../utilities/helpers';\nimport settings from '../../utilities/settings';\n\nwindow.papers = {};\n\nfunction confetti(selector = '') {\n  const pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers[`${pattern.id}`] = new paper.PaperScope();\n  const paperObj = window.papers[`${pattern.id}`];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', () => {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function randColor() {\n      const selectedColor = settings.colors[randNumber(0, settings.colors.length)];\n      return selectedColor.value;\n    }\n\n    function randPosition() {\n      return [\n        randNumber(1, paperObj.view.bounds.width),\n        randNumber(1, paperObj.view.bounds.height)\n      ];\n    }\n\n    function randPositionX() {\n      return Math.round(paperObj.Point.random().x * paperObj.view.size.width);\n    }\n\n    const density = 0.02;\n    const quantity = Math.round((area() / 100) * density);\n    const items = (quantity <= 200) ? quantity : 200;\n    const shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: randColor()\n    });\n\n    for (let i = 0; i < items; i++) {\n      const copy = shape.clone();\n\n      copy.size = [randNumber(20, 30), 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.fillColor = randColor();\n      copy.blendMode = 'multiply';\n      copy.rotate(randNumber(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale((i / items) * randNumber(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n    paperObj.view.update();\n    const children = paperObj.project.activeLayer.children;\n\n    paperObj.view.onFrame = function () {\n      for (let i = 0; i < items; i++) {\n        const item = children[i];\n        const rotationDirection = (i % 2) ? +1 : -1;\n\n        item.rotate(rotationDirection);\n        item.position.y += (item.bounds.width / (item.bounds.width * 2));\n\n        if (item.bounds.top > paperObj.view.size.height) {\n          item.position.y = -item.bounds.width;\n          item.position.x = randPositionX();\n        }\n      }\n    };\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nfunction background(selector = '', color = 'white') {\n  const pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers[`${pattern.id}`] = new paper.PaperScope();\n  const paperObj = window.papers[`${pattern.id}`];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', () => {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function selectColor(name) {\n      const selected = settings.colors.find(item => item.name === name);\n      return (selected) ? selected.value : name;\n    }\n\n    function randPosition() {\n      return [\n        randNumber(1, paperObj.view.bounds.width),\n        randNumber(1, paperObj.view.bounds.height)\n      ];\n    }\n\n    const density = 0.02;\n    const quantity = Math.round((area() / 100) * density);\n    const items = (quantity <= 200) ? quantity : 200;\n    const shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: selectColor(color)\n    });\n\n    for (let i = 0; i < items; i++) {\n      const copy = shape.clone();\n\n      copy.size = [30, 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.rotate(randNumber(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale((i / items) * randNumber(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nexport { confetti, background };\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/patterns/index.js","const settings = {\n  speed: 500,\n  easing: 'easeInOutExpo',\n  colors: [\n    { name: 'red', value: '#DF6C74' },\n    { name: 'green', value: '#99C46D' },\n    { name: 'yellow', value: '#ecce79' },\n    { name: 'blue', value: '#63ADF5' },\n    { name: 'cyan', value: '#59B6C4' },\n    { name: 'orange', value: '#D09B5C' },\n    { name: 'purple', value: '#C575E4' },\n    { name: 'slate', value: '#5F697F' }\n  ]\n};\n\nexport default settings;\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/utilities/settings.js","/*!\n * Paper.js v0.11.4 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Wed Jun 7 16:56:44 2017 +0200\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2016 Juerg Lehni\n * http://scratchdisk.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * http://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = function(self, undefined) {\n\nself = self || require('./node/self.js');\nvar window = self.window,\n\tdocument = self.document;\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\tarray = [],\n\t\tslice = array.slice,\n\t\tcreate = Object.create,\n\t\tdescribe = Object.getOwnPropertyDescriptor,\n\t\tdefine = Object.defineProperty,\n\n\t\tforEach = array.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this) {\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tset = Object.assign || function(dst) {\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tfor (var key in src) {\n\t\t\t\t\tif (src.hasOwnProperty(key))\n\t\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\n\t\teach = function(obj, iter, bind) {\n\t\t\tif (obj) {\n\t\t\t\tvar desc = describe(obj, 'length');\n\t\t\t\t(desc && typeof desc.value === 'number' ? forEach : forIn)\n\t\t\t\t\t.call(obj, iter, bind = bind || obj);\n\t\t\t}\n\t\t\treturn bind;\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res)) {\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t}\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable != null ? enumerable : !bean;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tvar src = arguments[i];\n\t\t\tif (src)\n\t\t\t\tset(this, src);\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn inject(Base, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, null, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, obj, l = arguments.length;\n\t\t\t\t\ti < l && !(ctor && proto); i++) {\n\t\t\t\tobj = arguments[i];\n\t\t\t\tctor = ctor || obj.initialize;\n\t\t\t\tproto = proto || obj.prototype;\n\t\t\t}\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = proto || create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}).inject({\n\t\tenumerable: false,\n\n\t\tinitialize: Base,\n\n\t\tset: Base,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src) {\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\tset: set,\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t},\n\n\t\t\tslice: function(list, begin, end) {\n\t\t\t\treturn slice.call(list, begin, end);\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (typeof module !== 'undefined')\n\tmodule.exports = Base;\n\nBase.inject({\n\tenumerable: false,\n\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\timportJSON: function(json) {\n\t\treturn Base.importJSON(json, this);\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\tset: function(props, exclude) {\n\t\tif (props)\n\t\t\tBase.filter(this, props, exclude, this._prioritize);\n\t\treturn this;\n\t}\n}, {\n\nbeans: false,\nstatics: {\n\texports: {},\n\n\textend: function extend() {\n\t\tvar res = extend.base.apply(this, arguments),\n\t\t\tname = res.prototype._class;\n\t\tif (name && !Base.exports[name])\n\t\t\tBase.exports[name] = res;\n\t\treturn res;\n\t},\n\n\tequals: function(obj1, obj2) {\n\t\tif (obj1 === obj2)\n\t\t\treturn true;\n\t\tif (obj1 && obj1.equals)\n\t\t\treturn obj1.equals(obj2);\n\t\tif (obj2 && obj2.equals)\n\t\t\treturn obj2.equals(obj1);\n\t\tif (obj1 && obj2\n\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\tvar length = obj1.length;\n\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\tlength = keys.length;\n\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tread: function(list, start, options, amount) {\n\t\tif (this === Base) {\n\t\t\tvar value = this.peek(list, start);\n\t\t\tlist.__index++;\n\t\t\treturn value;\n\t\t}\n\t\tvar proto = this.prototype,\n\t\t\treadIndex = proto._readIndex,\n\t\t\tbegin = start || readIndex && list.__index || 0,\n\t\t\tlength = list.length,\n\t\t\tobj = list[begin];\n\t\tamount = amount || length - begin;\n\t\tif (obj instanceof this\n\t\t\t|| options && options.readNull && obj == null && amount <= 1) {\n\t\t\tif (readIndex)\n\t\t\t\tlist.__index = begin + 1;\n\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t}\n\t\tobj = Base.create(proto);\n\t\tif (readIndex)\n\t\t\tobj.__read = true;\n\t\tobj = obj.initialize.apply(obj, begin > 0 || begin + amount < length\n\t\t\t\t? Base.slice(list, begin, begin + amount)\n\t\t\t\t: list) || obj;\n\t\tif (readIndex) {\n\t\t\tlist.__index = begin + obj.__read;\n\t\t\tvar filtered = obj.__filtered;\n\t\t\tif (filtered) {\n\t\t\t\tlist.__filtered = filtered;\n\t\t\t\tobj.__filtered = undefined;\n\t\t\t}\n\t\t\tobj.__read = undefined;\n\t\t}\n\t\treturn obj;\n\t},\n\n\tpeek: function(list, start) {\n\t\treturn list[list.__index = start || list.__index || 0];\n\t},\n\n\tremain: function(list) {\n\t\treturn list.length - (list.__index || 0);\n\t},\n\n\treadList: function(list, start, options, amount) {\n\t\tvar res = [],\n\t\t\tentry,\n\t\t\tbegin = start || 0,\n\t\t\tend = amount ? begin + amount : list.length;\n\t\tfor (var i = begin; i < end; i++) {\n\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t}\n\t\treturn res;\n\t},\n\n\treadNamed: function(list, name, start, options, amount) {\n\t\tvar value = this.getNamed(list, name),\n\t\t\thasObject = value !== undefined;\n\t\tif (hasObject) {\n\t\t\tvar filtered = list.__filtered;\n\t\t\tif (!filtered) {\n\t\t\t\tfiltered = list.__filtered = Base.create(list[0]);\n\t\t\t\tfiltered.__unfiltered = list[0];\n\t\t\t}\n\t\t\tfiltered[name] = undefined;\n\t\t}\n\t\tvar l = hasObject ? [value] : list,\n\t\t\tres = this.read(l, start, options, amount);\n\t\treturn res;\n\t},\n\n\tgetNamed: function(list, name) {\n\t\tvar arg = list[0];\n\t\tif (list._hasObject === undefined)\n\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\tif (list._hasObject)\n\t\t\treturn name ? arg[name] : list.__filtered || arg;\n\t},\n\n\thasNamed: function(list, name) {\n\t\treturn !!this.getNamed(list, name);\n\t},\n\n\tfilter: function(dest, source, exclude, prioritize) {\n\t\tvar processed;\n\n\t\tfunction handleKey(key) {\n\t\t\tif (!(exclude && key in exclude) &&\n\t\t\t\t!(processed && key in processed)) {\n\t\t\t\tvar value = source[key];\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\tdest[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tif (prioritize) {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0, key, l = prioritize.length; i < l; i++) {\n\t\t\t\tif ((key = prioritize[i]) in source) {\n\t\t\t\t\thandleKey(key);\n\t\t\t\t\tkeys[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed = keys;\n\t\t}\n\n\t\tObject.keys(source.__unfiltered || source).forEach(handleKey);\n\t\treturn dest;\n\t},\n\n\tisPlainValue: function(obj, asString) {\n\t\treturn Base.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t|| asString && typeof obj === 'string';\n\t},\n\n\tserialize: function(obj, options, compact, dictionary) {\n\t\toptions = options || {};\n\n\t\tvar isRoot = !dictionary,\n\t\t\tres;\n\t\tif (isRoot) {\n\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\tdictionary = {\n\t\t\t\tlength: 0,\n\t\t\t\tdefinitions: {},\n\t\t\t\treferences: {},\n\t\t\t\tadd: function(item, create) {\n\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t}\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (obj && obj._serialize) {\n\t\t\tres = obj._serialize(options, dictionary);\n\t\t\tvar name = obj._class;\n\t\t\tif (name && !obj._compactSerialize && (isRoot || !compact)\n\t\t\t\t\t&& res[0] !== name) {\n\t\t\t\tres.unshift(name);\n\t\t\t}\n\t\t} else if (Array.isArray(obj)) {\n\t\t\tres = [];\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\tres[i] = Base.serialize(obj[i], options, compact, dictionary);\n\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\tres = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\tdictionary);\n\t\t\t}\n\t\t} else if (typeof obj === 'number') {\n\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t} else {\n\t\t\tres = obj;\n\t\t}\n\t\treturn isRoot && dictionary.length > 0\n\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t: res;\n\t},\n\n\tdeserialize: function(json, create, _data, _setDictionary, _isRoot) {\n\t\tvar res = json,\n\t\t\tisFirst = !_data,\n\t\t\thasDictionary = isFirst && json && json.length\n\t\t\t\t&& json[0][0] === 'dictionary';\n\t\t_data = _data || {};\n\t\tif (Array.isArray(json)) {\n\t\t\tvar type = json[0],\n\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\tif (json.length == 1 && /^#/.test(type)) {\n\t\t\t\treturn _data.dictionary[type];\n\t\t\t}\n\t\t\ttype = Base.exports[type];\n\t\t\tres = [];\n\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++) {\n\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\tisDictionary, hasDictionary));\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tvar args = res;\n\t\t\t\tif (create) {\n\t\t\t\t\tres = create(type, args, isFirst || _isRoot);\n\t\t\t\t} else {\n\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Base.isPlainObject(json)) {\n\t\t\tres = {};\n\t\t\tif (_setDictionary)\n\t\t\t\t_data.dictionary = res;\n\t\t\tfor (var key in json)\n\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t}\n\t\treturn hasDictionary ? res[1] : res;\n\t},\n\n\texportJSON: function(obj, options) {\n\t\tvar json = Base.serialize(obj, options);\n\t\treturn options && options.asString == false\n\t\t\t\t? json\n\t\t\t\t: JSON.stringify(json);\n\t},\n\n\timportJSON: function(json, target) {\n\t\treturn Base.deserialize(\n\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\tfunction(ctor, args, isRoot) {\n\t\t\t\t\tvar useTarget = isRoot && target\n\t\t\t\t\t\t\t&& target.constructor === ctor,\n\t\t\t\t\t\tobj = useTarget ? target\n\t\t\t\t\t\t\t: Base.create(ctor.prototype);\n\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t&& (useTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t}\n\t\t\t\t\t(useTarget ? obj.set : ctor).apply(obj, args);\n\t\t\t\t\tif (useTarget)\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\treturn obj;\n\t\t\t\t});\n\t},\n\n\tsplice: function(list, items, index, remove) {\n\t\tvar amount = items && items.length,\n\t\t\tappend = index === undefined;\n\t\tindex = append ? list.length : index;\n\t\tif (index > list.length)\n\t\t\tindex = list.length;\n\t\tfor (var i = 0; i < amount; i++)\n\t\t\titems[i]._index = index + i;\n\t\tif (append) {\n\t\t\tlist.push.apply(list, items);\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar args = [index, remove];\n\t\t\tif (items)\n\t\t\t\targs.push.apply(args, items);\n\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\tremoved[i]._index = undefined;\n\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\tlist[i]._index = i;\n\t\t\treturn removed;\n\t\t}\n\t},\n\n\tcapitalize: function(str) {\n\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t},\n\n\tcamelize: function(str) {\n\t\treturn str.replace(/-(.)/g, function(match, chr) {\n\t\t\treturn chr.toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(str) {\n\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t}\n}});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, func);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = Base.slice(arguments, 1),\n\t\t\tsetTarget = event && event.target && !event.currentTarget;\n\t\thandlers = handlers.slice();\n\t\tif (setTarget)\n\t\t\tevent.currentTarget = this;\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) == false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t   }\n\t\t}\n\t\tif (setTarget)\n\t\t\tdelete event.currentTarget;\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar types = this._eventTypes,\n\t\t\thandlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tif (types) {\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar entry = types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\tinsertItems: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1) || {};\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\t\tif (!this.agent) {\n\t\t\tvar user = self.navigator.userAgent.toLowerCase(),\n\t\t\t\tos = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],\n\t\t\t\tplatform = os === 'darwin' ? 'mac' : os,\n\t\t\t\tagent = proto.agent = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tagent[platform] = true;\n\t\t\tuser.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g,\n\t\t\t\tfunction(match, n, v1, v2, rv) {\n\t\t\t\t\tif (!agent.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 :\n\t\t\t\t\t\t\t\t/^(node|trident)$/.test(n) ? rv : v1;\n\t\t\t\t\t\tagent.version = v;\n\t\t\t\t\t\tagent.versionNumber = parseFloat(v);\n\t\t\t\t\t\tn = n === 'trident' ? 'msie' : n;\n\t\t\t\t\t\tagent.name = n;\n\t\t\t\t\t\tagent[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (agent.chrome)\n\t\t\t\tdelete agent.webkit;\n\t\t\tif (agent.atom)\n\t\t\t\tdelete agent.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.11.4\",\n\n\tgetView: function() {\n\t\tvar project = this.project;\n\t\treturn project && project._view;\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, options) {\n\t\tpaper.PaperScript.execute(code, this, options);\n\t\tView.updateFocus();\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tcreateCanvas: function(width, height) {\n\t\treturn CanvasProvider.getCanvas(width, height);\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tvar projects = this.projects,\n\t\t\ttools = this.tools;\n\t\tfor (var i = projects.length - 1; i >= 0; i--)\n\t\t\tprojects[i].remove();\n\t\tfor (var i = tools.length - 1; i >= 0; i--)\n\t\t\ttools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._scope.getView();\n\t}\n});\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = Base.pick(precision, 5);\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn this.precision < 16\n\t\t\t\t? Math.round(val * this.multiplier) / this.multiplier : val;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tlog2 = Math.log2 || function(x) {\n\t\t\treturn Math.log(x) * Math.LOG2E;\n\t\t},\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clamp(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\tfunction getDiscriminant(a, b, c) {\n\t\tfunction split(v) {\n\t\t\tvar x = v * 134217729,\n\t\t\t\ty = v - x,\n\t\t\t\thi = y + x,\n\t\t\t\tlo = v - hi;\n\t\t\treturn [hi, lo];\n\t\t}\n\n\t\tvar D = b * b - a * c,\n\t\t\tE = b * b + a * c;\n\t\tif (abs(D) * 3 < E) {\n\t\t\tvar ad = split(a),\n\t\t\t\tbd = split(b),\n\t\t\t\tcd = split(c),\n\t\t\t\tp = b * b,\n\t\t\t\tdp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],\n\t\t\t\tq = a * c,\n\t\t\t\tdq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])\n\t\t\t\t\t\t+ ad[1] * cd[1];\n\t\t\tD = (p - q) + (dp - dq);\n\t\t}\n\t\treturn D;\n\t}\n\n\tfunction getNormalizationFactor() {\n\t\tvar norm = Math.max.apply(Math, arguments);\n\t\treturn norm && (norm < 1e-8 || norm > 1e8)\n\t\t\t\t? pow(2, -Math.round(log2(norm)))\n\t\t\t\t: 0;\n\t}\n\n\treturn {\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 1e-8,\n\t\tGEOMETRIC_EPSILON: 1e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-8,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tclamp: clamp,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance) {\n\t\t\t\t\tx = nx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clamp(x, a, b);\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar x1, x2 = Infinity;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(b) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / b;\n\t\t\t} else {\n\t\t\t\tb *= -0.5;\n\t\t\t\tvar D = getDiscriminant(a, b, c);\n\t\t\t\tif (D && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c));\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\ta *= f;\n\t\t\t\t\t\tb *= f;\n\t\t\t\t\t\tc *= f;\n\t\t\t\t\t\tD = getDiscriminant(a, b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0,\n\t\t\t\tboundless = min == null,\n\t\t\t\tminB = min - EPSILON,\n\t\t\t\tmaxB = max + EPSILON;\n\t\t\tif (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))\n\t\t\t\troots[count++] = boundless ? x1 : clamp(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))\n\t\t\t\troots[count++] = boundless ? x2 : clamp(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),\n\t\t\t\tx, b1, c2, qd, q;\n\t\t\tif (f) {\n\t\t\t\ta *= f;\n\t\t\t\tb *= f;\n\t\t\t\tc *= f;\n\t\t\t\td *= f;\n\t\t\t}\n\n\t\t\tfunction evaluate(x0) {\n\t\t\t\tx = x0;\n\t\t\t\tvar tmp = a * x;\n\t\t\t\tb1 = tmp + b;\n\t\t\t\tc2 = b1 * x + c;\n\t\t\t\tqd = (tmp + b1) * x + c2;\n\t\t\t\tq = c2 * x + d;\n\t\t\t}\n\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tevaluate(-(b / a) / 3);\n\t\t\t\tvar t = q / a,\n\t\t\t\t\tr = pow(abs(t), 1/3),\n\t\t\t\t\ts = t < 0 ? -1 : 1,\n\t\t\t\t\ttd = -qd / a,\n\t\t\t\t\trd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,\n\t\t\t\t\tx0 = x - s * rd;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tevaluate(x0);\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),\n\t\t\t\tboundless = min == null;\n\t\t\tif (isFinite(x) && (count === 0\n\t\t\t\t\t|| count > 0 && x !== roots[0] && x !== roots[1])\n\t\t\t\t\t&& (boundless || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = boundless ? x : clamp(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(name) {\n\t\tif (name) {\n\t\t\tvar pool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasY ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('angle' in obj) {\n\t\t\t\tthis._set(obj.length || 0, 0);\n\t\t\t\tthis.setAngle(obj.angle || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis._set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(arguments);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\ttolerance = Base.read(arguments);\n\t\treturn this.getDistance(point) <= tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.x) && isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tisInQuadrant: function(q) {\n\t\treturn this.x * (q > 1 && q < 4 ? -1 : 1) >= 0\n\t\t\t&& this.y * (q > 2 ? -1 : 1) >= 0;\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\treturn this._setter === 'setPosition' ? 4 : 0;\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasHeight ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.width) && isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar type = typeof arg0,\n\t\t\tread;\n\t\tif (type === 'number') {\n\t\t\tthis._set(arg0, arg1, arg2, arg3);\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0, 0, 0);\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis._set.apply(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis._set(arg0.x || 0, arg0.y || 0,\n\t\t\t\t\t\targ0.width || 0, arg0.height || 0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis._set(0, 0, 0, 0);\n\t\t\t\tBase.filter(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t}\n\t\t}\n\t\tif (read === undefined) {\n\t\t\tvar frm = Point.readNamed(arguments, 'from'),\n\t\t\t\tnext = Base.peek(arguments),\n\t\t\t\tx = frm.x,\n\t\t\t\ty = frm.y,\n\t\t\t\twidth,\n\t\t\t\theight;\n\t\t\tif (next && next.x !== undefined\n\t\t\t\t\t|| Base.hasNamed(arguments, 'to')) {\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\twidth = to.x - x;\n\t\t\t\theight = to.y - y;\n\t\t\t\tif (width < 0) {\n\t\t\t\t\tx = to.x;\n\t\t\t\t\twidth = -width;\n\t\t\t\t}\n\t\t\t\tif (height < 0) {\n\t\t\t\t\ty = to.y;\n\t\t\t\t\theight = -height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\twidth = size.width;\n\t\t\t\theight = size.height;\n\t\t\t}\n\t\t\tthis._set(x, y, width, height);\n\t\t\tread = arguments.__index;\n\t\t\tvar filtered = arguments.__filtered;\n\t\t\tif (filtered)\n\t\t\t\tthis.__filtered = filtered;\n\t\t}\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\t_fw: 1,\n\t_fh: 1,\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tsx = this._sx,\n\t\t\tsy = this._sy,\n\t\t\tw = size.width,\n\t\t\th = size.height;\n\t\tif (sx) {\n\t\t\tthis.x += (this.width - w) * sx;\n\t\t}\n\t\tif (sy) {\n\t\t\tthis.y += (this.height - h) * sy;\n\t\t}\n\t\tthis.width = w;\n\t\tthis.height = h;\n\t\tthis._fw = this._fh = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = left - this.x;\n\t\t\tthis.width -= this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = left;\n\t\tthis._sx = this._fw = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = top - this.y;\n\t\t\tthis.height -= this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = top;\n\t\tthis._sy = this._fh = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = right - this.x;\n\t\t\tthis.width = this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = right - this.width;\n\t\tthis._sx = 1;\n\t\tthis._fw = 0;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = bottom - this.y;\n\t\t\tthis.height = this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = bottom - this.height;\n\t\tthis._sy = 1;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width / 2;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tif (this._fw || this._sx === 0.5) {\n\t\t\tthis.x = x - this.width / 2;\n\t\t} else {\n\t\t\tif (this._sx) {\n\t\t\t\tthis.x += (x - this.x) * 2 * this._sx;\n\t\t\t}\n\t\t\tthis.width = (x - this.x) * 2;\n\t\t}\n\t\tthis._sx = 0.5;\n\t\tthis._fw = 0;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height / 2;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tif (this._fh || this._sy === 0.5) {\n\t\t\tthis.y = y - this.height / 2;\n\t\t} else {\n\t\t\tif (this._sy) {\n\t\t\t\tthis.y += (y - this.y) * 2 * this._sy;\n\t\t\t}\n\t\t\tthis.height = (y - this.y) * 2;\n\t\t}\n\t\tthis._sy = 0.5;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length === 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tepsilon = Base.read(arguments) || 0;\n\t\treturn rect.x + rect.width > this.x - epsilon\n\t\t\t\t&& rect.y + rect.height > this.y - epsilon\n\t\t\t\t&& rect.x < this.x + this.width + epsilon\n\t\t\t\t&& rect.y < this.y + this.height + epsilon;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join(''),\n\t\t\txFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis._set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tinternal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn !!(this._owner._selection & 2);\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner._changeSelection) {\n\t\t\t\t\towner._changeSelection(2, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg, _dontNotify) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count >= 6) {\n\t\t\tthis._set.apply(this, arguments);\n\t\t} else if (count === 1 || count === 2) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,\n\t\t\t\t\t\t_dontNotify);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis._set.apply(this,\n\t\t\t\t\t\t_dontNotify ? arg.concat([_dontNotify]) : arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (!count) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok) {\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t}\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(a, b, c, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._b = b;\n\t\tthis._c = c;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.getValues(), options, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(9);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._c),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._b), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._b = this._c = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t_setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._c;\n\t\tthis._ty += x * this._b + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar scale = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._b *= scale.x;\n\t\tthis._c *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * c;\n\t\tthis._b = cos * b + sin * d;\n\t\tthis._c = -sin * a + cos * c;\n\t\tthis._d = -sin * b + cos * d;\n\t\tthis._tx += tx * a + ty * c;\n\t\tthis._ty += tx * b + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar shear = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tb = this._b;\n\t\tthis._a += shear.y * this._c;\n\t\tthis._b += shear.y * this._d;\n\t\tthis._c += shear.x * a;\n\t\tthis._d += shear.x * b;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar skew = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tappend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * c1;\n\t\t\tthis._c = b2 * a1 + d2 * c1;\n\t\t\tthis._b = a2 * b1 + c2 * d1;\n\t\t\tthis._d = b2 * b1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * c1;\n\t\t\tthis._ty += tx2 * b1 + ty2 * d1;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tprepend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * b1;\n\t\t\tthis._c = a2 * c1 + b2 * d1;\n\t\t\tthis._b = c2 * a1 + d2 * b1;\n\t\t\tthis._d = c2 * c1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tappended: function(mx) {\n\t\treturn this.clone().append(mx);\n\t},\n\n\tprepended: function(mx) {\n\t\treturn this.clone().prepend(mx);\n\t},\n\n\tinvert: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tthis._a = d / det;\n\t\t\tthis._b = -b / det;\n\t\t\tthis._c = -c / det;\n\t\t\tthis._d = a / det;\n\t\t\tthis._tx = (c * ty - d * tx) / det;\n\t\t\tthis._ty = (b * tx - a * ty) / det;\n\t\t\tres = this;\n\t\t}\n\t\treturn res;\n\t},\n\n\tinverted: function() {\n\t\treturn this.clone().invert();\n\t},\n\n\tconcatenate: '#append',\n\tpreConcatenate: '#prepend',\n\tchain: '#appended',\n\n\t_shiftless: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n\t},\n\n\t_orNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\tisInvertible: function() {\n\t\tvar det = this._a * this._d - this._c * this._b;\n\t\treturn det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n\t},\n\n\tisSingular: function() {\n\t\treturn !this.isInvertible();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest._set(\n\t\t\t\tx * this._a + y * this._c + this._tx,\n\t\t\t\tx * this._b + y * this._d + this._ty,\n\t\t\t\t_dontNotify);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tfor (var i = 0, max = 2 * count; i < max; i += 2) {\n\t\t\tvar x = src[i],\n\t\t\t\ty = src[i + 1];\n\t\t\tdst[i] = x * this._a + y * this._c + this._tx;\n\t\t\tdst[i + 1] = x * this._b + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j]) {\n\t\t\t\tmin[j] = val;\n\t\t\t} else if (val > max[j]) {\n\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\tres = dest._set(\n\t\t\t\t\t(x * d - y * c) / det,\n\t\t\t\t\t(y * a - x * b) / det,\n\t\t\t\t\t_dontNotify);\n\t\t}\n\t\treturn res;\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\tdet = a * d - b * c,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tatan2 = Math.atan2,\n\t\t\tdegrees = 180 / Math.PI,\n\t\t\trotate,\n\t\t\tscale,\n\t\t\tskew;\n\t\tif (a !== 0 || b !== 0) {\n\t\t\tvar r = sqrt(a * a + b * b);\n\t\t\trotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n\t\t\tscale = [r, det / r];\n\t\t\tskew = [atan2(a * c + b * d, r * r), 0];\n\t\t} else if (c !== 0 || d !== 0) {\n\t\t\tvar s = sqrt(c * c + d * d);\n\t\t\trotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);\n\t\t\tscale = [det / s, s];\n\t\t\tskew = [0, atan2(a * c + b * d, s * s)];\n\t\t} else {\n\t\t\trotate = 0;\n\t\t\tskew = scale = [0, 0];\n\t\t}\n\t\treturn {\n\t\t\ttranslation: this.getTranslation(),\n\t\t\trotation: rotate * degrees,\n\t\t\tscaling: new Point(scale),\n\t\t\tskewing: new Point(skew[0] * degrees, skew[1] * degrees)\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._b, this._c, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn (this.decompose() || {}).scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn (this.decompose() || {}).rotation;\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tif (!this.isIdentity()) {\n\t\t\tctx.transform(this._a, this._b, this._c, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t}\n\t}\n}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {\n\tvar part = Base.capitalize(key),\n\t\tprop = '_' + key;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(this.getSignedDistance(point));\n\t},\n\n\tgetSignedDistance: function(point) {\n\t\treturn Line.getSignedDistance(this._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true);\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (!isInfinite && Numerical.isZero(ccw)) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t},\n\n\t\tgetDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\treturn Math.abs(\n\t\t\t\t\tLine.getSignedDistance(px, py, vx, vy, x, y, asVector));\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\t_compactSerialize: true,\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis._activeLayer = null;\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectionItems = {};\n\t\tthis._selectionCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this._children, options, true, dictionary);\n\t},\n\n\t_changed: function(flags, item) {\n\t\tif (flags & 1) {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview._needsUpdate = true;\n\t\t\t\tif (!view._requested && view._autoUpdate)\n\t\t\t\t\tview.requestUpdate();\n\t\t\t}\n\t\t}\n\t\tvar changes = this._changes;\n\t\tif (changes && item) {\n\t\t\tvar changesById = this._changesById,\n\t\t\t\tid = item._id,\n\t\t\t\tentry = changesById[id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tchanges.push(changesById[id] = { item: item, flags: flags });\n\t\t\t}\n\t\t}\n\t},\n\n\tclear: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--)\n\t\t\tchildren[i].remove();\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children.length;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.set(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetLayers: function() {\n\t\treturn this._children;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this, insert: true });\n\t},\n\n\tgetSymbolDefinitions: function() {\n\t\tvar definitions = [],\n\t\t\tids = {};\n\t\tthis.getItems({\n\t\t\tclass: SymbolItem,\n\t\t\tmatch: function(item) {\n\t\t\t\tvar definition = item._definition,\n\t\t\t\t\tid = definition._id;\n\t\t\t\tif (!ids[id]) {\n\t\t\t\t\tids[id] = true;\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn definitions;\n\t},\n\n\tgetSymbols: 'getSymbolDefinitions',\n\n\tgetSelectedItems: function() {\n\t\tvar selectionItems = this._selectionItems,\n\t\t\titems = [];\n\t\tfor (var id in selectionItems) {\n\t\t\tvar item = selectionItems[id],\n\t\t\t\tselection = item._selection;\n\t\t\tif ((selection & 1) && item.isInserted()) {\n\t\t\t\titems.push(item);\n\t\t\t} else if (!selection) {\n\t\t\t\tthis._updateSelection(item);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectionItems = this._selectionItems;\n\t\tif (item._selection) {\n\t\t\tif (selectionItems[id] !== item) {\n\t\t\t\tthis._selectionCount++;\n\t\t\t\tselectionItems[id] = item;\n\t\t\t}\n\t\t} else if (selectionItems[id] === item) {\n\t\t\tthis._selectionCount--;\n\t\t\tdelete selectionItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectionItems = this._selectionItems;\n\t\tfor (var i in selectionItems)\n\t\t\tselectionItems[i].setFullySelected(false);\n\t},\n\n\taddLayer: function(layer) {\n\t\treturn this.insertLayer(undefined, layer);\n\t},\n\n\tinsertLayer: function(index, layer) {\n\t\tif (layer instanceof Layer) {\n\t\t\tlayer._remove(false, true);\n\t\t\tBase.splice(this._children, [layer], index, 0);\n\t\t\tlayer._setProject(this, true);\n\t\t\tvar name = layer._name;\n\t\t\tif (name)\n\t\t\t\tlayer.setName(name);\n\t\t\tif (this._changes)\n\t\t\t\tlayer._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = layer;\n\t\t} else {\n\t\t\tlayer = null;\n\t\t}\n\t\treturn layer;\n\t},\n\n\t_insertItem: function(index, item, _created) {\n\t\titem = this.insertLayer(index, item)\n\t\t\t\t|| (this._activeLayer || this._insertItem(undefined,\n\t\t\t\t\t\tnew Layer(Item.NO_INSERT), true))\n\t\t\t\t\t\t.insertChild(index, item);\n\t\tif (_created && item.activate)\n\t\t\titem.activate();\n\t\treturn item;\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tremoveOn: function(type) {\n\t\tvar sets = this._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar children = this._children,\n\t\t\tparam = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].draw(ctx, param);\n\t\t}\n\t\tctx.restore();\n\n\t\tif (this._selectionCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectionItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items) {\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = Base.set({},\n\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_name: null,\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_canScaleStroke: false,\n\t_pivot: null,\n\t_visible: true,\n\t_blendMode: 'normal',\n\t_opacity: 1,\n\t_locked: false,\n\t_guide: false,\n\t_clipMask: false,\n\t_selection: 0,\n\t_selectBounds: true,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tlocked: false,\n\t\tguide: false,\n\t\tclipMask: false,\n\t\tselected: false,\n\t\tdata: {}\n\t},\n\t_prioritize: ['applyMatrix']\n},\nnew function() {\n\tvar handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];\n\treturn Base.each(handlers,\n\t\tfunction(name) {\n\t\t\tthis._events[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, 1);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, -1);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\t_events: {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tonLoad: {},\n\t\t\t\tonError: {}\n\t\t\t},\n\t\t\tstatics: {\n\t\t\t\t_itemHandlers: handlers\n\t\t\t}\n\t\t}\n\t);\n}, {\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project,\n\t\t\tsettings = paper.settings;\n\t\tthis._id = internal ? null : UID.get();\n\t\tthis._parent = this._index = null;\n\t\tthis._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (internal || hasProps && props.insert == false\n\t\t\t|| !settings.insertItems && !(hasProps && props.insert === true)) {\n\t\t\tthis._setProject(project);\n\t\t} else {\n\t\t\t(hasProps && props.parent || project)\n\t\t\t\t\t._insertItem(undefined, this, true);\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT) {\n\t\t\tthis.set(props, {\n\t\t\t\tinternal: true, insert: true, project: true, parent: true\n\t\t\t});\n\t\t}\n\t\treturn hasProps;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._symbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\tthis._globalMatrix = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 40)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project)\n\t\t\tproject._changed(flags, this);\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar owner = this._getOwner();\n\t\tif (name && owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tif (!(name in children))\n\t\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(128);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tkey = '_' + name,\n\t\t\tflags = {\n\t\t\t\tlocked: 128,\n\t\t\t\tvisible: 137\n\t\t\t};\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[key];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[key]) {\n\t\t\t\tthis[key] = value;\n\t\t\t\tthis._changed(flags[name] || 129);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tif (selection !== this._selection) {\n\t\t\tthis._selection = selection;\n\t\t\tvar project = this._project;\n\t\t\tif (project) {\n\t\t\t\tproject._updateSelection(this);\n\t\t\t\tthis._changed(129);\n\t\t\t}\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn !!(this._selection & 1);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisFullySelected: function() {\n\t\tvar children = this._children,\n\t\t\tselected = !!(this._selection & 1);\n\t\tif (children && selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(129);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(1024);\n\t\t}\n\t},\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar position = this._position,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\tif (!position) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tposition = this._position = pivot\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t}\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\tgetPivot: function() {\n\t\tvar pivot = this._pivot;\n\t\treturn pivot\n\t\t\t\t? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')\n\t\t\t\t: null;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t}\n}, Base.each({\n\t\tgetStrokeBounds: { stroke: true },\n\t\tgetHandleBounds: { handle: true },\n\t\tgetInternalBounds: { internal: true }\n\t},\n\tfunction(options, key) {\n\t\tthis[key] = function(matrix) {\n\t\t\treturn this.getBounds(matrix, options);\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\tgetBounds: function(matrix, options) {\n\t\tvar hasMatrix = options || matrix instanceof Matrix,\n\t\t\topts = Base.set({}, hasMatrix ? options : matrix,\n\t\t\t\t\tthis._boundsOptions);\n\t\tif (!opts.stroke || this.getStrokeScaling())\n\t\t\topts.cacheItem = this;\n\t\tvar rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n\t\treturn !arguments.length\n\t\t\t\t? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,\n\t\t\t\t\tthis, 'setBounds')\n\t\t\t\t: rect;\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\t_matrix = this._matrix,\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tif (!_matrix.isInvertible()) {\n\t\t\t\t_matrix.set(_matrix._backup\n\t\t\t\t\t\t|| new Matrix().translate(_matrix.getTranslation()));\n\t\t\t\tbounds = this.getBounds();\n\t\t\t}\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width !== 0 ? rect.width / bounds.width : 0,\n\t\t\t\t\tbounds.height !== 0 ? rect.height / bounds.height : 0);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar children = this._children;\n\t\tif (!children || !children.length)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, options.cacheItem);\n\t\treturn Item._getBounds(children, matrix, options);\n\t},\n\n\t_getBoundsCacheKey: function(options, internal) {\n\t\treturn [\n\t\t\toptions.stroke ? 1 : 0,\n\t\t\toptions.handle ? 1 : 0,\n\t\t\tinternal ? 1 : 0\n\t\t].join('');\n\t},\n\n\t_getCachedBounds: function(matrix, options, noInternal) {\n\t\tmatrix = matrix && matrix._orNullIfIdentity();\n\t\tvar internal = options.internal && !noInternal,\n\t\t\tcacheItem = options.cacheItem,\n\t\t\t_matrix = internal ? null : this._matrix._orNullIfIdentity(),\n\t\t\tcacheKey = cacheItem && (!matrix || matrix.equals(_matrix))\n\t\t\t\t&& this._getBoundsCacheKey(options, internal),\n\t\t\tbounds = this._bounds;\n\t\tItem._updateBoundsCache(this._parent || this._symbol, cacheItem);\n\t\tif (cacheKey && bounds && cacheKey in bounds) {\n\t\t\tvar cached = bounds[cacheKey];\n\t\t\treturn {\n\t\t\t\trect: cached.rect.clone(),\n\t\t\t\tnonscaling: cached.nonscaling\n\t\t\t};\n\t\t}\n\t\tvar res = this._getBounds(matrix || _matrix, options),\n\t\t\trect = res.rect || res,\n\t\t\tstyle = this._style,\n\t\t\tnonscaling = res.nonscaling || style.hasStroke()\n\t\t\t\t&& !style.getStrokeScaling();\n\t\tif (cacheKey) {\n\t\t\tif (!bounds) {\n\t\t\t\tthis._bounds = bounds = {};\n\t\t\t}\n\t\t\tvar cached = bounds[cacheKey] = {\n\t\t\t\trect: rect.clone(),\n\t\t\t\tnonscaling: nonscaling,\n\t\t\t\tinternal: internal\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trect: rect,\n\t\t\tnonscaling: nonscaling\n\t\t};\n\t},\n\n\t_getStrokeMatrix: function(matrix, options) {\n\t\tvar parent = this.getStrokeScaling() ? null\n\t\t\t\t: options && options.internal ? this\n\t\t\t\t\t: this._parent || this._symbol && this._symbol._item,\n\t\t\tmx = parent ? parent.getViewMatrix().invert() : matrix;\n\t\treturn mx && mx._shiftless();\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent && item) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getBounds: function(items, matrix, options) {\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2,\n\t\t\t\tnonscaling = false;\n\t\t\toptions = options || {};\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._visible && !item.isEmpty()) {\n\t\t\t\t\tvar bounds = item._getCachedBounds(\n\t\t\t\t\t\tmatrix && matrix.appended(item._matrix), options, true),\n\t\t\t\t\t\trect = bounds.rect;\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t\tif (bounds.nonscaling)\n\t\t\t\t\t\tnonscaling = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\trect: isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle(),\n\t\t\t\tnonscaling: nonscaling\n\t\t\t};\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._applyMatrix\n\t\t\t? null\n\t\t\t: this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed ? decomposed.rotation : 0;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\ts = decomposed && decomposed.scaling;\n\t\treturn new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling && !current.equals(scaling)) {\n\t\t\tvar rotation = this.getRotation(),\n\t\t\t\tdecomposed = this._decomposed,\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tcenter = this.getPosition(true);\n\t\t\tmatrix.translate(center);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(rotation);\n\t\t\tmatrix.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(-rotation);\n\t\t\tmatrix.translate(center.negate());\n\t\t\tthis.transform(matrix);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix,\n\t\t\tupdateVersion = this._project._updateVersion;\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\tmatrix = null;\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.prepend(parent.getGlobalMatrix(true));\n\t\t\tmatrix._updateVersion = updateVersion;\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetViewMatrix: function() {\n\t\treturn this.getGlobalMatrix().prepend(this.getView()._matrix);\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\t_getOwner: '#getParent',\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(options) {\n\t\tvar copy = new this.constructor(Item.NO_INSERT),\n\t\t\tchildren = this._children,\n\t\t\tinsert = Base.pick(options ? options.insert : undefined,\n\t\t\t\t\toptions === undefined || options === true),\n\t\t\tdeep = Base.pick(options ? options.deep : undefined, true);\n\t\tif (children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (!children || deep)\n\t\t\tcopy.copyContent(this);\n\t\tif (!children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (insert)\n\t\t\tcopy.insertAbove(this);\n\t\tvar name = this._name,\n\t\t\tparent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\tif (name !== orig)\n\t\t\t\tcopy.setName(name);\n\t\t}\n\t\treturn copy;\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar children = source._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tthis.addChild(children[i].clone(false), true);\n\t\t}\n\t},\n\n\tcopyAttributes: function(source, excludeMatrix) {\n\t\tthis.setStyle(source._style);\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (source.hasOwnProperty(key))\n\t\t\t\tthis[key] = source[key];\n\t\t}\n\t\tif (!excludeMatrix)\n\t\t\tthis._matrix.set(source._matrix, true);\n\t\tthis.setApplyMatrix(source._applyMatrix);\n\t\tthis.setPivot(source._pivot);\n\t\tthis.setSelection(source._selection);\n\t\tvar data = source._data,\n\t\t\tname = source._name;\n\t\tthis._data = data ? Base.clone(data) : null;\n\t\tif (name)\n\t\t\tthis.setName(name);\n\t},\n\n\trasterize: function(resolution, insert) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\tif (!size.isZero()) {\n\t\t\tvar canvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t\traster.setCanvas(canvas);\n\t\t}\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t.scale(1 / scale));\n\t\tif (insert === undefined || insert)\n\t\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\treturn !!this._contains(\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t},\n\n\t_contains: function(point) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tif (children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix, true).length > 0;\n\t}\n},\nnew function() {\n\tfunction hitTest() {\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(arguments),\n\t\t\t\tHitResult.getOptions(arguments));\n\t}\n\n\tfunction hitTestAll() {\n\t\tvar point = Point.read(arguments),\n\t\t\toptions = HitResult.getOptions(arguments),\n\t\t\tall = [];\n\t\tthis._hitTest(point, Base.set({ all: all }, options));\n\t\treturn all;\n\t}\n\n\tfunction hitTestChildren(point, options, viewMatrix, _exclude) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar res = child !== _exclude && child._hitTest(point, options,\n\t\t\t\t\t\tviewMatrix);\n\t\t\t\tif (res && !options.all)\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tProject.inject({\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTest: hitTestChildren\n\t});\n\n\treturn {\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTestChildren: hitTestChildren,\n\t};\n}, {\n\n\t_hitTest: function(point, options, parentViewMatrix) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar matrix = this._matrix,\n\t\t\tviewMatrix = parentViewMatrix\n\t\t\t\t\t? parentViewMatrix.appended(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().prepend(this.getView()._matrix),\n\t\t\ttolerance = Math.max(options.tolerance, 1e-12),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\tPath._getStrokePadding(tolerance,\n\t\t\t\t\t\tmatrix._shiftless().invert()));\n\t\tpoint = matrix._inverseTransform(point);\n\t\tif (!point || !this._children &&\n\t\t\t!this.getBounds({ internal: true, stroke: true, handle: true })\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this.isSelected()\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tmatch = options.match,\n\t\t\tthat = this,\n\t\t\tbounds,\n\t\t\tres;\n\n\t\tfunction filter(hit) {\n\t\t\tif (hit && match && !match(hit))\n\t\t\t\thit = null;\n\t\t\tif (hit && options.all)\n\t\t\t\toptions.all.push(hit);\n\t\t\treturn hit;\n\t\t}\n\n\t\tfunction checkPoint(type, part) {\n\t\t\tvar pt = part ? bounds['get' + part]() : that.getPosition();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1) {\n\t\t\t\treturn new HitResult(type, that, {\n\t\t\t\t\tname: part ? Base.hyphenate(part) : type,\n\t\t\t\t\tpoint: pt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar checkPosition = options.position,\n\t\t\tcheckCenter = options.center,\n\t\t\tcheckBounds = options.bounds;\n\t\tif (checkSelf && this._parent\n\t\t\t\t&& (checkPosition || checkCenter || checkBounds)) {\n\t\t\tif (checkCenter || checkBounds) {\n\t\t\t\tbounds = this.getInternalBounds();\n\t\t\t}\n\t\t\tres = checkPosition && checkPoint('position') ||\n\t\t\t\t\tcheckCenter && checkPoint('center', 'Center');\n\t\t\tif (!res && checkBounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++) {\n\t\t\t\t\tres = checkPoint('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = filter(res);\n\t\t}\n\n\t\tif (!res) {\n\t\t\tres = this._hitTestChildren(point, options, viewMatrix)\n\t\t\t\t|| checkSelf\n\t\t\t\t\t&& filter(this._hitTestSelf(point, options, viewMatrix,\n\t\t\t\t\t\tthis.getStrokeScaling() ? null\n\t\t\t\t\t\t\t: viewMatrix._shiftless().invert()))\n\t\t\t\t|| null;\n\t\t}\n\t\tif (res && res.point) {\n\t\t\tres.point = matrix.transform(res.point);\n\t\t}\n\t\treturn res;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else if (name === 'match') {\n\t\t\treturn compare(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (name === 'class') {\n\t\t\t\tif (typeof compare === 'function')\n\t\t\t\t\treturn this instanceof compare;\n\t\t\t\tvalue = this._class;\n\t\t\t}\n\t\t\tif (typeof compare === 'function') {\n\t\t\t\treturn !!compare(value);\n\t\t\t} else if (compare) {\n\t\t\t\tif (compare.test) {\n\t\t\t\t\treturn compare.test(value);\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\treturn matchObject(compare, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Base.equals(value, compare);\n\t\t}\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix, null, true)[0]\n\t\t\t\t|| null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(item, options, matrix, param, firstOnly) {\n\t\t\tif (!param) {\n\t\t\t\tvar obj = typeof options === 'object' && options,\n\t\t\t\t\toverlapping = obj && obj.overlapping,\n\t\t\t\t\tinside = obj && obj.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\trecursive: obj && obj.recursive !== false,\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (obj) {\n\t\t\t\t\toptions = Base.filter({}, options, {\n\t\t\t\t\t\trecursive: true, inside: true, overlapping: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = item._children,\n\t\t\t\titems = param.items,\n\t\t\t\trect = param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.appended(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(rect.contains(bounds)\n\t\t\t\t\t\t\t|| param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(options)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (param.recursive !== false) {\n\t\t\t\t\t_getItems(child, options, childMatrix, param, firstOnly);\n\t\t\t\t}\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this ? this.addChild(res) : res;\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tvar res = item ? this.insertChildren(index, [item]) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items) {\n\t\treturn this.insertChildren(this._children.length, items);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Base.slice(items);\n\t\t\tvar inserted = {};\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tid = item && item._id;\n\t\t\t\tif (!item || inserted[id]) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\titem._remove(false, true);\n\t\t\t\t\tinserted[id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tname = item._name;\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(project, true);\n\t\t\t\tif (name)\n\t\t\t\t\titem.setName(name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\titem._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertItem: '#insertChild',\n\n\t_insertAt: function(item, offset) {\n\t\tvar owner = item && item._getOwner(),\n\t\t\tres = item !== this && owner ? this : null;\n\t\tif (res) {\n\t\t\tres._remove(false, true);\n\t\t\towner._insertItem(item._index + offset, res);\n\t\t}\n\t\treturn res;\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn this._insertAt(item, 1);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn this._insertAt(item, 0);\n\t},\n\n\tsendToBack: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(0, this) : null;\n\t},\n\n\tbringToFront: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(undefined, this) : null;\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\taddTo: function(owner) {\n\t\treturn owner._insertItem(undefined, this);\n\t},\n\n\tcopyTo: function(owner) {\n\t\treturn this.clone(false).addTo(owner);\n\t},\n\n\treduce: function(options) {\n\t\tvar children = this._children;\n\t\tif (children && children.length === 1) {\n\t\t\tvar child = children[0].reduce(options);\n\t\t\tif (this._parent) {\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tthis.remove();\n\t\t\t} else {\n\t\t\t\tchild.remove();\n\t\t\t}\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar owner = this._getOwner();\n\t\tif (owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[0];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar owner = this._getOwner(),\n\t\t\tproject = this._project,\n\t\t\tindex = this._index;\n\t\tif (owner) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (index != null) {\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(owner._children, null, index, 1);\n\t\t\t}\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent)\n\t\t\t\towner._changed(11, this);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(start, end) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, start, end - start);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function() {\n\t\tvar children = this._children;\n\t\treturn !children || !children.length;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent === item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t_setApplyMatrix) {\n\t\tvar _matrix = this._matrix,\n\t\t\ttransform = matrix && !matrix.isIdentity(),\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t&& ((!_matrix.isIdentity() || transform)\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\tif (!transform && !applyMatrix)\n\t\t\treturn this;\n\t\tif (transform) {\n\t\t\tif (!matrix.isInvertible() && _matrix.isInvertible())\n\t\t\t\t_matrix._backup = _matrix.getValues();\n\t\t\t_matrix.prepend(matrix, true);\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\t\tif (applyMatrix && (applyMatrix = this._transformContent(_matrix,\n\t\t\t\t_applyRecursively, _setApplyMatrix))) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tif (transform || applyMatrix) {\n\t\t\tthis._changed(9);\n\t\t}\n\t\tvar decomp = transform && bounds && matrix.decompose();\n\t\tif (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar cache = bounds[key];\n\t\t\t\tif (cache.nonscaling) {\n\t\t\t\t\tdelete bounds[key];\n\t\t\t\t} else if (applyMatrix || !cache.internal) {\n\t\t\t\t\tvar rect = cache.rect;\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bounds = bounds;\n\t\t\tvar cached = bounds[this._getBoundsCacheKey(\n\t\t\t\t\tthis._boundsOptions || {})];\n\t\t\tif (cached) {\n\t\t\t\tthis._position = cached.rect.getCenter(true);\n\t\t\t}\n\t\t} else if (transform && position && this._pivot) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\tsetApplyMatrix);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t}\n}), {\n\n\t_setStyles: function(ctx, param, viewMatrix) {\n\t\tvar style = this._style,\n\t\t\tmatrix = this._matrix;\n\t\tif (style.hasFill()) {\n\t\t\tctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n\t\t}\n\t\tif (style.hasStroke()) {\n\t\t\tctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n\t\t\tctx.lineWidth = style.getStrokeWidth();\n\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\tif (strokeJoin)\n\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\tif (strokeCap)\n\t\t\t\tctx.lineCap = strokeCap;\n\t\t\tif (miterLimit)\n\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\tif (paper.support.nativeDash) {\n\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (style.hasShadow()) {\n\t\t\tvar pixelRatio = param.pixelRatio || 1,\n\t\t\t\tmx = viewMatrix._shiftless().prepend(\n\t\t\t\t\tnew Matrix().scale(pixelRatio, pixelRatio)),\n\t\t\t\tblur = mx.transform(new Point(style.getShadowBlur(), 0)),\n\t\t\t\toffset = mx.transform(this.getShadowOffset());\n\t\t\tctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n\t\t\tctx.shadowBlur = blur.getLength();\n\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\tctx.shadowOffsetY = offset.y;\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].appended(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tviewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)\n\t\t\t\t: globalMatrix;\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = this._opacity,\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(viewMatrix);\n\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\treturn;\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.appended(matrix)\n\t\t\t\t: this._canScaleStroke && !this.getStrokeScaling(true)\n\t\t\t\t\t&& viewMatrix,\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform) {\n\t\t\t(direct ? matrix : viewMatrix).applyToContext(ctx);\n\t\t}\n\t\tif (clip) {\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, viewMatrix, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish)\n\t\t\tctx.clip();\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n\t\tvar selection = this._selection,\n\t\t\titemSelected = selection & 1,\n\t\t\tboundsSelected = selection & 2\n\t\t\t\t\t|| itemSelected && this._selectBounds,\n\t\t\tpositionSelected = selection & 4;\n\t\tif (!this._drawSelected)\n\t\t\titemSelected = false;\n\t\tif ((itemSelected || boundsSelected || positionSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar layer,\n\t\t\t\tcolor = this.getSelectedColor(true) || (layer = this.getLayer())\n\t\t\t\t\t&& layer.getSelectedColor(true),\n\t\t\t\tmx = matrix.appended(this.getGlobalMatrix(true)),\n\t\t\t\thalf = size / 2;\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (itemSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectionItems);\n\t\t\tif (positionSelected) {\n\t\t\t\tvar point = this.getPosition(true),\n\t\t\t\t\tx = point.x,\n\t\t\t\t\ty = point.y;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.stroke();\n\t\t\t\tvar deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],\n\t\t\t\t\tstart = half,\n\t\t\t\t\tend = size + 1;\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar delta = deltas[i],\n\t\t\t\t\t\tdx = delta[0],\n\t\t\t\t\t\tdy = delta[1];\n\t\t\t\t\tctx.moveTo(x + dx * start, y + dy * start);\n\t\t\t\t\tctx.lineTo(x + dx * end, y + dy * end);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (boundsSelected) {\n\t\t\t\tvar coords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(key) {\n\tthis['removeOn' + Base.capitalize(key)] = function() {\n\t\tvar hash = {};\n\t\thash[key] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}));\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectBounds: false,\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 1026) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i]._clipMask) {\n\t\t\t\t\tclipItem = children[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_getBounds: function _getBounds(matrix, options) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn clipItem\n\t\t\t? clipItem._getCachedBounds(\n\t\t\t\tmatrix && matrix.appended(clipItem._matrix),\n\t\t\t\tBase.set({}, options, { stroke: false }))\n\t\t\t: _getBounds.base.call(this, matrix, options);\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn (!clipItem || clipItem.contains(point))\n\t\t\t\t&& _hitTestChildren.base.call(this, point, options, viewMatrix,\n\t\t\t\t\tclipItem);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem();\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tctx.beginPath();\n\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar item = children[i];\n\t\t\tif (item !== clipItem)\n\t\t\t\titem.draw(ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer() {\n\t\tGroup.apply(this, arguments);\n\t},\n\n\t_getOwner: function() {\n\t\treturn this._parent || this._index != null && this._project;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_hitTestSelf: function() {\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_canScaleStroke: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props, point) {\n\t\tthis._initialize(props, point);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setType(source._type);\n\t\tthis.setSize(source._size);\n\t\tthis.setRadius(source._radius);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tthis._radius.set(Size.min(this._radius, size.divide(2)));\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius._set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size._set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size._set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size._set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t});\n\t\tpath.copyAttributes(this);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\tif (insert === undefined || insert)\n\t\t\tpath.insertAbove(this);\n\t\treturn path;\n\t},\n\n\ttoShape: '#clone',\n\n\t_asPathItem: function() {\n\t\treturn this.toPath(false);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\tstyle = this._style,\n\t\t\tstrokeWidth = options.stroke && style.hasStroke()\n\t\t\t\t\t&& style.getStrokeWidth();\n\t\tif (matrix)\n\t\t\trect = matrix._transformBounds(rect);\n\t\treturn strokeWidth\n\t\t\t\t? rect.expand(Path._getStrokePadding(strokeWidth,\n\t\t\t\t\tthis._getStrokeMatrix(matrix, options)))\n\t\t\t\t: rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var q = 1; q <= 4; q++) {\n\t\t\t\tvar dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(\n\t\t\t\t\t\t\texpand ? corner.add(dir.multiply(expand)) : corner,\n\t\t\t\t\t\t\tcenter);\n\t\t\t\tif (rect.contains(point))\n\t\t\t\t\treturn { point: center, quadrant: q };\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isOnEllipseStroke(point, radius, padding, quadrant) {\n\t\tvar vector = point.divide(radius);\n\t\treturn (!quadrant || vector.isInQuadrant(quadrant)) &&\n\t\t\t\tvector.subtract(vector.normalize()).multiply(radius)\n\t\t\t\t\t.divide(padding).length <= 1;\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center.point).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,\n\t\t\t\tstrokeMatrix) {\n\t\t\tvar hit = false,\n\t\t\t\tstyle = this._style,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill();\n\t\t\tif (hitStroke || hitFill) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\t\tstrokePadding = options._tolerancePadding.add(\n\t\t\t\t\t\tPath._getStrokePadding(strokeRadius,\n\t\t\t\t\t\t\t!style.getStrokeScaling() && strokeMatrix));\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar padding = strokePadding.multiply(2),\n\t\t\t\t\t\tcenter = getCornerCenter(this, point, padding);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\thit = isOnEllipseStroke(point.subtract(center.point),\n\t\t\t\t\t\t\t\tradius, strokePadding, center.quadrant);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(padding),\n\t\t\t\t\t\t\tinner = rect.expand(padding.negate());\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thit = isOnEllipseStroke(point, radius, strokePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = new Shape(Base.getNamed(args), point);\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\treturn item;\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targuments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, arguments);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: false, handle: false },\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\t_prioritize: ['crossOrigin'],\n\n\tinitialize: function Raster(object, position) {\n\t\tif (!this._initialize(object,\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\tvar image = typeof object === 'string'\n\t\t\t\t\t? document.getElementById(object) : object;\n\t\t\tif (image) {\n\t\t\t\tthis.setImage(image);\n\t\t\t} else {\n\t\t\t\tthis.setSource(object);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar image = source._image,\n\t\t\tcanvas = source._canvas;\n\t\tif (image) {\n\t\t\tthis._setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(source._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tthis._setImage(copyCanvas);\n\t\t}\n\t\tthis._crossOrigin = source._crossOrigin;\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = this.getElement();\n\t\t\t\tthis._setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element)\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tgetLoaded: function() {\n\t\treturn this._loaded;\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tvar that = this;\n\n\t\tfunction emit(event) {\n\t\t\tvar view = that.getView(),\n\t\t\t\ttype = event && event.type || 'load';\n\t\t\tif (view && that.responds(type)) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.emit(type, new Event(event));\n\t\t\t}\n\t\t}\n\n\t\tthis._setImage(image);\n\t\tif (this._loaded) {\n\t\t\tsetTimeout(emit, 0);\n\t\t} else if (image) {\n\t\t\tDomEvent.add(image, {\n\t\t\t\tload: function(event) {\n\t\t\t\t\tthat._setImage(image);\n\t\t\t\t\temit(event);\n\t\t\t\t},\n\t\t\t\terror: emit\n\t\t\t});\n\t\t}\n\t},\n\n\t_setImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = !!(image && image.src && image.complete);\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(521);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(modify) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (modify) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(513);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar image = new self.Image(),\n\t\t\tcrossOrigin = this._crossOrigin;\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\timage.src = src;\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tvar image = this._image;\n\t\tif (image)\n\t\t\timage.crossOrigin = crossOrigin;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster._setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.prepend(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar image = this._image,\n\t\t\tsrc = image && image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (typeof object === 'object') {\n\t\t\tif ('width' in object) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if ('x' in object) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t}\n\t\tif (!bounds)\n\t\t\treturn null;\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcolor = Color.read(arguments),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx) {\n\t\tvar element = this.getElement();\n\t\tif (element) {\n\t\t\tctx.globalAlpha = this._opacity;\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar SymbolItem = Item.extend({\n\t_class: 'SymbolItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: true },\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function SymbolItem(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setDefinition(arg0 instanceof SymbolDefinition ?\n\t\t\t\t\targ0 : new SymbolDefinition(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._definition === item._definition;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setDefinition(source._definition);\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(definition) {\n\t\tthis._definition = definition;\n\t\tthis._changed(9);\n\t},\n\n\tgetSymbol: '#getDefinition',\n\tsetSymbol: '#setDefinition',\n\n\tisEmpty: function() {\n\t\treturn this._definition._item.isEmpty();\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar item = this._definition._item;\n\t\treturn item._getCachedBounds(item._matrix.prepended(matrix), options);\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix) {\n\t\tvar res = this._definition._item._hitTest(point, options, viewMatrix);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis._definition._item.draw(ctx, param);\n\t}\n\n});\n\nvar SymbolDefinition = Base.extend({\n\t_class: 'SymbolDefinition',\n\n\tinitialize: function SymbolDefinition(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tif (item)\n\t\t\tthis.setItem(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._item],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8)\n\t\t\tItem._clearBoundsCache(this);\n\t\tif (flags & 1)\n\t\t\tthis.project._changed(flags);\n\t},\n\n\tgetItem: function() {\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item, _dontCenter) {\n\t\tif (item._symbol)\n\t\t\titem = item.clone();\n\t\tif (this._item)\n\t\t\tthis._item._symbol = null;\n\t\tthis._item = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._symbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tgetDefinition: '#getItem',\n\tsetDefinition: '#setItem',\n\n\tplace: function(position) {\n\t\treturn new SymbolItem(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new SymbolDefinition(this._item.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this._item.equals(symbol._item)\n\t\t\t\t|| false;\n\t}\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values)\n\t\t\tthis.inject(values);\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(args) {\n\t\t\tvar options = args && Base.read(args);\n\t\t\treturn Base.set({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tposition: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\t_selection: 0,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut, selection;\n\t\tif (count > 0) {\n\t\t\tif (arg0 == null || typeof arg0 === 'object') {\n\t\t\t\tif (count === 1 && arg0 && 'point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t\tselection = arg0.selection;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t\thandleIn = arg1;\n\t\t\t\t\thandleOut = arg2;\n\t\t\t\t\tselection = arg3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\tif (selection)\n\t\t\tthis.setSelection(selection);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar point = this._point,\n\t\t\tselection = this._selection,\n\t\t\tobj = selection || this.hasHandles()\n\t\t\t\t\t? [point, this._handleIn, this._handleOut]\n\t\t\t\t\t: point;\n\t\tif (selection)\n\t\t\tobj.push(selection);\n\t\treturn Base.serialize(obj, options, true, dictionary);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(25);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tthis._point.set(Point.read(arguments));\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tthis._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tthis._handleOut.set(Point.read(arguments));\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tisSmooth: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut;\n\t\treturn !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t&& handleIn.isCollinear(handleOut);\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn._set(0, 0);\n\t\tthis._handleOut._set(0, 0);\n\t},\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tvar oldSelection = this._selection,\n\t\t\tpath = this._path;\n\t\tthis._selection = selection = selection || 0;\n\t\tif (path && selection !== oldSelection) {\n\t\t\tpath._updateSelection(this, oldSelection, selection);\n\t\t\tpath._changed(129);\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._selection & 7);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._changeSelection(7, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tsmooth: function(options, _first, _last) {\n\t\tvar opts = options || {},\n\t\t\ttype = opts.type,\n\t\t\tfactor = opts.factor,\n\t\t\tprev = this.getPrevious(),\n\t\t\tnext = this.getNext(),\n\t\t\tp0 = (prev || this)._point,\n\t\t\tp1 = this._point,\n\t\t\tp2 = (next || this)._point,\n\t\t\td1 = p0.getDistance(p1),\n\t\t\td2 = p1.getDistance(p2);\n\t\tif (!type || type === 'catmull-rom') {\n\t\t\tvar a = factor === undefined ? 0.5 : factor,\n\t\t\t\td1_a = Math.pow(d1, a),\n\t\t\t\td1_2a = d1_a * d1_a,\n\t\t\t\td2_a = Math.pow(d2, a),\n\t\t\t\td2_2a = d2_a * d2_a;\n\t\t\tif (!_first && prev) {\n\t\t\t\tvar A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,\n\t\t\t\t\tN = 3 * d2_a * (d2_a + d1_a);\n\t\t\t\tthis.setHandleIn(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,\n\t\t\t\t\t\t(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t\tif (!_last && next) {\n\t\t\t\tvar A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,\n\t\t\t\t\tN = 3 * d1_a * (d1_a + d2_a);\n\t\t\t\tthis.setHandleOut(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,\n\t\t\t\t\t\t(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t} else if (type === 'geometric') {\n\t\t\tif (prev && next) {\n\t\t\t\tvar vector = p0.subtract(p2),\n\t\t\t\t\tt = factor === undefined ? 0.4 : factor,\n\t\t\t\t\tk = t * d1 / (d1 + d2);\n\t\t\t\tif (!_first)\n\t\t\t\t\tthis.setHandleIn(vector.multiply(k));\n\t\t\t\tif (!_last)\n\t\t\t\t\tthis.setHandleOut(vector.multiply(k - t));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Smoothing method \\'' + type + '\\' not supported.');\n\t\t}\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\ttmp = handleIn.clone();\n\t\thandleIn.set(handleOut);\n\t\thandleOut.set(tmp);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar u = 1 - factor,\n\t\t\tv = factor,\n\t\t\tpoint1 = from._point,\n\t\t\tpoint2 = to._point,\n\t\t\thandleIn1 = from._handleIn,\n\t\t\thandleIn2 = to._handleIn,\n\t\t\thandleOut2 = to._handleOut,\n\t\t\thandleOut1 = from._handleOut;\n\t\tthis._point._set(\n\t\t\t\tu * point1._x + v * point2._x,\n\t\t\t\tu * point1._y + v * point2._y, true);\n\t\tthis._handleIn._set(\n\t\t\t\tu * handleIn1._x + v * handleIn2._x,\n\t\t\t\tu * handleIn1._y + v * handleIn2._y, true);\n\t\tthis._handleOut._set(\n\t\t\t\tu * handleOut1._x + v * handleOut2._x,\n\t\t\t\tu * handleOut1._y + v * handleOut2._y, true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y,\n\t\t\tselected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\t_set: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this._x) && isZero(this._y);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\tvar owner = this._owner;\n\t\treturn this === owner._point ? 1\n\t\t\t: this === owner._handleIn ? 2\n\t\t\t: this === owner._handleOut ? 4\n\t\t\t: 0;\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\tbeans: true,\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (!count) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tclassify: function() {\n\t\treturn Curve.classify(this.getValues());\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tthis._segment1._point.set(Point.read(arguments));\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tthis._segment2._point.set(Point.read(arguments));\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tthis._segment1._handleOut.set(Point.read(arguments));\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tthis._segment2._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._segment1._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t}\n}, {\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tdivideAt: function(location) {\n\t\treturn this.divideAtTime(location && location.curve === this\n\t\t\t\t? location.time : this.getTimeAt(location));\n\t},\n\n\tdivideAtTime: function(time, _setHandles) {\n\t\tvar tMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (time >= tMin && time <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), time),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tseg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tseg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n\t\t\t\tseg2._handleIn._set(right[4] - right[6],right[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(seg1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tthis._changed();\n\t\t\t\tres = new Curve(segment, seg2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar path = this._path;\n\t\treturn path ? path.splitAt(location) : null;\n\t},\n\n\tsplitAtTime: function(time) {\n\t\treturn this.splitAt(this.getLocationAtTime(time));\n\t},\n\n\tdivide: function(offset, isTime) {\n\t\treturn this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\tsplit: function(offset, isTime) {\n\t\treturn this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut._set(0, 0);\n\t\tthis._segment2._handleIn._set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix, straight) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tx1 = p1.x, y1 = p1.y,\n\t\t\tx2 = p2.x, y2 = p2.y,\n\t\t\tvalues = straight\n\t\t\t\t? [ x1, y1, x1, y1, x2, y2, x2, y2 ]\n\t\t\t\t: [\n\t\t\t\t\tx1, y1,\n\t\t\t\t\tx1 + h1._x, y1 + h1._y,\n\t\t\t\t\tx2 + h2._x, y2 + h2._y,\n\t\t\t\t\tx2, y2\n\t\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tx4 = u * x0 + t * x1, y4 = u * y0 + t * y1,\n\t\t\tx5 = u * x1 + t * x2, y5 = u * y1 + t * y2,\n\t\t\tx6 = u * x2 + t * x3, y6 = u * y2 + t * y3,\n\t\t\tx7 = u * x4 + t * x5, y7 = u * y4 + t * y5,\n\t\t\tx8 = u * x5 + t * x6, y8 = u * y5 + t * y6,\n\t\t\tx9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n\t\treturn [\n\t\t\t[x0, y0, x4, y4, x7, y7, x9, y9],\n\t\t\t[x9, y9, x8, y8, x6, y6, x3, y3]\n\t\t];\n\t},\n\n\tgetMonoCurves: function(v, dir) {\n\t\tvar curves = [],\n\t\t\tio = dir ? 0 : 1,\n\t\t\to0 = v[io + 0],\n\t\t\to1 = v[io + 2],\n\t\t\to2 = v[io + 4],\n\t\t\to3 = v[io + 6];\n\t\tif ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)\n\t\t\t\t|| Curve.isStraight(v)) {\n\t\t\tcurves.push(v);\n\t\t} else {\n\t\t\tvar a = 3 * (o1 - o2) - o0 + o3,\n\t\t\t\tb = 2 * (o0 + o2) - 4 * o1,\n\t\t\t\tc = o1 - o0,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [],\n\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\tif (!n) {\n\t\t\t\tcurves.push(v);\n\t\t\t} else {\n\t\t\t\troots.sort();\n\t\t\t\tvar t = roots[0],\n\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\tcurves.push(parts[0]);\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\tcurves.push(parts[0]);\n\t\t\t\t}\n\t\t\t\tcurves.push(parts[1]);\n\t\t\t}\n\t\t}\n\t\treturn curves;\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar v0 = v[coord],\n\t\t\tv1 = v[coord + 2],\n\t\t\tv2 = v[coord + 4],\n\t\t\tv3 = v[coord + 6],\n\t\t\tres = 0;\n\t\tif (  !(v0 < val && v3 < val && v1 < val && v2 < val ||\n\t\t\t\tv0 > val && v3 > val && v1 > val && v2 > val)) {\n\t\t\tvar c = 3 * (v1 - v0),\n\t\t\t\tb = 3 * (v2 - v1) - c,\n\t\t\t\ta = v3 - v0 - c - b;\n\t\t\tres = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n\t\t}\n\t\treturn res;\n\t},\n\n\tgetTimeOf: function(v, point) {\n\t\tvar p0 = new Point(v[0], v[1]),\n\t\t\tp3 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tt = point.isClose(p0, epsilon) ? 0\n\t\t\t  : point.isClose(p3, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t === null) {\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [];\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar u = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, u), geomEpsilon))\n\t\t\t\t\t\treturn u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p0, geomEpsilon) ? 0\n\t\t\t : point.isClose(p3, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestTime: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tvx = x3 - x0, vy = y3 - y0,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getTimeOf(v,\n\t\t\t\t\tnew Point(x0 + u * vx, y0 + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 1e-8) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\tisFlatEnough: function(v, flatness) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tux = 3 * x1 - 2 * x0 - x3,\n\t\t\tuy = 3 * y1 - 2 * y0 - y3,\n\t\t\tvx = 3 * x2 - 2 * x3 - x0,\n\t\t\tvy = 3 * y2 - 2 * y3 - y0;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t<= 16 * flatness * flatness;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)\n\t\t\t\t+ y1 * (x0 - x2) - x1 * (y0 - y2)\n\t\t\t\t+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\n\t\tpadding /= 2;\n\t\tvar minPad = min[coord] - padding,\n\t\t\tmaxPad = max[coord] + padding;\n\t\tif (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||\n\t\t\t\tv0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n\t\t\tif (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n\t\t\t\tadd(v0, padding);\n\t\t\t\tadd(v3, padding);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0,\n\t\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\t\ttMin = 1e-8,\n\t\t\t\t\ttMax = 1 - tMin;\n\t\t\t\tadd(v3, 0);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar t = roots[i],\n\t\t\t\t\t\tu = 1 - t;\n\t\t\t\t\tif (tMin <= t && t <= tMax)\n\t\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\t\tpadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false, this._path);\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(p1, h1, h2, p2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar v = p2.subtract(p1);\n\t\t\tif (v.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n\t\t\t\tvar l = new Line(p1, p2),\n\t\t\t\t\tepsilon = 1e-7;\n\t\t\t\tif (l.getDistance(p1.add(h1)) < epsilon &&\n\t\t\t\t\tl.getDistance(p2.add(h2)) < epsilon) {\n\t\t\t\t\tvar div = v.dot(v),\n\t\t\t\t\t\ts1 = v.dot(h1) / div,\n\t\t\t\t\t\ts2 = v.dot(h2) / div;\n\t\t\t\t\treturn s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(p1, h1, h2, p2) {\n\t\tvar third = p2.subtract(p1).divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function(epsilon) {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,\n\t\t\t\tepsilon);\n\t};\n\n\tthis.statics[name] = function(v, epsilon) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn test(\n\t\t\t\tnew Point(x0, y0),\n\t\t\t\tnew Point(v[2] - x0, v[3] - y0),\n\t\t\t\tnew Point(v[4] - x3, v[5] - y3),\n\t\t\t\tnew Point(x3, y3), epsilon);\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\thasLength: function(epsilon) {\n\t\treturn (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())\n\t\t\t\t&& this.getLength() > (epsilon || 0);\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)\n\t\t\t\t< 1e-8;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)\n\t\t\t\t< 1e-8;\n\t}\n}), {\n\tbeans: false,\n\n\tgetLocationAt: function(offset, _isTime) {\n\t\treturn this.getLocationAtTime(\n\t\t\t\t_isTime ? offset : this.getTimeAt(offset));\n\t},\n\n\tgetLocationAtTime: function(t) {\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetTimeAt: function(offset, start) {\n\t\treturn Curve.getTimeAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterAt: '#getTimeAt',\n\n\tgetOffsetAtTime: function(t) {\n\t\treturn this.getPartLength(0, t);\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetTimeOf: function() {\n\t\treturn Curve.getTimeOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetParameterOf: '#getTimeOf',\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestTime(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(location, _isTime) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, _isTime ? location\n\t\t\t\t\t\t: Curve.getTimeAt(values, location));\n\t\t\t};\n\n\t\t\tthis[name + 'AtTime'] = function(time) {\n\t\t\t\treturn Curve[name](this.getValues(), time);\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\t_evaluateMethods: methods\n\t\t\t}\n\t\t}\n\t);\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\n\t\t\tax = 9 * (x1 - x2) + 3 * (x3 - x0),\n\t\t\tbx = 6 * (x0 + x2) - 12 * x1,\n\t\t\tcx = 3 * (x1 - x0),\n\n\t\t\tay = 9 * (y1 - y2) + 3 * (y3 - y0),\n\t\t\tby = 6 * (y0 + y2) - 12 * y1,\n\t\t\tcy = 3 * (y1 - y0);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tisZero = Numerical.isZero;\n\t\tif (isZero(x1 - x0) && isZero(y1 - y0)) {\n\t\t\tx1 = x0;\n\t\t\ty1 = y0;\n\t\t}\n\t\tif (isZero(x2 - x3) && isZero(y2 - y3)) {\n\t\t\tx2 = x3;\n\t\t\ty2 = y3;\n\t\t}\n\t\tvar cx = 3 * (x1 - x0),\n\t\t\tbx = 3 * (x2 - x1) - cx,\n\t\t\tax = x3 - x0 - cx - bx,\n\t\t\tcy = 3 * (y1 - y0),\n\t\t\tby = 3 * (y2 - y1) - cy,\n\t\t\tay = y3 - y0 - cy - by,\n\t\t\tx, y;\n\t\tif (type === 0) {\n\t\t\tx = t === 0 ? x0 : t === 1 ? x3\n\t\t\t\t\t: ((ax * t + bx) * t + cx) * t + x0;\n\t\t\ty = t === 0 ? y0 : t === 1 ? y3\n\t\t\t\t\t: ((ay * t + by) * t + cy) * t + y0;\n\t\t} else {\n\t\t\tvar tMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t < tMin) {\n\t\t\t\tx = cx;\n\t\t\t\ty = cy;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tx = 3 * (x3 - x2);\n\t\t\t\ty = 3 * (y3 - y2);\n\t\t\t} else {\n\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t}\n\t\t\tif (normalized) {\n\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\tx = x2 - x1;\n\t\t\t\t\ty = y2 - y1;\n\t\t\t\t}\n\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\tif (len) {\n\t\t\t\t\tx /= len;\n\t\t\t\t\ty /= len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type === 3) {\n\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tclassify: function(v) {\n\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\ta1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,\n\t\t\t\ta2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,\n\t\t\t\ta3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,\n\t\t\t\td3 = 3 * a3,\n\t\t\t\td2 = d3 - a2,\n\t\t\t\td1 = d2 - a2 + a1,\n\t\t\t\tl = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),\n\t\t\t\ts = l !== 0 ? 1 / l : 0,\n\t\t\t\tisZero = Numerical.isZero,\n\t\t\t\tserpentine = 'serpentine';\n\t\t\td1 *= s;\n\t\t\td2 *= s;\n\t\t\td3 *= s;\n\n\t\t\tfunction type(type, t1, t2) {\n\t\t\t\tvar hasRoots = t1 !== undefined,\n\t\t\t\t\tt1Ok = hasRoots && t1 > 0 && t1 < 1,\n\t\t\t\t\tt2Ok = hasRoots && t2 > 0 && t2 < 1;\n\t\t\t\tif (hasRoots && (!(t1Ok || t2Ok)\n\t\t\t\t\t\t|| type === 'loop' && !(t1Ok && t2Ok))) {\n\t\t\t\t\ttype = 'arch';\n\t\t\t\t\tt1Ok = t2Ok = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: type,\n\t\t\t\t\troots: t1Ok || t2Ok\n\t\t\t\t\t\t\t? t1Ok && t2Ok\n\t\t\t\t\t\t\t\t? t1 < t2 ? [t1, t2] : [t2, t1]\n\t\t\t\t\t\t\t\t: [t1Ok ? t1 : t2]\n\t\t\t\t\t\t\t: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isZero(d1)) {\n\t\t\t\treturn isZero(d2)\n\t\t\t\t\t\t? type(isZero(d3) ? 'line' : 'quadratic')\n\t\t\t\t\t\t: type(serpentine, d3 / (3 * d2));\n\t\t\t}\n\t\t\tvar d = 3 * d2 * d2 - 4 * d1 * d3;\n\t\t\tif (isZero(d)) {\n\t\t\t\treturn type('cusp', d2 / (2 * d1));\n\t\t\t}\n\t\t\tvar f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),\n\t\t\t\tf2 = 2 * d1;\n\t\t\treturn type(d > 0 ? serpentine : 'loop',\n\t\t\t\t\t(d2 + f1) / f2,\n\t\t\t\t\t(d2 - f1) / f2);\n\t\t},\n\n\t\tgetLength: function(v, a, b, ds) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar c = v;\n\t\t\t\tif (b < 1) {\n\t\t\t\t\tc = Curve.subdivide(c, b)[0];\n\t\t\t\t\ta /= b;\n\t\t\t\t}\n\t\t\t\tif (a > 0) {\n\t\t\t\t\tc = Curve.subdivide(c, a)[1];\n\t\t\t\t}\n\t\t\t\tvar dx = c[6] - c[0],\n\t\t\t\t\tdy = c[7] - c[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\treturn Numerical.integrate(ds || getLengthIntegrand(v), a, b,\n\t\t\t\t\tgetIterations(a, b));\n\t\t},\n\n\t\tgetTimeAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0;\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Curve.getLength(v, a, b, ds),\n\t\t\t\tdiff = abs(offset) - rangeLength;\n\t\t\tif (abs(diff) < epsilon) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (diff > epsilon) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t},\n\n\t\tgetPeaks: function(v) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tax =     -x0 + 3 * x1 - 3 * x2 + x3,\n\t\t\t\tbx =  3 * x0 - 6 * x1 + 3 * x2,\n\t\t\t\tcx = -3 * x0 + 3 * x1,\n\t\t\t\tay =     -y0 + 3 * y1 - 3 * y2 + y3,\n\t\t\t\tby =  3 * y0 - 6 * y1 + 3 * y2,\n\t\t\t\tcy = -3 * y0 + 3 * y1,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [];\n\t\t\tNumerical.solveCubic(\n\t\t\t\t\t9 * (ax * ax + ay * ay),\n\t\t\t\t\t9 * (ax * bx + by * ay),\n\t\t\t\t\t2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),\n\t\t\t\t\t(cx * bx + by * cy),\n\t\t\t\t\troots, tMin, tMax);\n\t\t\treturn roots.sort();\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, include, c1, t1, c2, t2, overlap) {\n\t\tvar excludeStart = !overlap && c1.getPrevious() === c2,\n\t\t\texcludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&\n\t\t\tt1 <= (excludeEnd ? tMax : 1)) {\n\t\t\tif (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&\n\t\t\t\tt2 <= (excludeStart ? tMax : 1)) {\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1, null, overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2, null, overlap);\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc1)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc1, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, include, flip,\n\t\t\trecursion, calls, tMin, tMax, uMin, uMax) {\n\t\tif (++calls >= 4096 || ++recursion >= 40)\n\t\t\treturn calls;\n\t\tvar fatLineEpsilon = 1e-9,\n\t\t\tq0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif (d1 === 0 && d2 === 0\n\t\t\t\t&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0\n\t\t\t|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null\n\t\t\t|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn calls;\n\t\tvar tMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n\t\t\tvar t = (tMinNew + tMaxNew) / 2,\n\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tflip ? c2 : c1, flip ? u : t,\n\t\t\t\t\tflip ? c1 : c2, flip ? t : u);\n\t\t} else {\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tif (tMaxClip - tMinClip > 0.8) {\n\t\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = (tMinNew + tMaxNew) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[0], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, t);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[1], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, t, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[0], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, u, tMinNew, tMaxNew);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[1], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, u, uMax, tMinNew, tMaxNew);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (uMax - uMin >= fatLineEpsilon) {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, include, flip,\n\t\t\t\t\t\t\trecursion, calls, tMinNew, tMaxNew, uMin, uMax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn calls;\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= 0.5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getCurveLineIntersections(v, px, py, vx, vy) {\n\t\tvar isZero = Numerical.isZero;\n\t\tif (isZero(vx) && isZero(vy)) {\n\t\t\tvar t = Curve.getTimeOf(v, new Point(px, py));\n\t\t\treturn t === null ? [] : [t];\n\t\t}\n\t\tvar angle = Math.atan2(-vy, vx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trv = [],\n\t\t\troots = [];\n\t\tfor (var i = 0; i < 8; i += 2) {\n\t\t\tvar x = v[i] - px,\n\t\t\t\ty = v[i + 1] - py;\n\t\t\trv.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tCurve.solveCubic(rv, 1, 0, roots, 0, 1);\n\t\treturn roots;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, include,\n\t\t\tflip) {\n\t\tvar x1 = v2[0], y1 = v2[1],\n\t\t\tx2 = v2[6], y2 = v2[7],\n\t\t\troots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n\t\tfor (var i = 0, l = roots.length; i < l; i++) {\n\t\t\tvar t1 = roots[i],\n\t\t\t\tp1 = Curve.getPoint(v1, t1),\n\t\t\t\tt2 = Curve.getTimeOf(v2, p1);\n\t\t\tif (t2 !== null) {\n\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\tflip ? c2 : c1, flip ? t2 : t1,\n\t\t\t\t\t\tflip ? c1 : c2, flip ? t1 : t2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, include) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, Curve.getTimeOf(v1, pt),\n\t\t\t\t\tc2, Curve.getTimeOf(v2, pt));\n\t\t}\n\t}\n\n\tfunction getCurveIntersections(v1, v2, c1, c2, locations, include) {\n\t\tvar epsilon = 1e-12,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max;\n\n\t\tif (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >\n\t\t\tmin(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmin(v1[0], v1[2], v1[4], v1[6]) - epsilon <\n\t\t\tmax(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmax(v1[1], v1[3], v1[5], v1[7]) + epsilon >\n\t\t\tmin(v2[1], v2[3], v2[5], v2[7]) &&\n\t\t\tmin(v1[1], v1[3], v1[5], v1[7]) - epsilon <\n\t\t\tmax(v2[1], v2[3], v2[5], v2[7])) {\n\t\t\tvar overlaps = getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\tc1, overlap[0],\n\t\t\t\t\t\t\tc2, overlap[1], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tflip = straight1 && !straight2,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tflip ? v2 : v1, flip ? v1 : v2,\n\t\t\t\t\t\t\tflip ? c2 : c1, flip ? c1 : c2,\n\t\t\t\t\t\t\tlocations, include, flip,\n\t\t\t\t\t\t\t0, 0, 0, 1, 0, 1);\n\t\t\t\tif (!straight || locations.length === before) {\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tvar t1 = i >> 1,\n\t\t\t\t\t\t\tt2 = i & 1,\n\t\t\t\t\t\t\ti1 = t1 * 6,\n\t\t\t\t\t\t\ti2 = t2 * 6,\n\t\t\t\t\t\t\tp1 = new Point(v1[i1], v1[i1 + 1]),\n\t\t\t\t\t\t\tp2 = new Point(v2[i2], v2[i2 + 1]);\n\t\t\t\t\t\tif (p1.isClose(p2, epsilon)) {\n\t\t\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\t\t\tc1, t1,\n\t\t\t\t\t\t\t\t\tc2, t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getLoopIntersection(v1, c1, locations, include) {\n\t\tvar info = Curve.classify(v1);\n\t\tif (info.type === 'loop') {\n\t\t\tvar roots = info.roots;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, roots[0],\n\t\t\t\t\tc1, roots[1]);\n\t\t}\n\t  return locations;\n\t}\n\n\tfunction getIntersections(curves1, curves2, include, matrix1, matrix2,\n\t\t\t_returnFirst) {\n\t\tvar self = !curves2;\n\t\tif (self)\n\t\t\tcurves2 = curves1;\n\t\tvar length1 = curves1.length,\n\t\t\tlength2 = curves2.length,\n\t\t\tvalues2 = [],\n\t\t\tarrays = [],\n\t\t\tlocations,\n\t\t\tcurrent;\n\t\tfor (var i = 0; i < length2; i++)\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvar curve1 = curves1[i],\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\tpath1 = curve1.getPath();\n\t\t\tif (path1 !== current) {\n\t\t\t\tcurrent = path1;\n\t\t\t\tlocations = [];\n\t\t\t\tarrays.push(locations);\n\t\t\t}\n\t\t\tif (self) {\n\t\t\t\tgetLoopIntersection(values1, curve1, locations, include);\n\t\t\t}\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\treturn locations;\n\t\t\t\tgetCurveIntersections(values1, values2[j], curve1, curves2[j],\n\t\t\t\t\t\tlocations, include);\n\t\t\t}\n\t\t}\n\t\tlocations = [];\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getOverlaps(v1, v2) {\n\n\t\tfunction getSquaredLineLength(v) {\n\t\t\tvar x = v[6] - v[0],\n\t\t\t\ty = v[7] - v[1];\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tvar abs = Math.abs,\n\t\t\tgetDistance = Line.getDistance,\n\t\t\ttimeEpsilon = 1e-8,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\tstraightBoth = straight1 && straight2,\n\t\t\tflip = getSquaredLineLength(v1) < getSquaredLineLength(v2),\n\t\t\tl1 = flip ? v2 : v1,\n\t\t\tl2 = flip ? v1 : v2,\n\t\t\tpx = l1[0], py = l1[1],\n\t\t\tvx = l1[6] - px, vy = l1[7] - py;\n\t\tif (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&\n\t\t\tgetDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n\t\t\tif (!straightBoth &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {\n\t\t\t\tstraight1 = straight2 = straightBoth = true;\n\t\t\t}\n\t\t} else if (straightBoth) {\n\t\t\treturn null;\n\t\t}\n\t\tif (straight1 ^ straight2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar v = [v1, v2],\n\t\t\tpairs = [];\n\t\tfor (var i = 0; i < 4 && pairs.length < 2; i++) {\n\t\t\tvar i1 = i & 1,\n\t\t\t\ti2 = i1 ^ 1,\n\t\t\t\tt1 = i >> 1,\n\t\t\t\tt2 = Curve.getTimeOf(v[i1], new Point(\n\t\t\t\t\tv[i2][t1 ? 6 : 0],\n\t\t\t\t\tv[i2][t1 ? 7 : 1]));\n\t\t\tif (t2 != null) {\n\t\t\t\tvar pair = i1 ? [t1, t2] : [t2, t1];\n\t\t\t\tif (!pairs.length ||\n\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon) {\n\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && !pairs.length)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pairs.length !== 2) {\n\t\t\tpairs = null;\n\t\t} else if (!straightBoth) {\n\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\tpairs = null;\n\t\t}\n\t\treturn pairs;\n\t}\n\n\treturn {\n\t\tgetIntersections: function(curve) {\n\t\t\tvar v1 = this.getValues(),\n\t\t\t\tv2 = curve && curve !== this && curve.getValues();\n\t\t\treturn v2 ? getCurveIntersections(v1, v2, this, curve, [])\n\t\t\t\t\t  : getLoopIntersection(v1, this, []);\n\t\t},\n\n\t\tstatics: {\n\t\t\tgetOverlaps: getOverlaps,\n\t\t\tgetIntersections: getIntersections,\n\t\t\tgetCurveLineIntersections: getCurveLineIntersections\n\t\t}\n\t};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\n\tinitialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n\t\tif (time >= 0.99999999) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\ttime = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._setCurve(curve);\n\t\tthis._time = time;\n\t\tthis._point = point || curve.getPointAtTime(time);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._previous = null;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tvar path = curve._path;\n\t\tthis._path = path;\n\t\tthis._version = path ? path._version : 0;\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tthis._setCurve(segment.getCurve());\n\t\tthis._segment = segment;\n\t\tthis._time = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar segment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tif (time === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (time != null) {\n\t\t\t\tsegment = curve.getPartLength(0, time)\n\t\t\t\t\t< curve.getPartLength(time, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tthis._time = this._offset = this._curveOffset = this._curve = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn this._curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetTime: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this._time;\n\t\treturn curve && time == null\n\t\t\t? this._time = curve.getTimeOf(this._point)\n\t\t\t: time;\n\t},\n\n\tgetParameter: '#getTime',\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar offset = this._curveOffset;\n\t\tif (offset == null) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tthis._curveOffset = offset = time != null && curve\n\t\t\t\t\t&& curve.getPartLength(0, time);\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = curve && curve.divideAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tpath = curve._path,\n\t\t\tres = curve && curve.splitAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(path.getLastSegment());\n\t\t}\n\t\treturn  res;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc;\n\t\tif (!res && loc instanceof CurveLocation) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tp1 = c1._path,\n\t\t\t\tp2 = c2._path;\n\t\t\tif (p1 === p2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tepsilon = 1e-7,\n\t\t\t\t\tdiff = abs(this.getOffset() - loc.getOffset()),\n\t\t\t\t\ti1 = !_ignoreOther && this._intersection,\n\t\t\t\t\ti2 = !_ignoreOther && loc._intersection;\n\t\t\t\tres = (diff < epsilon\n\t\t\t\t\t\t|| p1 && abs(p1.getLength() - diff) < epsilon)\n\t\t\t\t\t&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar time = this.getTime();\n\t\tif (time != null)\n\t\t\tparts.push('time: ' + f.number(time));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getTime(),\n\t\t\tt2 = inter.getTime(),\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tt1Inside = t1 >= tMin && t1 <= tMax,\n\t\t\tt2Inside = t2 >= tMin && t2 <= tMax;\n\t\tif (t1Inside && t2Inside)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = t1 < tMin ? c2.getPrevious() : c2,\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = t2 < tMin ? c4.getPrevious() : c4;\n\t\tif (t1 > tMax)\n\t\t\tc2 = c2.getNext();\n\t\tif (t2 > tMax)\n\t\t\tc4 = c4.getNext();\n\t\tif (!c1 || !c2 || !c3 || !c4)\n\t\t\treturn false;\n\n\t\tvar offsets = [];\n\n\t\tfunction addOffsets(curve, end) {\n\t\t\tvar v = curve.getValues(),\n\t\t\t\troots = Curve.classify(v).roots || Curve.getPeaks(v),\n\t\t\t\tcount = roots.length,\n\t\t\t\tt = end && count > 1 ? roots[count - 1]\n\t\t\t\t\t\t: count > 0 ? roots[0]\n\t\t\t\t\t\t: 0.5;\n\t\t\toffsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);\n\t\t}\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min || angle < max;\n\t\t}\n\n\t\tif (!t1Inside) {\n\t\t\taddOffsets(c1, true);\n\t\t\taddOffsets(c2, false);\n\t\t}\n\t\tif (!t2Inside) {\n\t\t\taddOffsets(c3, true);\n\t\t\taddOffsets(c4, false);\n\t\t}\n\t\tvar pt = this.getPoint(),\n\t\t\toffset = Math.min.apply(Math, offsets),\n\t\t\tv2 = t1Inside ? c2.getTangentAtTime(t1)\n\t\t\t\t\t: c2.getPointAt(offset).subtract(pt),\n\t\t\tv1 = t1Inside ? v2.negate()\n\t\t\t\t\t: c1.getPointAt(-offset).subtract(pt),\n\t\t\tv4 = t2Inside ? c4.getTangentAtTime(t2)\n\t\t\t\t\t: c4.getPointAt(offset).subtract(pt),\n\t\t\tv3 = t2Inside ? v4.negate()\n\t\t\t\t\t: c3.getPointAt(-offset).subtract(pt),\n\t\t\ta1 = v1.getAngle(),\n\t\t\ta2 = v2.getAngle(),\n\t\t\ta3 = v3.getAngle(),\n\t\t\ta4 = v4.getAngle();\n\t\treturn !!(t1Inside\n\t\t\t\t? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&\n\t\t\t\t  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))\n\t\t\t\t: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&\n\t\t\t\t  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));\n\t},\n\n\thasOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve._evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this.getTime();\n\t\treturn time != null && curve && curve[get](time, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t1e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 !== path2\n\t\t\t\t? path1._id - path2._id\n\t\t\t\t: (loc.getIndex() + loc.getTime())\n\t\t\t\t- (loc2.getIndex() + loc2.getTime());\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\t_selectBounds: false,\n\t_canScaleStroke: true,\n\tbeans: true,\n\n\tinitialize: function PathItem() {\n\t},\n\n\tstatics: {\n\t\tcreate: function(arg) {\n\t\t\tvar data,\n\t\t\t\tsegments,\n\t\t\t\tcompound;\n\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\tsegments = arg.segments;\n\t\t\t\tdata = arg.pathData;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tsegments = arg;\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tdata = arg;\n\t\t\t}\n\t\t\tif (segments) {\n\t\t\t\tvar first = segments[0];\n\t\t\t\tcompound = first && Array.isArray(first[0]);\n\t\t\t} else if (data) {\n\t\t\t\tcompound = (data.match(/m/gi) || []).length > 1\n\t\t\t\t\t\t|| /z\\s*\\S+/i.test(data);\n\t\t\t}\n\t\t\tvar ctor = compound ? CompoundPath : Path;\n\t\t\treturn new ctor(arg);\n\t\t}\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tisClockwise: function() {\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis[move ? 'moveTo' : 'lineTo'](current = getPoint(j));\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\t\tmove = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tcurrent = current.clone();\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(1e-12);\n\t\t\t\tcurrent = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = point.isInside(\n\t\t\t\tthis.getBounds({ internal: true, handle: true }))\n\t\t\t\t\t? this._getWinding(point)\n\t\t\t\t\t: {};\n\t\treturn winding.onPath || !!(this.getFillRule() === 'evenodd'\n\t\t\t\t? winding.windingL & 1 || winding.windingR & 1\n\t\t\t\t: winding.winding);\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix._orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix)._orNullIfIdentity();\n\t\treturn self || this.getBounds(matrix1).intersects(\n\t\t\t\tpath.getBounds(matrix2), 1e-12)\n\t\t\t\t? Curve.getIntersections(\n\t\t\t\t\t\tthis.getCurves(), !self && path.getCurves(), include,\n\t\t\t\t\t\tmatrix1, matrix2, _returnFirst)\n\t\t\t\t: [];\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.hasOverlap() || inter.isCrossing();\n\t\t});\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar isPath = !this._children,\n\t\t\tname = isPath ? '_segments' : '_children',\n\t\t\titemsFrom = from[name],\n\t\t\titemsTo = to[name],\n\t\t\titems = this[name];\n\t\tif (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {\n\t\t\tthrow new Error('Invalid operands in interpolate() call: ' +\n\t\t\t\t\tfrom + ', ' + to);\n\t\t}\n\t\tvar current = items.length,\n\t\t\tlength = itemsTo.length;\n\t\tif (current < length) {\n\t\t\tvar ctor = isPath ? Segment : Path;\n\t\t\tfor (var i = current; i < length; i++) {\n\t\t\t\tthis.add(new ctor());\n\t\t\t}\n\t\t} else if (current > length) {\n\t\t\tthis[isPath ? 'removeSegments' : 'removeChildren'](length, current);\n\t\t}\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titems[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n\t\t}\n\t\tif (isPath) {\n\t\t\tthis.setClosed(from._closed);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tcompare: function(path) {\n\t\tvar ok = false;\n\t\tif (path) {\n\t\t\tvar paths1 = this._children || [this],\n\t\t\t\tpaths2 = path._children ? path._children.slice() : [path],\n\t\t\t\tlength1 = paths1.length,\n\t\t\t\tlength2 = paths2.length,\n\t\t\t\tmatched = [],\n\t\t\t\tcount = 0;\n\t\t\tok = true;\n\t\t\tfor (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {\n\t\t\t\tvar path1 = paths1[i1];\n\t\t\t\tok = false;\n\t\t\t\tfor (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {\n\t\t\t\t\tif (path1.compare(paths2[i2])) {\n\t\t\t\t\t\tif (!matched[i2]) {\n\t\t\t\t\t\t\tmatched[i2] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = ok && count === length2;\n\t\t}\n\t\treturn ok;\n\t},\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar segments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: arguments\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? arguments\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._segmentSelection = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setSegments(source._segments);\n\t\tthis._closed = source._closed;\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tthis._length = this._area = undefined;\n\t\t\tif (flags & 16) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 32) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected(),\n\t\t\tlength = segments && segments.length;\n\t\tthis._segments.length = 0;\n\t\tthis._segmentSelection = 0;\n\t\tthis._curves = undefined;\n\t\tif (length) {\n\t\t\tvar last = segments[length - 1];\n\t\t\tif (typeof last === 'boolean') {\n\t\t\t\tthis.setClosed(last);\n\t\t\t\tlength--;\n\t\t\t}\n\t\t\tthis._add(Segment.readList(segments, 0, {}, length));\n\t\t}\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine) {\n\t\t\t\t\t\tvar dx = curX - prevX,\n\t\t\t\t\t\t\tdy = curY - prevY;\n\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t  dx === 0 ? 'v' + f.number(dy)\n\t\t\t\t\t\t\t: dy === 0 ? 'h' + f.number(dx)\n\t\t\t\t\t\t\t: 'l' + f.pair(dx, dy));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair( inX - prevX,  inY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (!length)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._segments.length;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar segments = this._segments,\n\t\t\tcoords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selection);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tstart = index > 0 && index + amount - 1 === total ? index - 1\n\t\t\t\t\t: index,\n\t\t\t\tinsert = start,\n\t\t\t\tend = Math.min(start + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [start, 0].concat(segs._curves));\n\t\t\t\tinsert += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = insert; i < end; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(start, end);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(start, end) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && !start ? segments.length - 1\n\t\t\t\t: start - 1]) {\n\t\t\tcurve._segment2 = segments[start] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[end]) {\n\t\t\tcurve._segment1 = segments[end];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readList(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readList(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(start, end, _includeCurves) {\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(start, end - start),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, segment._selection, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = start, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = start > 0 && end === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? start - 1\n\t\t\t\t\t: start,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\t\tcurves[i]._path = null;\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tvar area = this._area;\n\t\tif (area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tclosed = this._closed;\n\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar last = i + 1 === l;\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[last ? 0 : i + 1],\n\t\t\t\t\t\tnull, last && !closed));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn area;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this.isSelected() && length > 0 && this._segmentSelection\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelection: function setSelection(selection) {\n\t\tif (!(selection & 1))\n\t\t\tthis._selectSegments(false);\n\t\tsetSelection.base.call(this, selection);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tselection = selected ? 7 : 0;\n\t\tthis._segmentSelection = selection * length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tsegments[i]._selection = selection;\n\t},\n\n\t_updateSelection: function(segment, oldSelection, newSelection) {\n\t\tsegment._selection = newSelection;\n\t\tvar selection = this._segmentSelection += newSelection - oldSelection;\n\t\tif (selection > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tdivideAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tcurve;\n\t\treturn loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))\n\t\t\t\t? curve._segment1\n\t\t\t\t: null;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tindex = loc && loc.index,\n\t\t\ttime = loc && loc.time,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (time > tMax) {\n\t\t\tindex++;\n\t\t\ttime = 0;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (time >= tMin) {\n\t\t\t\tcurves[index++].divideAtTime(time);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.copyAttributes(this);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\tsplit: function(index, time) {\n\t\tvar curve,\n\t\t\tlocation = time === undefined ? index\n\t\t\t\t: (curve = this.getCurves()[index])\n\t\t\t\t\t&& curve.getLocationAtTime(time);\n\t\treturn location != null ? this.splitAt(location) : null;\n\t},\n\n\tjoin: function(path, tolerance) {\n\t\tvar epsilon = tolerance || 0;\n\t\tif (path && path !== this) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.isClose(last2._point, epsilon))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.isClose(first2._point, epsilon)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.isClose(first2._point, epsilon))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.isClose(last2._point, epsilon)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.isClose(last._point, epsilon)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\treduce: function(options) {\n\t\tvar curves = this.getCurves(),\n\t\t\tsimplify = options && options.simplify,\n\t\t\ttolerance = simplify ? 1e-7 : 0;\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (!curve.hasLength(tolerance)\n\t\t\t\t\t|| simplify && curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tthis._changed(9);\n\t},\n\n\tflatten: function(flatness) {\n\t\tvar flattener = new PathFlattener(this, flatness || 0.25, 256, true),\n\t\t\tparts = flattener.parts,\n\t\t\tlength = parts.length,\n\t\t\tsegments = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tsegments.push(new Segment(parts[i].curve.slice(0, 2)));\n\t\t}\n\t\tif (!this._closed && length > 0) {\n\t\t\tsegments.push(new Segment(parts[length - 1].curve.slice(6)));\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tvar segments = new PathFitter(this).fit(tolerance || 2.5);\n\t\tif (segments)\n\t\t\tthis.setSegments(segments);\n\t\treturn !!segments;\n\t},\n\n\tsmooth: function(options) {\n\t\tvar that = this,\n\t\t\topts = options || {},\n\t\t\ttype = opts.type || 'asymmetric',\n\t\t\tsegments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tclosed = this._closed;\n\n\t\tfunction getIndex(value, _default) {\n\t\t\tvar index = value && value.index;\n\t\t\tif (index != null) {\n\t\t\t\tvar path = value.path;\n\t\t\t\tif (path && path !== that)\n\t\t\t\t\tthrow new Error(value._class + ' ' + index + ' of ' + path\n\t\t\t\t\t\t\t+ ' is not part of ' + that);\n\t\t\t\tif (_default && value instanceof Curve)\n\t\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tindex = typeof value === 'number' ? value : _default;\n\t\t\t}\n\t\t\treturn Math.min(index < 0 && closed\n\t\t\t\t\t? index % length\n\t\t\t\t\t: index < 0 ? index + length : index, length - 1);\n\t\t}\n\n\t\tvar loop = closed && opts.from === undefined && opts.to === undefined,\n\t\t\tfrom = getIndex(opts.from, 0),\n\t\t\tto = getIndex(opts.to, length - 1);\n\n\t\tif (from > to) {\n\t\t\tif (closed) {\n\t\t\t\tfrom -= length;\n\t\t\t} else {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t}\n\t\tif (/^(?:asymmetric|continuous)$/.test(type)) {\n\t\t\tvar asymmetric = type === 'asymmetric',\n\t\t\t\tmin = Math.min,\n\t\t\t\tamount = to - from + 1,\n\t\t\t\tn = amount - 1,\n\t\t\t\tpadding = loop ? min(amount, 4) : 1,\n\t\t\t\tpaddingLeft = padding,\n\t\t\t\tpaddingRight = padding,\n\t\t\t\tknots = [];\n\t\t\tif (!closed) {\n\t\t\t\tpaddingLeft = min(1, from);\n\t\t\t\tpaddingRight = min(1, length - to - 1);\n\t\t\t}\n\t\t\tn += paddingLeft + paddingRight;\n\t\t\tif (n <= 1)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {\n\t\t\t\tknots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n\t\t\t}\n\n\t\t\tvar x = knots[0]._x + 2 * knots[1]._x,\n\t\t\t\ty = knots[0]._y + 2 * knots[1]._y,\n\t\t\t\tf = 2,\n\t\t\t\tn_1 = n - 1,\n\t\t\t\trx = [x],\n\t\t\t\try = [y],\n\t\t\t\trf = [f],\n\t\t\t\tpx = [],\n\t\t\t\tpy = [];\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tvar internal = i < n_1,\n\t\t\t\t\ta = internal ? 1 : asymmetric ? 1 : 2,\n\t\t\t\t\tb = internal ? 4 : asymmetric ? 2 : 7,\n\t\t\t\t\tu = internal ? 4 : asymmetric ? 3 : 8,\n\t\t\t\t\tv = internal ? 2 : asymmetric ? 0 : 1,\n\t\t\t\t\tm = a / f;\n\t\t\t\tf = rf[i] = b - m;\n\t\t\t\tx = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n\t\t\t\ty = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n\t\t\t}\n\n\t\t\tpx[n_1] = rx[n_1] / rf[n_1];\n\t\t\tpy[n_1] = ry[n_1] / rf[n_1];\n\t\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\t\tpx[i] = (rx[i] - px[i + 1]) / rf[i];\n\t\t\t\tpy[i] = (ry[i] - py[i + 1]) / rf[i];\n\t\t\t}\n\t\t\tpx[n] = (3 * knots[n]._x - px[n_1]) / 2;\n\t\t\tpy[n] = (3 * knots[n]._y - py[n_1]) / 2;\n\n\t\t\tfor (var i = paddingLeft, max = n - paddingRight, j = from;\n\t\t\t\t\ti <= max; i++, j++) {\n\t\t\t\tvar segment = segments[j < 0 ? j + length : j],\n\t\t\t\t\tpt = segment._point,\n\t\t\t\t\thx = px[i] - pt._x,\n\t\t\t\t\thy = py[i] - pt._y;\n\t\t\t\tif (loop || i < max)\n\t\t\t\t\tsegment.setHandleOut(hx, hy);\n\t\t\t\tif (loop || i > paddingLeft)\n\t\t\t\t\tsegment.setHandleIn(-hx, -hy);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = from; i <= to; i++) {\n\t\t\t\tsegments[i < 0 ? i + length : i].smooth(opts,\n\t\t\t\t\t\t!loop && i === from, !loop && i === to);\n\t\t\t}\n\t\t}\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t});\n\t\t\tshape.copyAttributes(this, true);\n\t\t\tshape._matrix.prepend(this._matrix);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\tif (insert === undefined || insert)\n\t\t\t\tshape.insertAbove(this);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\ttoPath: '#clone',\n\n\tcompare: function compare(path) {\n\t\tif (!path || path instanceof CompoundPath)\n\t\t\treturn compare.base.call(this, path);\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = curves2.length;\n\t\tif (!length1 || !length2) {\n\t\t\treturn length1 == length2;\n\t\t}\n\t\tvar v1 = curves1[0].getValues(),\n\t\t\tvalues2 = [],\n\t\t\tpos1 = 0, pos2,\n\t\t\tend1 = 0, end2;\n\t\tfor (var i = 0; i < length2; i++) {\n\t\t\tvar v2 = curves2[i].getValues();\n\t\t\tvalues2.push(v2);\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tpos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n\t\t\t\tend2 = overlaps[0][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar abs = Math.abs,\n\t\t\tepsilon = 1e-8,\n\t\t\tv2 = values2[pos2],\n\t\t\tstart2;\n\t\twhile (v1 && v2) {\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tvar t1 = overlaps[0][0];\n\t\t\t\tif (abs(t1 - end1) < epsilon) {\n\t\t\t\t\tend1 = overlaps[1][0];\n\t\t\t\t\tif (end1 === 1) {\n\t\t\t\t\t\tv1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n\t\t\t\t\t\tend1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = overlaps[0][1];\n\t\t\t\t\tif (abs(t2 - end2) < epsilon) {\n\t\t\t\t\t\tif (!start2)\n\t\t\t\t\t\t\tstart2 = [pos2, t2];\n\t\t\t\t\t\tend2 = overlaps[1][1];\n\t\t\t\t\t\tif (end2 === 1) {\n\t\t\t\t\t\t\tif (++pos2 >= length2)\n\t\t\t\t\t\t\t\tpos2 = 0;\n\t\t\t\t\t\t\tv2 = values2[pos2] || curves2[pos2].getValues();\n\t\t\t\t\t\t\tend2 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v1) {\n\t\t\t\t\t\t\treturn start2[0] === pos2 && start2[1] === end2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tstrokeRadius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (strokeRadius !== null) {\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tstrokePadding = strokePadding.add(\n\t\t\t\t\tPath._getStrokePadding(strokeRadius, strokeMatrix));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tvar isJoin = closed || segment._index > 0\n\t\t\t\t\t&& segment._index < numSegments - 1;\n\t\t\tif ((isJoin ? join : cap) === 'round') {\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t} else {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (isJoin) {\n\t\t\t\t\tif (!segment.isSmooth()) {\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius,\n\t\t\t\t\t\t\t   miterLimit, null, strokeMatrix, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t} else if (cap === 'square') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, null,\n\t\t\t\t\t\t\tstrokeMatrix, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (strokeRadius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar time = loc.getTime();\n\t\t\t\tif (time === 0 || time === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point)\n\t\t\t\t\t\t\t<= miterLimit * strokeRadius\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar loc = this.getLocationAt(offset);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset) {\n\t\tif (typeof offset === 'number') {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength()) {\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\t}\n\t\t} else if (offset && offset.getPath && offset.getPath() === this) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn null;\n\t}\n\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tvar half = size / 2,\n\t\t\tcoords = new Array(6),\n\t\t\tpX, pY;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tselection = segment._selection;\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tpX = coords[0];\n\t\t\tpY = coords[1];\n\t\t\tif (selection & 2)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (selection & 4)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (!(selection & 1)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar flattener = new PathFlattener(this, 0.25, 32, false,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = flattener.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\tflattener.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (!segments.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar abs = Math.abs,\n\t\t\t\tsqrt = Math.sqrt,\n\t\t\t\tcurrent = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(arguments);\n\t\t\t} else {\n\t\t\t\tvar radius = Size.read(arguments),\n\t\t\t\t\tisZero = Numerical.isZero;\n\t\t\t\tif (isZero(radius.width) || isZero(radius.height))\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq = x * x,\n\t\t\t\t\tySq = y * y;\n\t\t\t\tvar factor = sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1) * sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar epsilon = 1e-7,\n\t\t\t\text = abs(extent),\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = to,\n\t\t\t\t\tout = null;\n\t\t\t\tif (i < count) {\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t}\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(tolerance) {\n\t\t\tthis.setClosed(true);\n\t\t\tthis.join(this, tolerance);\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(matrix, options) {\n\t\tvar method = options.handle\n\t\t\t\t? 'getHandleBounds'\n\t\t\t\t: options.stroke\n\t\t\t\t? 'getStrokeBounds'\n\t\t\t\t: 'getBounds';\n\t\treturn Path[method](this._segments, this._closed, this, matrix, options);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, path, matrix, options, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6)),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = style.hasStroke(),\n\t\t\tstrokeWidth = style.getStrokeWidth(),\n\t\t\tstrokeMatrix = stroke && path._getStrokeMatrix(matrix, options),\n\t\t\tstrokePadding = stroke && Path._getStrokePadding(strokeWidth,\n\t\t\t\tstrokeMatrix),\n\t\t\tbounds = Path.getBounds(segments, closed, path, matrix, options,\n\t\t\t\tstrokePadding);\n\t\tif (!stroke)\n\t\t\treturn bounds;\n\t\tvar strokeRadius = strokeWidth / 2,\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = style.getMiterLimit(),\n\t\t\tjoinBounds = new Rectangle(new Size(strokePadding));\n\n\t\tfunction addPoint(point) {\n\t\t\tbounds = bounds.include(point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(\n\t\t\t\t\tjoinBounds.setCenter(segment._point.transform(matrix)));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tif (join === 'round' || segment.isSmooth()) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius, miterLimit,\n\t\t\t\t\t\tmatrix, strokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, matrix,\n\t\t\t\t\t\tstrokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tvar length = segments.length - (closed ? 0 : 1);\n\t\tfor (var i = 1; i < length; i++)\n\t\t\taddJoin(segments[i], join);\n\t\tif (closed) {\n\t\t\taddJoin(segments[0], join);\n\t\t} else if (length > 0) {\n\t\t\taddCap(segments[0], cap);\n\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getStrokePadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar hor = new Point(radius, 0).transform(matrix),\n\t\t\tver = new Point(0, radius).transform(matrix),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = Math.atan2(b * tan, a),\n\t\t\tty = Math.atan2(b, tan * a);\n\t\treturn [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, matrix,\n\t\t\tstrokeMatrix, addPoint, isArea) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPoint1().transform(matrix),\n\t\t\tnormal1 = curve1.getNormalAtTime(1).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\tnormal2 = curve2.getNormalAtTime(0).multiply(radius)\n\t\t\t\t.transform(strokeMatrix);\n\t\tif (normal1.getDirectedAngle(normal2) < 0) {\n\t\t\tnormal1 = normal1.negate();\n\t\t\tnormal2 = normal2.negate();\n\t\t}\n\t\tif (isArea)\n\t\t\taddPoint(point);\n\t\taddPoint(point.add(normal1));\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(point.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(point.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit * radius) {\n\t\t\t\taddPoint(corner);\n\t\t\t}\n\t\t}\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,\n\t\t\taddPoint, isArea) {\n\t\tvar point = segment._point.transform(matrix),\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal()\n\t\t\t\t\t.multiply(loc.getTime() === 0 ? radius : -radius)\n\t\t\t\t\t.transform(strokeMatrix);\n\t\tif (cap === 'square') {\n\t\t\tif (isArea) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tpoint = point.add(normal.rotate(-90));\n\t\t}\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = options.stroke && style.hasStroke(),\n\t\t\tstrokePadding,\n\t\t\tjoinPadding;\n\t\tif (stroke) {\n\t\t\tvar strokeMatrix = path._getStrokeMatrix(matrix, options),\n\t\t\t\tstrokeRadius = style.getStrokeWidth() / 2,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n\t\t\tstrokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n\t\t\tjoinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n\t\t}\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = !j ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && props.insert == false && Item.NO_INSERT);\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props, { insert: true });\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t], false, arguments);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\tpath = new Path(props && props.insert == false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = sides % 3 === 0,\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\tbeans: true,\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items) {\n\t\tvar list = items,\n\t\t\tfirst = list[0];\n\t\tif (first && typeof first[0] === 'number')\n\t\t\tlist = [list];\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = list[i];\n\t\t\tif (list === items && !(item instanceof Path))\n\t\t\t\tlist = Base.slice(list);\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tlist[i] = new Path({ segments: item, insert: false });\n\t\t\t} else if (item instanceof CompoundPath) {\n\t\t\t\tlist.splice.apply(list, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\treturn insertChildren.base.call(this, index, list);\n\t},\n\n\treduce: function reduce(options) {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce(options);\n\t\t\tif (path.isEmpty())\n\t\t\t\tpath.remove();\n\t\t}\n\t\tif (!children.length) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.copyAttributes(this);\n\t\t\tpath.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClosed: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tif (!children[i]._closed)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].setClosed(closed);\n\t\t}\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t},\n\n\tgetLength: function() {\n\t\tvar children = this._children,\n\t\t\tlength = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tlength += children[i].getLength();\n\t\treturn length;\n\t},\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.appended(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join('');\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\treturn _hitTestChildren.base.call(this, point,\n\t\t\t\toptions.class === Path || options.type === 'path' ? options\n\t\t\t\t\t: Base.set({}, options, { fill: false }),\n\t\t\t\tviewMatrix);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (!children.length)\n\t\t\treturn;\n\n\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\tctx.beginPath();\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectionItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectionItems[child._id]) {\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.appended(mx));\n\t\t\t}\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && !children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\treturn Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',\n\t\t\t'arcBy'],\n\t\tfunction(key) {\n\t\t\tthis[key] = function() {\n\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t};\n\t\t}, {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\n\t\t\tclosePath: function(tolerance) {\n\t\t\t\tgetCurrentPath(this, true).closePath(tolerance);\n\t\t\t}\n\t\t}\n\t);\n}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {\n\tthis[key] = function(param) {\n\t\tvar children = this._children,\n\t\t\tres;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tres = children[i][key](param) || res;\n\t\t}\n\t\treturn res;\n\t};\n}, {}));\n\nPathItem.inject(new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\toperators = {\n\t\t\tunite:     { '1': true, '2': true },\n\t\t\tintersect: { '2': true },\n\t\t\tsubtract:  { '1': true },\n\t\t\texclude:   { '1': true, '-1': true }\n\t\t};\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path.clone(false).reduce({ simplify: true })\n\t\t\t\t.transform(null, true, true);\n\t\treturn resolve\n\t\t\t\t? res.resolveCrossings().reorient(\n\t\t\t\t\tres.getFillRule() === 'nonzero', true)\n\t\t\t\t: res;\n\t}\n\n\tfunction createResult(paths, simplify, path1, path2, options) {\n\t\tvar result = new CompoundPath(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tresult = result.reduce({ simplify: simplify });\n\t\tif (!(options && options.insert == false)) {\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex() ? path2 : path1);\n\t\t}\n\t\tresult.copyAttributes(path1, true);\n\t\treturn result;\n\t}\n\n\tfunction traceBoolean(path1, path2, operation, options) {\n\t\tif (options && (options.trace == false || options.stroke) &&\n\t\t\t\t/^(subtract|intersect)$/.test(operation))\n\t\t\treturn splitBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true),\n\t\t\toperator = operators[operation];\n\t\toperator[operation] = true;\n\t\tif (_path2 && (operator.subtract || operator.exclude)\n\t\t\t\t^ (_path2.isClockwise() ^ _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar crossings = divideLocations(\n\t\t\t\tCurveLocation.expand(_path1.getCrossings(_path2))),\n\t\t\tpaths1 = _path1._children || [_path1],\n\t\t\tpaths2 = _path2 && (_path2._children || [_path2]),\n\t\t\tsegments = [],\n\t\t\tcurves = [],\n\t\t\tpaths;\n\n\t\tfunction collect(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\tcurves.push.apply(curves, path.getCurves());\n\t\t\t\tpath._overlapsOnly = true;\n\t\t\t}\n\t\t}\n\n\t\tif (crossings.length) {\n\t\t\tcollect(paths1);\n\t\t\tif (paths2)\n\t\t\t\tcollect(paths2);\n\t\t\tfor (var i = 0, l = crossings.length; i < l; i++) {\n\t\t\t\tpropagateWinding(crossings[i]._segment, _path1, _path2, curves,\n\t\t\t\t\t\toperator);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i],\n\t\t\t\t\tinter = segment._intersection;\n\t\t\t\tif (!segment._winding) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2, curves, operator);\n\t\t\t\t}\n\t\t\t\tif (!(inter && inter._overlap))\n\t\t\t\t\tsegment._path._overlapsOnly = false;\n\t\t\t}\n\t\t\tpaths = tracePaths(segments, operator);\n\t\t} else {\n\t\t\tpaths = reorientPaths(\n\t\t\t\t\tpaths2 ? paths1.concat(paths2) : paths1.slice(),\n\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\treturn !!operator[w];\n\t\t\t\t\t});\n\t\t}\n\n\t\treturn createResult(paths, true, path1, path2, options);\n\t}\n\n\tfunction splitBoolean(path1, path2, operation) {\n\t\tvar _path1 = preparePath(path1),\n\t\t\t_path2 = preparePath(path2),\n\t\t\tcrossings = _path1.getCrossings(_path2),\n\t\t\tsubtract = operation === 'subtract',\n\t\t\tdivide = operation === 'divide',\n\t\t\tadded = {},\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (!added[path._id] && (divide ||\n\t\t\t\t\t_path2.contains(path.getPointAt(path.getLength() / 2))\n\t\t\t\t\t\t^ subtract)) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn added[path._id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = crossings.length - 1; i >= 0; i--) {\n\t\t\tvar path = crossings[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn createResult(paths, false, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._previous;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._previous)\n\t\t\t\tto = to._previous;\n\t\t\tfrom._next = to;\n\t\t\tto._previous = from;\n\t\t}\n\t}\n\n\tfunction clearCurveHandles(curves) {\n\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\tcurves[i].clearHandles();\n\t}\n\n\tfunction reorientPaths(paths, isInside, clockwise) {\n\t\tvar length = paths && paths.length;\n\t\tif (length) {\n\t\t\tvar lookup = Base.each(paths, function (path, i) {\n\t\t\t\t\tthis[path._id] = {\n\t\t\t\t\t\tcontainer: null,\n\t\t\t\t\t\twinding: path.isClockwise() ? 1 : -1,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t};\n\t\t\t\t}, {}),\n\t\t\t\tsorted = paths.slice().sort(function (a, b) {\n\t\t\t\t\treturn abs(b.getArea()) - abs(a.getArea());\n\t\t\t\t}),\n\t\t\t\tfirst = sorted[0];\n\t\t\tif (clockwise == null)\n\t\t\t\tclockwise = first.isClockwise();\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar path1 = sorted[i],\n\t\t\t\t\tentry1 = lookup[path1._id],\n\t\t\t\t\tpoint = path1.getInteriorPoint(),\n\t\t\t\t\tcontainerWinding = 0;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tvar path2 = sorted[j];\n\t\t\t\t\tif (path2.contains(point)) {\n\t\t\t\t\t\tvar entry2 = lookup[path2._id];\n\t\t\t\t\t\tcontainerWinding = entry2.winding;\n\t\t\t\t\t\tentry1.winding += containerWinding;\n\t\t\t\t\t\tentry1.container = entry2.exclude ? entry2.container\n\t\t\t\t\t\t\t\t: path2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isInside(entry1.winding) === isInside(containerWinding)) {\n\t\t\t\t\tentry1.exclude = true;\n\t\t\t\t\tpaths[entry1.index] = null;\n\t\t\t\t} else {\n\t\t\t\t\tvar container = entry1.container;\n\t\t\t\t\tpath1.setClockwise(container ? !container.isClockwise()\n\t\t\t\t\t\t\t: clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\tfunction divideLocations(locations, include, clearLater) {\n\t\tvar results = include && [],\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tclearHandles = false,\n\t\t\tclearCurves = clearLater || [],\n\t\t\tclearLookup = clearLater && {},\n\t\t\trenormalizeLocs,\n\t\t\tprevCurve,\n\t\t\tprevTime;\n\n\t\tfunction getId(curve) {\n\t\t\treturn curve._path._id + '.' + curve._segment1._index;\n\t\t}\n\n\t\tfor (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {\n\t\t\tvar curve = clearLater[i];\n\t\t\tif (curve._path)\n\t\t\t\tclearLookup[getId(curve)] = true;\n\t\t}\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\ttime = loc._time,\n\t\t\t\torigTime = time,\n\t\t\t\texclude = include && !include(loc),\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tsegment;\n\t\t\tif (curve) {\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tclearHandles = !curve.hasHandles()\n\t\t\t\t\t\t\t|| clearLookup && clearLookup[getId(curve)];\n\t\t\t\t\trenormalizeLocs = [];\n\t\t\t\t\tprevTime = null;\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t} else if (prevTime >= tMin) {\n\t\t\t\t\ttime /= prevTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exclude) {\n\t\t\t\tif (renormalizeLocs)\n\t\t\t\t\trenormalizeLocs.push(loc);\n\t\t\t\tcontinue;\n\t\t\t} else if (include) {\n\t\t\t\tresults.unshift(loc);\n\t\t\t}\n\t\t\tprevTime = origTime;\n\t\t\tif (time < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tvar newCurve = curve.divideAtTime(time, true);\n\t\t\t\tif (clearHandles)\n\t\t\t\t\tclearCurves.push(curve, newCurve);\n\t\t\t\tsegment = newCurve._segment1;\n\t\t\t\tfor (var j = renormalizeLocs.length - 1; j >= 0; j--) {\n\t\t\t\t\tvar l = renormalizeLocs[j];\n\t\t\t\t\tl._time = (l._time - time) / (1 - time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t}\n\t\tif (!clearLater)\n\t\t\tclearCurveHandles(clearCurves);\n\t\treturn results || locations;\n\t}\n\n\tfunction getWinding(point, curves, dir, closed, dontFlip) {\n\t\tvar ia = dir ? 1 : 0,\n\t\t\tio = ia ^ 1,\n\t\t\tpv = [point.x, point.y],\n\t\t\tpa = pv[ia],\n\t\t\tpo = pv[io],\n\t\t\twindingEpsilon = 1e-9,\n\t\t\tqualityEpsilon = 1e-6,\n\t\t\tpaL = pa - windingEpsilon,\n\t\t\tpaR = pa + windingEpsilon,\n\t\t\twindingL = 0,\n\t\t\twindingR = 0,\n\t\t\tpathWindingL = 0,\n\t\t\tpathWindingR = 0,\n\t\t\tonPath = false,\n\t\t\tonAnyPath = false,\n\t\t\tquality = 1,\n\t\t\troots = [],\n\t\t\tvPrev,\n\t\t\tvClose;\n\n\t\tfunction addWinding(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po < min(o0, o3) || po > max(o0, o3)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar a0 = v[ia + 0],\n\t\t\t\ta1 = v[ia + 2],\n\t\t\t\ta2 = v[ia + 4],\n\t\t\t\ta3 = v[ia + 6];\n\t\t\tif (o0 === o3) {\n\t\t\t\tif (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t =   po === o0 ? 0\n\t\t\t\t\t: po === o3 ? 1\n\t\t\t\t\t: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Curve.solveCubic(v, io, po, roots, 0, 1) > 0\n\t\t\t\t\t\t? roots[0]\n\t\t\t\t\t\t: 1,\n\t\t\t\ta =   t === 0 ? a0\n\t\t\t\t\t: t === 1 ? a3\n\t\t\t\t\t: Curve.getPoint(v, t)[dir ? 'y' : 'x'],\n\t\t\t\twinding = o0 > o3 ? 1 : -1,\n\t\t\t\twindingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,\n\t\t\t\ta3Prev = vPrev[ia + 6];\n\t\t\tif (po !== o0) {\n\t\t\t\tif (a < paL) {\n\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t} else if (a > paR) {\n\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t} else {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\tif (a > pa - qualityEpsilon && a < pa + qualityEpsilon)\n\t\t\t\t\tquality /= 2;\n\t\t\t} else {\n\t\t\t\tif (winding !== windingPrev) {\n\t\t\t\t\tif (a0 < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t} else if (a0 > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t}\n\t\t\t\t} else if (a0 != a3Prev) {\n\t\t\t\t\tif (a3Prev < paR && a > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t} else if (a3Prev > paL && a < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquality = 0;\n\t\t\t}\n\t\t\tvPrev = v;\n\t\t\treturn !dontFlip && a > paL && a < paR\n\t\t\t\t\t&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0\n\t\t\t\t\t&& getWinding(point, curves, !dir, closed, true);\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to1 = v[io + 2],\n\t\t\t\to2 = v[io + 4],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n\t\t\t\tvar a0 = v[ia + 0],\n\t\t\t\t\ta1 = v[ia + 2],\n\t\t\t\t\ta2 = v[ia + 4],\n\t\t\t\t\ta3 = v[ia + 6],\n\t\t\t\t\tmonoCurves = paL > max(a0, a1, a2, a3) ||\n\t\t\t\t\t\t\t\t paR < min(a0, a1, a2, a3)\n\t\t\t\t\t\t\t? [v] : Curve.getMonoCurves(v, dir),\n\t\t\t\t\tres;\n\t\t\t\tfor (var i = 0, l = monoCurves.length; i < l; i++) {\n\t\t\t\t\tif (res = addWinding(monoCurves[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i],\n\t\t\t\tpath = curve._path,\n\t\t\t\tv = curve.getValues(),\n\t\t\t\tres;\n\t\t\tif (!i || curves[i - 1]._path !== path) {\n\t\t\t\tvPrev = null;\n\t\t\t\tif (!path._closed) {\n\t\t\t\t\tvClose = Curve.getValues(\n\t\t\t\t\t\t\tpath.getLastCurve().getSegment2(),\n\t\t\t\t\t\t\tcurve.getSegment1(),\n\t\t\t\t\t\t\tnull, !closed);\n\t\t\t\t\tif (vClose[io] !== vClose[io + 6]) {\n\t\t\t\t\t\tvPrev = vClose;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!vPrev) {\n\t\t\t\t\tvPrev = v;\n\t\t\t\t\tvar prev = path.getLastCurve();\n\t\t\t\t\twhile (prev && prev !== curve) {\n\t\t\t\t\t\tvar v2 = prev.getValues();\n\t\t\t\t\t\tif (v2[io] !== v2[io + 6]) {\n\t\t\t\t\t\t\tvPrev = v2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = prev.getPrevious();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res = handleCurve(v))\n\t\t\t\treturn res;\n\n\t\t\tif (i + 1 === l || curves[i + 1]._path !== path) {\n\t\t\t\tif (vClose && (res = handleCurve(vClose)))\n\t\t\t\t\treturn res;\n\t\t\t\tif (onPath && !pathWindingL && !pathWindingR) {\n\t\t\t\t\tpathWindingL = pathWindingR = path.isClockwise(closed) ^ dir\n\t\t\t\t\t\t\t? 1 : -1;\n\t\t\t\t}\n\t\t\t\twindingL += pathWindingL;\n\t\t\t\twindingR += pathWindingR;\n\t\t\t\tpathWindingL = pathWindingR = 0;\n\t\t\t\tif (onPath) {\n\t\t\t\t\tonAnyPath = true;\n\t\t\t\t\tonPath = false;\n\t\t\t\t}\n\t\t\t\tvClose = null;\n\t\t\t}\n\t\t}\n\t\twindingL = abs(windingL);\n\t\twindingR = abs(windingR);\n\t\treturn {\n\t\t\twinding: max(windingL, windingR),\n\t\t\twindingL: windingL,\n\t\t\twindingR: windingR,\n\t\t\tquality: quality,\n\t\t\tonPath: onAnyPath\n\t\t};\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, curves, operator) {\n\t\tvar chain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twinding;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve(),\n\t\t\t\tlength = curve.getLength();\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\ttotalLength += length;\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tvar offsets = [0.5, 0.25, 0.75],\n\t\t\twinding = { winding: 0, quality: -1 },\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tfor (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {\n\t\t\tvar length = totalLength * offsets[i];\n\t\t\tfor (var j = 0, l = chain.length; j < l; j++) {\n\t\t\t\tvar entry = chain[j],\n\t\t\t\t\tcurveLength = entry.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tvar curve = entry.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\toperand = parent instanceof CompoundPath ? parent : path,\n\t\t\t\t\t\tt = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),\n\t\t\t\t\t\tpt = curve.getPointAtTime(t),\n\t\t\t\t\t\tdir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n\t\t\t\t\tvar wind = !(operator.subtract && path2 && (\n\t\t\t\t\t\t\toperand === path1 &&\n\t\t\t\t\t\t\t\tpath2._getWinding(pt, dir, true).winding ||\n\t\t\t\t\t\t\toperand === path2 &&\n\t\t\t\t\t\t\t\t!path1._getWinding(pt, dir, true).winding))\n\t\t\t\t\t\t\t? getWinding(pt, curves, dir, true)\n\t\t\t\t\t\t\t: { winding: 0, quality: 1 };\n\t\t\t\t\tif (wind.quality > winding.quality)\n\t\t\t\t\t\twinding = wind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tfor (var j = chain.length - 1; j >= 0; j--) {\n\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t}\n\n\tfunction tracePaths(segments, operator) {\n\t\tvar paths = [],\n\t\t\tstarts;\n\n\t\tfunction isValid(seg) {\n\t\t\tvar winding;\n\t\t\treturn !!(seg && !seg._visited && (!operator\n\t\t\t\t\t|| operator[(winding = seg._winding || {}).winding]\n\t\t\t\t\t\t&& !(operator.unite && winding.winding === 2\n\t\t\t\t\t\t\t&& winding.windingL && winding.windingR)));\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\tif (seg) {\n\t\t\t\tfor (var i = 0, l = starts.length; i < l; i++) {\n\t\t\t\t\tif (seg === starts[i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction visitPath(path) {\n\t\t\tvar segments = path._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._visited = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCrossingSegments(segment, collectStarts) {\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tstart = inter,\n\t\t\t\tcrossings = [];\n\t\t\tif (collectStarts)\n\t\t\t\tstarts = [segment];\n\n\t\t\tfunction collect(inter, end) {\n\t\t\t\twhile (inter && inter !== end) {\n\t\t\t\t\tvar other = inter._segment,\n\t\t\t\t\t\tpath = other._path,\n\t\t\t\t\t\tnext = other.getNext() || path && path.getFirstSegment(),\n\t\t\t\t\t\tnextInter = next && next._intersection;\n\t\t\t\t\tif (other !== segment && (isStart(other) || isStart(next)\n\t\t\t\t\t\t|| next && (isValid(other) && (isValid(next)\n\t\t\t\t\t\t\t|| nextInter && isValid(nextInter._segment))))) {\n\t\t\t\t\t\tcrossings.push(other);\n\t\t\t\t\t}\n\t\t\t\t\tif (collectStarts)\n\t\t\t\t\t\tstarts.push(other);\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inter) {\n\t\t\t\tcollect(inter);\n\t\t\t\twhile (inter && inter._prev)\n\t\t\t\t\tinter = inter._prev;\n\t\t\t\tcollect(inter, start);\n\t\t\t}\n\t\t\treturn crossings;\n\t\t}\n\n\t\tsegments.sort(function(seg1, seg2) {\n\t\t\tvar inter1 = seg1._intersection,\n\t\t\t\tinter2 = seg2._intersection,\n\t\t\t\tover1 = !!(inter1 && inter1._overlap),\n\t\t\t\tover2 = !!(inter2 && inter2._overlap),\n\t\t\t\tpath1 = seg1._path,\n\t\t\t\tpath2 = seg2._path;\n\t\t\treturn over1 ^ over2\n\t\t\t\t\t? over1 ? 1 : -1\n\t\t\t\t\t: !inter1 ^ !inter2\n\t\t\t\t\t\t? inter1 ? 1 : -1\n\t\t\t\t\t\t: path1 !== path2\n\t\t\t\t\t\t\t? path1._id - path2._id\n\t\t\t\t\t\t\t: seg1._index - seg2._index;\n\t\t});\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tvalid = isValid(seg),\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false,\n\t\t\t\tclosed = true,\n\t\t\t\tbranches = [],\n\t\t\t\tbranch,\n\t\t\t\tvisited,\n\t\t\t\thandleIn;\n\t\t\tif (valid && seg._path._overlapsOnly) {\n\t\t\t\tvar path1 = seg._path,\n\t\t\t\t\tpath2 = seg._intersection._segment._path;\n\t\t\t\tif (path1.compare(path2)) {\n\t\t\t\t\tif (path1.getArea())\n\t\t\t\t\t\tpaths.push(path1.clone(false));\n\t\t\t\t\tvisitPath(path1);\n\t\t\t\t\tvisitPath(path2);\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (valid) {\n\t\t\t\tvar first = !path,\n\t\t\t\t\tcrossings = getCrossingSegments(seg, first),\n\t\t\t\t\tother = crossings.shift(),\n\t\t\t\t\tfinished = !first && (isStart(seg) || isStart(other)),\n\t\t\t\t\tcross = !finished && other;\n\t\t\t\tif (first) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tif (seg.isFirst() || seg.isLast())\n\t\t\t\t\t\tclosed = seg._path._closed;\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cross && branch) {\n\t\t\t\t\tbranches.push(branch);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (!branch) {\n\t\t\t\t\tif (cross)\n\t\t\t\t\t\tcrossings.push(seg);\n\t\t\t\t\tbranch = {\n\t\t\t\t\t\tstart: path._segments.length,\n\t\t\t\t\t\tcrossings: crossings,\n\t\t\t\t\t\tvisited: visited = [],\n\t\t\t\t\t\thandleIn: handleIn\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (cross)\n\t\t\t\t\tseg = other;\n\t\t\t\tif (!isValid(seg)) {\n\t\t\t\t\tpath.removeSegments(branch.start);\n\t\t\t\t\tfor (var j = 0, k = visited.length; j < k; j++) {\n\t\t\t\t\t\tvisited[j]._visited = false;\n\t\t\t\t\t}\n\t\t\t\t\tvisited.length = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tseg = branch && branch.crossings.shift();\n\t\t\t\t\t\tif (!seg) {\n\t\t\t\t\t\t\tbranch = branches.pop();\n\t\t\t\t\t\t\tif (branch) {\n\t\t\t\t\t\t\t\tvisited = branch.visited;\n\t\t\t\t\t\t\t\thandleIn = branch.handleIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (branch && !isValid(seg));\n\t\t\t\t\tif (!seg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar next = seg.getNext();\n\t\t\t\tpath.add(new Segment(seg._point, handleIn,\n\t\t\t\t\t\tnext && seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tvisited.push(seg);\n\t\t\t\tseg = next || seg._path.getFirstSegment();\n\t\t\t\thandleIn = next && next._handleIn;\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(handleIn);\n\t\t\t\t\tpath.setClosed(closed);\n\t\t\t\t}\n\t\t\t\tif (path.getArea() !== 0) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, dir, closed) {\n\t\t\treturn getWinding(point, this.getCurves(), dir, closed);\n\t\t},\n\n\t\tunite: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'unite', options);\n\t\t},\n\n\t\tintersect: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'intersect', options);\n\t\t},\n\n\t\tsubtract: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'subtract', options);\n\t\t},\n\n\t\texclude: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'exclude', options);\n\t\t},\n\n\t\tdivide: function(path, options) {\n\t\t\treturn options && (options.trace == false || options.stroke)\n\t\t\t\t\t? splitBoolean(this, path, 'divide')\n\t\t\t\t\t: createResult([\n\t\t\t\t\t\tthis.subtract(path, options),\n\t\t\t\t\t\tthis.intersect(path, options)\n\t\t\t\t\t], true, this, path, options);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = children || [this];\n\n\t\t\tfunction hasOverlap(seg) {\n\t\t\t\tvar inter = seg && seg._intersection;\n\t\t\t\treturn inter && inter._overlap;\n\t\t\t}\n\n\t\t\tvar hasOverlaps = false,\n\t\t\t\thasCrossings = false,\n\t\t\t\tintersections = this.getIntersections(null, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap() && (hasOverlaps = true) ||\n\t\t\t\t\t\t\tinter.isCrossing() && (hasCrossings = true);\n\t\t\t\t}),\n\t\t\t\tclearCurves = hasOverlaps && hasCrossings && [];\n\t\t\tintersections = CurveLocation.expand(intersections);\n\t\t\tif (hasOverlaps) {\n\t\t\t\tvar overlaps = divideLocations(intersections, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap();\n\t\t\t\t}, clearCurves);\n\t\t\t\tfor (var i = overlaps.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar seg = overlaps[i]._segment,\n\t\t\t\t\t\tprev = seg.getPrevious(),\n\t\t\t\t\t\tnext = seg.getNext();\n\t\t\t\t\tif (hasOverlap(prev) && hasOverlap(next)) {\n\t\t\t\t\t\tseg.remove();\n\t\t\t\t\t\tprev._handleOut._set(0, 0);\n\t\t\t\t\t\tnext._handleIn._set(0, 0);\n\t\t\t\t\t\tif (prev !== seg && !prev.getCurve().hasLength()) {\n\t\t\t\t\t\t\tnext._handleIn.set(prev._handleIn);\n\t\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCrossings) {\n\t\t\t\tdivideLocations(intersections, hasOverlaps && function(inter) {\n\t\t\t\t\tvar curve1 = inter.getCurve(),\n\t\t\t\t\t\tseg1 = inter.getSegment(),\n\t\t\t\t\t\tother = inter._intersection,\n\t\t\t\t\t\tcurve2 = other._curve,\n\t\t\t\t\t\tseg2 = other._segment;\n\t\t\t\t\tif (curve1 && curve2 && curve1._path && curve2._path)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (seg1)\n\t\t\t\t\t\tseg1._intersection = null;\n\t\t\t\t\tif (seg2)\n\t\t\t\t\t\tseg2._intersection = null;\n\t\t\t\t}, clearCurves);\n\t\t\t\tif (clearCurves)\n\t\t\t\t\tclearCurveHandles(clearCurves);\n\t\t\t\tpaths = tracePaths(Base.each(paths, function(path) {\n\t\t\t\t\tthis.push.apply(this, path._segments);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\tvar length = paths.length,\n\t\t\t\titem;\n\t\t\tif (length > 1 && children) {\n\t\t\t\tif (paths !== children)\n\t\t\t\t\tthis.setChildren(paths);\n\t\t\t\titem = this;\n\t\t\t} else if (length === 1 && !children) {\n\t\t\t\tif (paths[0] !== this)\n\t\t\t\t\tthis.setSegments(paths[0].removeSegments());\n\t\t\t\titem = this;\n\t\t\t}\n\t\t\tif (!item) {\n\t\t\t\titem = new CompoundPath(Item.NO_INSERT);\n\t\t\t\titem.addChildren(paths);\n\t\t\t\titem = item.reduce();\n\t\t\t\titem.copyAttributes(this);\n\t\t\t\tthis.replaceWith(item);\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\n\t\treorient: function(nonZero, clockwise) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && children.length) {\n\t\t\t\tthis.setChildren(reorientPaths(this.removeChildren(),\n\t\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\t\treturn !!(nonZero ? w : w & 1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclockwise));\n\t\t\t} else if (clockwise !== undefined) {\n\t\t\t\tthis.setClockwise(clockwise);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\ty = point.y,\n\t\t\t\t\tintercepts = [],\n\t\t\t\t\troots = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar v = curves[i].getValues(),\n\t\t\t\t\t\to0 = v[1],\n\t\t\t\t\t\to1 = v[3],\n\t\t\t\t\t\to2 = v[5],\n\t\t\t\t\t\to3 = v[7];\n\t\t\t\t\tif (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n\t\t\t\t\t\tvar monoCurves = Curve.getMonoCurves(v);\n\t\t\t\t\t\tfor (var j = 0, m = monoCurves.length; j < m; j++) {\n\t\t\t\t\t\t\tvar mv = monoCurves[j],\n\t\t\t\t\t\t\t\tmo0 = mv[1],\n\t\t\t\t\t\t\t\tmo3 = mv[7];\n\t\t\t\t\t\t\tif ((mo0 !== mo3) &&\n\t\t\t\t\t\t\t\t(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){\n\t\t\t\t\t\t\t\tvar x = y === mo0 ? mv[0]\n\t\t\t\t\t\t\t\t\t: y === mo3 ? mv[6]\n\t\t\t\t\t\t\t\t\t: Curve.solveCubic(mv, 1, y, roots, 0, 1)\n\t\t\t\t\t\t\t\t\t\t=== 1\n\t\t\t\t\t\t\t\t\t\t? Curve.getPoint(mv, roots[0]).x\n\t\t\t\t\t\t\t\t\t\t: (mv[0] + mv[6]) / 2;\n\t\t\t\t\t\t\t\tintercepts.push(x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (intercepts.length > 1) {\n\t\t\t\t\tintercepts.sort(function(a, b) { return a - b; });\n\t\t\t\t\tpoint.x = (intercepts[0] + intercepts[1]) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point;\n\t\t}\n\t};\n});\n\nvar PathFlattener = Base.extend({\n\t_class: 'PathFlattener',\n\n\tinitialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminSpan = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, t1, t2) {\n\t\t\tif ((t2 - t1) > minSpan\n\t\t\t\t\t&& !(ignoreStraight && Curve.isStraight(curve))\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, flatness || 0.25)) {\n\t\t\t\tvar halves = Curve.subdivide(curve, 0.5),\n\t\t\t\t\ttMid = (t1 + t2) / 2;\n\t\t\t\tcomputeParts(halves[0], index, t1, tMid);\n\t\t\t\tcomputeParts(halves[1], index, tMid, t2);\n\t\t\t} else {\n\t\t\t\tvar dx = curve[6] - curve[0],\n\t\t\t\t\tdy = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tif (dist > 0) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tcurve: curve,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttime: t2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\t_get: function(offset) {\n\t\tvar parts = this.parts,\n\t\t\tlength = parts.length,\n\t\t\tstart,\n\t\t\ti, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (!j || parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\tvar part = parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = parts[i - 1],\n\t\t\t\t\tprevTime = prev && prev.index === part.index ? prev.time : 0,\n\t\t\t\t\tprevOffset = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tindex: part.index,\n\t\t\t\t\ttime: prevTime + (part.time - prevTime)\n\t\t\t\t\t\t* (offset - prevOffset) / (part.offset - prevOffset)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tindex: parts[length - 1].index,\n\t\t\ttime: 1\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tvar start = this._get(from),\n\t\t\tend = this._get(to);\n\t\tfor (var i = start.index, l = end.index; i <= l; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti === start.index ? start.time : 0,\n\t\t\t\t\ti === end.index ? end.time : 1);\n\t\t\tif (i === start.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar param = this._get(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.time);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tclosed = path._closed;\n\t\tfor (var i = 0, prev, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point;\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(prev = point.clone());\n\t\t\t}\n\t\t}\n\t\tif (closed) {\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\t\tthis.closed = closed;\n\t},\n\n\tfit: function(error) {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = null;\n\t\tif (length > 0) {\n\t\t\tsegments = [new Segment(points[0])];\n\t\t\tif (length > 1) {\n\t\t\t\tthis.fitCubic(segments, error, 0, length - 1,\n\t\t\t\t\t\tpoints[1].subtract(points[0]),\n\t\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]));\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tsegments.shift();\n\t\t\t\t\tsegments.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(segments, error, first, last, tan1, tan2) {\n\t\tvar points = this.points;\n\t\tif (last - first === 1) {\n\t\t\tvar pt1 = points[first],\n\t\t\t\tpt2 = points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(error, error * error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < error && parametersInOrder) {\n\t\t\t\tthis.addCurve(segments, curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar tanCenter = points[split - 1].subtract(points[split + 1]);\n\t\tthis.fitCubic(segments, error, first, split, tan1, tanCenter);\n\t\tthis.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(segments, curve) {\n\t\tvar prev = segments[segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tsegments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tabs = Math.abs,\n\t\t\tpoints = this.points,\n\t\t\tpt1 = points[first],\n\t\t\tpt2 = points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1,\n\t\t\talpha2;\n\t\tif (abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\talpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0\n\t\t\t\t\t\t\t: abs(c1) > epsilon ? X[1] / c1\n\t\t\t\t\t\t\t: 0;\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1,\n\t\t\t\tpt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)),\n\t\t\t\tpt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\treturn Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsOptions: { stroke: false, handle: false },\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setContent(source._content);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(265);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\tvar lines = this._lines,\n\t\t\tstyle = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar rect = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(rect, rect) : rect;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tcolorCache = {},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tcomponents = [0, 0, 0];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\tcomponents = match[1].split(',');\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar value = +components[i];\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t}\n\t\t} else if (window) {\n\t\t\tvar cached = colorCache[string];\n\t\t\tif (!cached) {\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\tdata[2] / 255\n\t\t\t\t];\n\t\t\t}\n\t\t\tcomponents = cached.slice();\n\t\t} else {\n\t\t\tcomponents = [0, 0, 0];\n\t\t}\n\t\treturn components;\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t? function(value) {\n\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t};\n\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar args = arguments,\n\t\t\t\treading = this.__read,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (reading)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = Base.slice(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (reading) {\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = Base.slice(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && !i && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (reading && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (reading)\n\t\t\t\tthis.__read = read;\n\t\t\treturn this;\n\t\t},\n\n\t\tset: '#initialize',\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this.getAlpha() === col.getAlpha()\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx, matrix) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\thighlight = components[3],\n\t\t\t\tinverse = matrix && matrix.inverted(),\n\t\t\t\tcanvasGradient;\n\t\t\tif (inverse) {\n\t\t\t\torigin = inverse._transformPoint(origin);\n\t\t\t\tdestination = inverse._transformPoint(destination);\n\t\t\t\tif (highlight)\n\t\t\t\t\thighlight = inverse._transformPoint(highlight);\n\t\t\t}\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin);\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tcanvasGradient.addColorStop(\n\t\t\t\t\t\toffset == null ? i / (l - 1) : offset,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && Base.isPlainObject(stops)) {\n\t\t\tthis.set(stops);\n\t\t\tstops = radial = null;\n\t\t}\n\t\tif (this._stops == null) {\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t}\n\t\tif (this._radial == null) {\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t\t}\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++) {\n\t\t\tthis._owners[i]._changed();\n\t\t}\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (!this._owners.length)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tstops[i] = this._stops[i].clone();\n\t\t}\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t}\n\t\tvar _stops = this._stops;\n\t\tif (_stops) {\n\t\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t\t_stops[i]._owner = undefined;\n\t\t}\n\t\t_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t_stops[i]._owner = this;\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class) {\n\t\t\tvar stops1 = this._stops,\n\t\t\t\tstops2 = gradient._stops,\n\t\t\t\tlength = stops1.length;\n\t\t\tif (length === stops2.length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (!stops1[i].equals(stops2[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tvar color = arg0,\n\t\t\toffset = arg1;\n\t\tif (typeof arg0 === 'object' && arg1 === undefined) {\n\t\t\tif (Array.isArray(arg0) && typeof arg0[0] !== 'number') {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\toffset = arg0[1];\n\t\t\t} else if ('color' in arg0 || 'offset' in arg0\n\t\t\t\t\t|| 'rampPoint' in arg0) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\toffset = arg0.offset || arg0.rampPoint || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setColor(color);\n\t\tthis.setOffset(offset);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._offset);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar color = this._color,\n\t\t\toffset = this._offset;\n\t\treturn Base.serialize(offset == null ? [color] : [color, offset],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(65);\n\t},\n\n\tgetOffset: function() {\n\t\treturn this._offset;\n\t},\n\n\tsetOffset: function(offset) {\n\t\tthis._offset = offset;\n\t\tthis._changed();\n\t},\n\n\tgetRampPoint: '#getOffset',\n\tsetRampPoint: '#setOffset',\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function() {\n\t\tvar color = Color.read(arguments, 0, { clone: true });\n\t\tif (color)\n\t\t\tcolor._owner = this;\n\t\tthis._color = color;\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._offset == stop._offset\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar itemDefaults = {\n\t\tfillColor: null,\n\t\tfillRule: 'nonzero',\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\tshadowColor: null,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: null\n\t},\n\tgroupDefaults = Base.set({}, itemDefaults, {\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tleading: null,\n\t\tjustification: 'left'\n\t}),\n\ttextDefaults = Base.set({}, groupDefaults, {\n\t\tfillColor: new Color()\n\t}),\n\tflags = {\n\t\tstrokeWidth: 97,\n\t\tstrokeCap: 97,\n\t\tstrokeJoin: 97,\n\t\tstrokeScaling: 105,\n\t\tmiterLimit: 97,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t},\n\titem = {\n\t\tbeans: true\n\t},\n\tfields = {\n\t\t_class: 'Style',\n\t\tbeans: true,\n\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project\n\t\t\t\t\t|| paper.project;\n\t\t\tthis._defaults = !_owner || _owner instanceof Group ? groupDefaults\n\t\t\t\t\t: _owner instanceof TextItem ? textDefaults\n\t\t\t\t\t: itemDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t}\n\t};\n\n\tBase.each(groupDefaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children;\n\t\t\tif (children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t} else if (key in this._defaults) {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old && old._owner !== undefined)\n\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tvalue;\n\t\t\tif (key in this._defaults && (!children || !children.length\n\t\t\t\t\t|| _dontMerge || owner instanceof CompoundPath)) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tBase.each({\n\t\tFont: 'FontFamily',\n\t\tWindingRule: 'FillRule'\n\t}, function(value, key) {\n\t\tvar get = 'get' + key,\n\t\t\tset = 'set' + key;\n\t\tfields[get] = item[get] = '#get' + value;\n\t\tfields[set] = item[set] = '#set' + value;\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\tfunction compare(style1, style2, secondary) {\n\t\t\tvar values1 = style1._values,\n\t\t\t\tvalues2 = style2._values,\n\t\t\t\tdefaults2 = style2._defaults;\n\t\t\tfor (var key in values1) {\n\t\t\t\tvar value1 = values1[key],\n\t\t\t\t\tvalue2 = values2[key];\n\t\t\t\tif (!(secondary && key in values2) && !Base.equals(value1,\n\t\t\t\t\t\tvalue2 === undefined ? defaults2[key] : value2))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& compare(this, style)\n\t\t\t\t&& compare(style, this, true)\n\t\t\t\t|| false;\n\t},\n\n\thasFill: function() {\n\t\tvar color = this.getFillColor();\n\t\treturn !!color && color.alpha > 0;\n\t},\n\n\thasStroke: function() {\n\t\tvar color = this.getStrokeColor();\n\t\treturn !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\tvar color = this.getShadowColor();\n\t\treturn !!color && color.alpha > 0 && (this.getShadowBlur() > 0\n\t\t\t\t|| !this.getShadowOffset().isZero());\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tisInserted: function(el) {\n\t\t\treturn document.body.contains(el);\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn el && handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\ttimer;\n\n\tfunction handleCallbacks() {\n\t\tvar functions = callbacks;\n\t\tcallbacks = [];\n\t\tfor (var i = 0, l = functions.length; i < l; i++)\n\t\t\tfunctions[i]();\n\t\trequested = nativeRequest && callbacks.length;\n\t\tif (requested)\n\t\t\tnativeRequest(handleCallbacks);\n\t}\n\n\treturn function(callback) {\n\t\tcallbacks.push(callback);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t}\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t}\n\n\t\tvar size;\n\t\tif (window && element) {\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserDrag: none,\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsize = getCanvasSize();\n\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = new Size(element);\n\t\t\telement = null;\n\t\t}\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window && window.devicePixelRatio || 1;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize = size;\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t\tthis._itemEvents = { native: {}, virtual: {} };\n\t\tthis._autoUpdate = !paper.agent.node;\n\t\tthis._needsUpdate = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tvar project = this._project;\n\t\tif (project._view === this)\n\t\t\tproject._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(\n\t\tItem._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),\n\t\tfunction(name) {\n\t\t\tthis[name] = {};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\tgetAutoUpdate: function() {\n\t\treturn this._autoUpdate;\n\t},\n\n\tsetAutoUpdate: function(autoUpdate) {\n\t\tthis._autoUpdate = autoUpdate;\n\t\tif (autoUpdate)\n\t\t\tthis.requestUpdate();\n\t},\n\n\tupdate: function() {\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\trequestUpdate: function() {\n\t\tif (!this._requested) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (that._animate) {\n\t\t\t\t\tthat.requestUpdate();\n\t\t\t\t\tvar element = that._element;\n\t\t\t\t\tif ((!DomElement.getPrefixed(document, 'hidden')\n\t\t\t\t\t\t\t|| PaperScope.getAttribute(element, 'keepalive')\n\t\t\t\t\t\t\t\t=== 'true') && DomElement.isInView(element)) {\n\t\t\t\t\t\tthat._handleFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (that._autoUpdate)\n\t\t\t\t\tthat.update();\n\t\t\t});\n\t\t\tthis._requested = true;\n\t\t}\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tthis.requestUpdate();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._last ? now - this._last : 0;\n\t\tthis._last = now;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tthis._project._changed(2049);\n\t\tthis._bounds = this._decomposed = undefined;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize.set(size);\n\t\tthis._changed();\n\t\tthis.emit('resize', { size: size, delta: delta });\n\t\tif (this._autoUpdate) {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_setElementSize: function(width, height) {\n\t\tvar element = this._element;\n\t\tif (element) {\n\t\t\tif (element.width !== width)\n\t\t\t\telement.width = width;\n\t\t\tif (element.height !== height)\n\t\t\t\telement.height = height;\n\t\t}\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tisInserted: function() {\n\t\treturn DomElement.isInserted(this._element);\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixels;\n\t\tif (element) {\n\t\t\tvar parent = element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tpixels = parseFloat(pixels);\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\treturn 0;\n\t}\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getCenter(true)));\n\t};\n}, {\n\t_decompose: function() {\n\t\treturn this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.translate(this.getCenter().subtract(center));\n\t},\n\n\tgetZoom: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling ? (scaling.x + scaling.y) / 2 : 0;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis.transform(new Matrix().scale(zoom / this.getZoom(),\n\t\t\tthis.getCenter()));\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed && decomposed.rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tthis.rotate(rotation - current);\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling\n\t\t\t\t? new LinkedPoint(scaling.x, scaling.y, this, 'setScaling')\n\t\t\t\t: undefined;\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling) {\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._matrix.append(matrix);\n\t},\n\n\tscrollBy: function() {\n\t\tthis.translate(Point.read(arguments).negate());\n\t}\n}), {\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tgetEventPoint: function(event) {\n\t\treturn this.viewToProject(DomEvent.getOffset(event, this._element));\n\t},\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (document && typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\tvar ctor = window ? CanvasView : View;\n\t\t\treturn new ctor(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tif (!window)\n\t\treturn;\n\tvar prevFocus,\n\t\ttempFocus,\n\t\tdragging = false,\n\t\tmouseDown = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[\n\t\t\t\ttarget.getAttribute('id')];\n\t}\n\n\tfunction updateFocus() {\n\t\tvar view = View._focused;\n\t\tif (!view || !view.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tif ((view = View._views[i]).isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, event, point) {\n\t\tview._handleMouseEvent('mousemove', event, point);\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {},\n\t\tdocEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML')) {\n\t\t\t\t\tvar offset = DomEvent.getOffset(event, view._element),\n\t\t\t\t\t\tx = offset.x,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\tax = abs(x),\n\t\t\t\t\t\tmax = 1 << 25,\n\t\t\t\t\t\tdiff = ax - max;\n\t\t\t\t\toffset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n\t\t\t\t\thandleMouseMove(view, event, view.viewToProject(offset));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tscroll: updateFocus\n\t\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event);\n\t\tif (!dragging) {\n\t\t\tdragging = true;\n\t\t\tview._handleMouseEvent('mousedown', event);\n\t\t}\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!mouseDown) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target) {\n\t\t\t\t\tif (view)\n\t\t\t\t\t\thandleMouseMove(view, event);\n\t\t\t\t\tif (!prevFocus)\n\t\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t}\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tif (prevFocus && !prevFocus.isInserted())\n\t\t\t\t\tprevFocus = null;\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tprevFocus = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view)\n\t\t\thandleMouseMove(view, event);\n\t};\n\n\tdocEvents[mousedown] = function() {\n\t\tmouseDown = true;\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (view && dragging)\n\t\t\tview._handleMouseEvent('mouseup', event);\n\t\tmouseDown = dragging = false;\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar called = false,\n\t\tprevented = false,\n\t\tfallbacks = {\n\t\t\tdoubleclick: 'click',\n\t\t\tmousedrag: 'mousemove'\n\t\t},\n\t\twasInView = false,\n\t\toverView,\n\t\tdownPoint,\n\t\tlastPoint,\n\t\tdownItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tclickItem,\n\t\tclickTime,\n\t\tdblClick;\n\n\tfunction emitMouseEvent(obj, target, type, event, point, prevPoint,\n\t\t\tstopItem) {\n\t\tvar stopped = false,\n\t\t\tmouseEvent;\n\n\t\tfunction emit(obj, type) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point,\n\t\t\t\t\t\t\ttarget || obj,\n\t\t\t\t\t\t\tprevPoint ? point.subtract(prevPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent)) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif (mouseEvent.prevented)\n\t\t\t\t\t\tprevented = true;\n\t\t\t\t\tif (mouseEvent.stopped)\n\t\t\t\t\t\treturn stopped = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar fallback = fallbacks[type];\n\t\t\t\tif (fallback)\n\t\t\t\t\treturn emit(obj, fallback);\n\t\t\t}\n\t\t}\n\n\t\twhile (obj && obj !== stopItem) {\n\t\t\tif (emit(obj, type))\n\t\t\t\tbreak;\n\t\t\tobj = obj._parent;\n\t\t}\n\t\treturn stopped;\n\t}\n\n\tfunction emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n\t\tview._project.removeOn(type);\n\t\tprevented = called = false;\n\t\treturn (dragItem && emitMouseEvent(dragItem, null, type, event,\n\t\t\t\t\tpoint, prevPoint)\n\t\t\t|| hitItem && hitItem !== dragItem\n\t\t\t\t&& !hitItem.isDescendant(dragItem)\n\t\t\t\t&& emitMouseEvent(hitItem, null, type, event, point, prevPoint,\n\t\t\t\t\tdragItem)\n\t\t\t|| emitMouseEvent(view, dragItem || hitItem || view, type, event,\n\t\t\t\t\tpoint, prevPoint));\n\t}\n\n\tvar itemEventsMap = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleMouseEvent: function(type, event, point) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\thitItems = itemEvents.native[type],\n\t\t\t\tnativeMove = type === 'mousemove',\n\t\t\t\ttool = this._scope.tool,\n\t\t\t\tview = this;\n\n\t\t\tfunction responds(type) {\n\t\t\t\treturn itemEvents.virtual[type] || view.responds(type)\n\t\t\t\t\t\t|| tool && tool.responds(type);\n\t\t\t}\n\n\t\t\tif (nativeMove && dragging && responds('mousedrag'))\n\t\t\t\ttype = 'mousedrag';\n\t\t\tif (!point)\n\t\t\t\tpoint = this.getEventPoint(event);\n\n\t\t\tvar inView = this.getBounds().contains(point),\n\t\t\t\thit = hitItems && inView && view._project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\thitItem = hit && hit.item || null,\n\t\t\t\thandle = false,\n\t\t\t\tmouse = {};\n\t\t\tmouse[type.substr(5)] = true;\n\n\t\t\tif (hitItems && hitItem !== overItem) {\n\t\t\t\tif (overItem) {\n\t\t\t\t\temitMouseEvent(overItem, null, 'mouseleave', event, point);\n\t\t\t\t}\n\t\t\t\tif (hitItem) {\n\t\t\t\t\temitMouseEvent(hitItem, null, 'mouseenter', event, point);\n\t\t\t\t}\n\t\t\t\toverItem = hitItem;\n\t\t\t}\n\t\t\tif (wasInView ^ inView) {\n\t\t\t\temitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',\n\t\t\t\t\t\tevent, point);\n\t\t\t\toverView = inView ? this : null;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tif ((inView || mouse.drag) && !point.equals(lastPoint)) {\n\t\t\t\temitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',\n\t\t\t\t\t\tevent, point, lastPoint);\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\twasInView = inView;\n\t\t\tif (mouse.down && inView || mouse.up && downPoint) {\n\t\t\t\temitMouseEvents(this, hitItem, type, event, point, downPoint);\n\t\t\t\tif (mouse.down) {\n\t\t\t\t\tdblClick = hitItem === clickItem\n\t\t\t\t\t\t&& (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = clickItem = hitItem;\n\t\t\t\t\tif (!prevented && hitItem) {\n\t\t\t\t\t\tvar item = hitItem;\n\t\t\t\t\t\twhile (item && !item.responds('mousedrag'))\n\t\t\t\t\t\t\titem = item._parent;\n\t\t\t\t\t\tif (item)\n\t\t\t\t\t\t\tdragItem = hitItem;\n\t\t\t\t\t}\n\t\t\t\t\tdownPoint = point;\n\t\t\t\t} else if (mouse.up) {\n\t\t\t\t\tif (!prevented && hitItem === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\temitMouseEvents(this, hitItem, dblClick ? 'doubleclick'\n\t\t\t\t\t\t\t\t: 'click', event, point, downPoint);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t}\n\t\t\t\twasInView = false;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tlastPoint = point;\n\t\t\tif (handle && tool) {\n\t\t\t\tcalled = tool._handleMouseEvent(type, event, point, mouse)\n\t\t\t\t\t|| called;\n\t\t\t}\n\n\t\t\tif (called && !mouse.move || mouse.down && responds('mouseup'))\n\t\t\t\tevent.preventDefault();\n\t\t},\n\n\t\t_handleKeyEvent: function(type, event, key, character) {\n\t\t\tvar scope = this._scope,\n\t\t\t\ttool = scope.tool,\n\t\t\t\tkeyEvent;\n\n\t\t\tfunction emit(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tpaper = scope;\n\t\t\t\t\tobj.emit(type, keyEvent = keyEvent\n\t\t\t\t\t\t\t|| new KeyEvent(type, event, key, character));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isVisible()) {\n\t\t\t\temit(this);\n\t\t\t\tif (tool && tool.responds(type))\n\t\t\t\t\temit(tool);\n\t\t\t}\n\t\t},\n\n\t\t_countItemEvent: function(type, sign) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\tnative = itemEvents.native,\n\t\t\t\tvirtual = itemEvents.virtual;\n\t\t\tfor (var key in itemEventsMap) {\n\t\t\t\tnative[key] = (native[key] || 0)\n\t\t\t\t\t\t+ (itemEventsMap[key][type] || 0) * sign;\n\t\t\t}\n\t\t\tvirtual[type] = (virtual[type] || 0) + sign;\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof window.HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ Base.slice(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tvar ctx = this._context = canvas.getContext('2d');\n\t\tctx.save();\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(ctx,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t\tthis._needsUpdate = true;\n\t},\n\n\tremove: function remove() {\n\t\tthis._context.restore();\n\t\treturn remove.base.call(this);\n\t},\n\n\t_setElementSize: function _setElementSize(width, height) {\n\t\tvar pixelRatio = this._pixelRatio;\n\t\t_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n\t\tif (pixelRatio !== 1) {\n\t\t\tvar element = this._element,\n\t\t\t\tctx = this._context;\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\tctx.save();\n\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetPixelSize: function getPixelSize(size) {\n\t\tvar agent = paper.agent,\n\t\t\tpixels;\n\t\tif (agent && agent.firefox) {\n\t\t\tpixels = getPixelSize.base.call(this, size);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function() {\n\t\tif (!this._needsUpdate)\n\t\t\treturn false;\n\t\tvar project = this._project,\n\t\t\tctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tif (project)\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tthis._needsUpdate = false;\n\t\treturn true;\n\t}\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t\tthis.type = event && event.type;\n\t},\n\n\tprevented: false,\n\tstopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.prevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.stopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetTimeStamp: function() {\n\t\treturn this.event.timeStamp;\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(type, event, key, character) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\tvar keyLookup = {\n\t\t\t'\\t': 'tab',\n\t\t\t' ': 'space',\n\t\t\t'\\b': 'backspace',\n\t\t\t'\\x7f': 'delete',\n\t\t\t'Spacebar': 'space',\n\t\t\t'Del': 'delete',\n\t\t\t'Win': 'meta',\n\t\t\t'Esc': 'escape'\n\t\t},\n\n\t\tcharLookup = {\n\t\t\t'tab': '\\t',\n\t\t\t'space': ' ',\n\t\t\t'enter': '\\r'\n\t\t},\n\n\t\tkeyMap = {},\n\t\tcharMap = {},\n\t\tmetaFixMap,\n\t\tdownKey,\n\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\talt: false,\n\t\t\tmeta: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}).inject({\n\t\t\toption: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.alt;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcommand: {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar agent = paper && paper.agent;\n\t\t\t\t\treturn agent && agent.mac ? this.meta : this.control;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tfunction getKey(event) {\n\t\tvar key = event.key || event.keyIdentifier;\n\t\tkey = /^U\\+/.test(key)\n\t\t\t\t? String.fromCharCode(parseInt(key.substr(2), 16))\n\t\t\t\t: /^Arrow[A-Z]/.test(key) ? key.substr(5)\n\t\t\t\t: key === 'Unidentified' ? String.fromCharCode(event.keyCode)\n\t\t\t\t: key;\n\t\treturn keyLookup[key] ||\n\t\t\t\t(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n\t}\n\n\tfunction handleKey(down, key, character, event) {\n\t\tvar type = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharMap[key] = character;\n\t\t} else {\n\t\t\tdelete charMap[key];\n\t\t}\n\t\tif (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar agent = paper && paper.agent;\n\t\t\tif (name === 'meta' && agent && agent.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tmetaFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var k in metaFixMap) {\n\t\t\t\t\t\tif (k in charMap)\n\t\t\t\t\t\t\thandleKey(false, k, metaFixMap[k], event);\n\t\t\t\t\t}\n\t\t\t\t\tmetaFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && metaFixMap) {\n\t\t\tmetaFixMap[key] = character;\n\t\t}\n\t\tif (view) {\n\t\t\tview._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,\n\t\t\t\t\tcharacter);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar key = getKey(event),\n\t\t\t\tagent = paper && paper.agent;\n\t\t\tif (key.length > 1 || agent && (agent.chrome && (event.altKey\n\t\t\t\t\t\t|| agent.mac && event.metaKey\n\t\t\t\t\t\t|| !agent.mac && event.ctrlKey))) {\n\t\t\t\thandleKey(true, key,\n\t\t\t\t\t\tcharLookup[key] || (key.length > 1 ? '' : key), event);\n\t\t\t} else {\n\t\t\t\tdownKey = key;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downKey) {\n\t\t\t\tvar key = getKey(event),\n\t\t\t\t\tcode = event.charCode,\n\t\t\t\t\tcharacter = code >= 32 ? String.fromCharCode(code)\n\t\t\t\t\t\t: key.length > 1 ? '' : key;\n\t\t\t\tif (key !== downKey) {\n\t\t\t\t\tkey = character.toLowerCase();\n\t\t\t\t}\n\t\t\t\thandleKey(true, key, character, event);\n\t\t\t\tdownKey = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar key = getKey(event);\n\t\t\tif (key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn this.tool[/^mouse(down|up)$/.test(this.type)\n\t\t\t\t? '_downCount' : '_moveCount'];\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',\n\t\t\t'onKeyUp'],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._moveCount = -1;\n\t\tthis._downCount = -1;\n\t\tthis.set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_handleMouseEvent: function(type, event, point, mouse) {\n\t\tpaper = this._scope;\n\t\tif (mouse.drag && !this.responds(type))\n\t\t\ttype = 'mousemove';\n\t\tvar move = mouse.move || mouse.drag,\n\t\t\tresponds = this.responds(type),\n\t\t\tminDistance = this.minDistance,\n\t\t\tmaxDistance = this.maxDistance,\n\t\t\tcalled = false,\n\t\t\ttool = this;\n\t\tfunction update(minDistance, maxDistance) {\n\t\t\tvar pt = point,\n\t\t\t\ttoolPoint = move ? tool._point : (tool._downPoint || pt);\n\t\t\tif (move) {\n\t\t\t\tif (tool._moveCount && pt.equals(toolPoint)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (toolPoint && (minDistance != null || maxDistance != null)) {\n\t\t\t\t\tvar vector = pt.subtract(toolPoint),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < (minDistance || 0))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance) {\n\t\t\t\t\t\tpt = toolPoint.add(vector.normalize(\n\t\t\t\t\t\t\t\tMath.min(distance, maxDistance)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttool._moveCount++;\n\t\t\t}\n\t\t\ttool._point = pt;\n\t\t\ttool._lastPoint = toolPoint || pt;\n\t\t\tif (mouse.down) {\n\t\t\t\ttool._moveCount = -1;\n\t\t\t\ttool._downPoint = pt;\n\t\t\t\ttool._downCount++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction emit() {\n\t\t\tif (responds) {\n\t\t\t\tcalled = tool.emit(type, new ToolEvent(tool, type, event))\n\t\t\t\t\t\t|| called;\n\t\t\t}\n\t\t}\n\n\t\tif (mouse.down) {\n\t\t\tupdate();\n\t\t\temit();\n\t\t} else if (mouse.up) {\n\t\t\tupdate(null, maxDistance);\n\t\t\temit();\n\t\t} else if (responds) {\n\t\t\twhile (update(minDistance, maxDistance))\n\t\t\t\temit();\n\t\t}\n\t\treturn called;\n\t}\n\n});\n\nvar Http = {\n\trequest: function(options) {\n\t\tvar xhr = new self.XMLHttpRequest();\n\t\txhr.open((options.method || 'get').toUpperCase(), options.url,\n\t\t\t\tBase.pick(options.async, true));\n\t\tif (options.mimeType)\n\t\t\txhr.overrideMimeType(options.mimeType);\n\t\txhr.onload = function() {\n\t\t\tvar status = xhr.status;\n\t\t\tif (status === 0 || status === 200) {\n\t\t\t\tif (options.onLoad) {\n\t\t\t\t\toptions.onLoad.call(xhr, xhr.responseText);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txhr.onerror();\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tvar status = xhr.status,\n\t\t\t\tmessage = 'Could not load \"' + options.url + '\" (Status: '\n\t\t\t\t\t\t+ status + ')';\n\t\t\tif (options.onError) {\n\t\t\t\toptions.onError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height) {\n\t\tif (!window)\n\t\t\treturn null;\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tclear = false;\n\t\t}\n\t\tvar ctx = canvas.getContext('2d');\n\t\tif (!ctx) {\n\t\t\tthrow new Error('Canvas ' + canvas +\n\t\t\t\t\t' is unable to provide a 2D context.');\n\t\t}\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height) {\n\t\tvar canvas = this.getCanvas(width, height);\n\t\treturn canvas ? canvas.getContext('2d') : null;\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj && obj.canvas ? obj.canvas : obj;\n\t\tif (canvas && canvas.getContext) {\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1);\n\tif (ctx) {\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken\n\t\t\t\t\t\t\t? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t}\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SvgElement = new function() {\n\tvar svg = 'http://www.w3.org/2000/svg',\n\t\txmlns = 'http://www.w3.org/2000/xmlns',\n\t\txlink = 'http://www.w3.org/1999/xlink',\n\t\tattributeNamespace = {\n\t\t\thref: xlink,\n\t\t\txlink: xmlns,\n\t\t\txmlns: xmlns + '/',\n\t\t\t'xmlns:xlink': xmlns + '/'\n\t\t};\n\n\tfunction create(tag, attributes, formatter) {\n\t\treturn set(document.createElementNS(svg, tag), attributes, formatter);\n\t}\n\n\tfunction get(node, name) {\n\t\tvar namespace = attributeNamespace[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\treturn value === 'null' ? null : value;\n\t}\n\n\tfunction set(node, attributes, formatter) {\n\t\tfor (var name in attributes) {\n\t\t\tvar value = attributes[name],\n\t\t\t\tnamespace = attributeNamespace[name];\n\t\t\tif (typeof value === 'number' && formatter)\n\t\t\t\tvalue = formatter.number(value);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, name, value);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\treturn {\n\t\tsvg: svg,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\n\t\tcreate: create,\n\t\tget: get,\n\t\tset: set\n\t};\n};\n\nvar SvgStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tfillRule: ['fill-rule', 'string'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'style']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nnew function() {\n\tvar formatter;\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tmatrix = matrix._shiftless();\n\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\ttrans = null;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling,\n\t\t\t\t\tskew = decomposed.skewing;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (skew.x)\n\t\t\t\t\tparts.push('skewX(' + formatter.number(skew.x) + ')');\n\t\t\t\tif (skew.y)\n\t\t\t\t\tparts.push('skewY(' + formatter.number(skew.y) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = SvgElement.create('g', attrs, formatter);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = SvgElement.create('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tSvgElement.set(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages == false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn SvgElement.create('image', attrs, formatter);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\tlength = segments.length,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (matchShapes && length >= 2 && !item.hasHandles()) {\n\t\t\tif (length > 2) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t}\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar start = segments[0]._point,\n\t\t\t\t\tend = segments[1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: end.x,\n\t\t\t\t\ty2: end.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn SvgElement.create('path', attrs, formatter);\n\t}\n\n\tfunction exportSymbolItem(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tdefinition = item._definition,\n\t\t\tnode = getDefinition(definition, 'symbol'),\n\t\t\tdefinitionItem = definition._item,\n\t\t\tbounds = definitionItem.getBounds();\n\t\tif (!node) {\n\t\t\tnode = SvgElement.create('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tnode.appendChild(exportSVG(definitionItem, options));\n\t\t\tsetDefinition(definition, node, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + node.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = bounds.width;\n\t\tattrs.height = bounds.height;\n\t\tattrs.overflow = 'visible';\n\t\treturn SvgElement.create('use', attrs, formatter);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin(),\n\t\t\t\tdestination = color.getDestination(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = SvgElement.create((radial ? 'radial' : 'linear')\n\t\t\t\t\t+ 'Gradient', attrs, formatter);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha(),\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: offset == null ? i / (l - 1) : offset\n\t\t\t\t};\n\t\t\t\tif (stopColor)\n\t\t\t\t\tattrs['stop-color'] = stopColor.toCSS(true);\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(\n\t\t\t\t\t\tSvgElement.create('stop', attrs, formatter));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = SvgElement.create('text', getTransform(item._matrix, true),\n\t\t\t\tformatter);\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tSymbolItem: exportSymbolItem,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent(),\n\t\t\tstyle = [];\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SvgStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tif (type === 'style') {\n\t\t\t\t\tstyle.push(entry.attribute + ': ' + value);\n\t\t\t\t} else {\n\t\t\t\t\tattrs[entry.attribute] = value == null ? 'none'\n\t\t\t\t\t\t\t: type === 'color' ? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array' ? value.join(',')\n\t\t\t\t\t\t\t: type === 'lookup' ? entry.toSVG[value]\n\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (style.length)\n\t\t\tattrs.style = style.join(';');\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn SvgElement.set(node, attrs, formatter);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-'\n\t\t\t\t+ (item._id || item.__id || (item.__id = UID.get('svg')))];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + typeId;\n\t\tdefinitions.svgs[type + '-' + (item._id || item.__id)] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = SvgElement.create('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(SvgElement.create('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new self.XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar children = this._children,\n\t\t\t\tview = this.getView(),\n\t\t\t\tbounds = Base.pick(options.bounds, 'view'),\n\t\t\t\tmx = options.matrix || bounds === 'view' && view._matrix,\n\t\t\t\tmatrix = mx && Matrix.read([mx]),\n\t\t\t\trect = bounds === 'view'\n\t\t\t\t\t? new Rectangle([0, 0], view.getViewSize())\n\t\t\t\t\t: bounds === 'content'\n\t\t\t\t\t\t? Item._getBounds(children, matrix, { stroke: true })\n\t\t\t\t\t\t\t.rect\n\t\t\t\t\t\t: Rectangle.read([bounds], 0, { readNull: true }),\n\t\t\t\tattrs = {\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: SvgElement.svg,\n\t\t\t\t\t'xmlns:xlink': SvgElement.xlink,\n\t\t\t\t};\n\t\t\tif (rect) {\n\t\t\t\tattrs.width = rect.width;\n\t\t\t\tattrs.height = rect.height;\n\t\t\t\tif (rect.x || rect.y)\n\t\t\t\t\tattrs.viewBox = formatter.rectangle(rect);\n\t\t\t}\n\t\t\tvar node = SvgElement.create('svg', attrs, formatter),\n\t\t\t\tparent = node;\n\t\t\tif (matrix && !matrix.isIdentity()) {\n\t\t\t\tparent = node.appendChild(SvgElement.create('g',\n\t\t\t\t\t\tgetTransform(matrix), formatter));\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tparent.appendChild(exportSVG(children[i], options, true));\n\t\t\t}\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tvar definitions = {},\n\t\trootSize;\n\n\tfunction getValue(node, name, isString, allowNull, allowPercent) {\n\t\tvar value = SvgElement.get(node, name),\n\t\t\tres = value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString ? '' : 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t\treturn /%\\s*$/.test(value)\n\t\t\t? (res / 100) * (allowPercent ? 1\n\t\t\t\t: rootSize[/x|^width/.test(name) ? 'width' : 'height'])\n\t\t\t: res;\n\t}\n\n\tfunction getPoint(node, x, y, allowNull, allowPercent) {\n\t\tx = getValue(node, x || 'x', false, allowNull, allowPercent);\n\t\ty = getValue(node, y || 'y', false, allowNull, allowPercent);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull, allowPercent) {\n\t\tw = getValue(node, w || 'width', false, allowNull, allowPercent);\n\t\th = getValue(node, h || 'height', false, allowNull, allowPercent);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none' ? null\n\t\t\t\t: type === 'number' ? parseFloat(value)\n\t\t\t\t: type === 'array' ?\n\t\t\t\t\tvalue ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t: type === 'color' ? getDefinition(value) || value\n\t\t\t\t: type === 'lookup' ? lookup[value]\n\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\tisDefs = type === 'defs',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip && !isDefs) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportNode(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& !/^defs$/i.test(childNode.nodeName)\n\t\t\t\t\t&& (child = importNode(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof SymbolDefinition))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || isDefs) {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\treturn PathItem.create(node.getAttribute('d'));\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tradial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t\tif (gradient._radial ^ radial) {\n\t\t\t\tgradient = gradient.clone();\n\t\t\t\tgradient._radial = radial;\n\t\t\t}\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, radial);\n\t\t}\n\t\tvar origin, destination, highlight,\n\t\t\tscaleToBounds = getValue(node, 'gradientUnits', true) !==\n\t\t\t\t'userSpaceOnUse';\n\t\tif (radial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy', false, scaleToBounds);\n\t\t\tdestination = origin.add(\n\t\t\t\t\tgetValue(node, 'r', false, false, scaleToBounds), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1', false, scaleToBounds);\n\t\t\tdestination = getPoint(node, 'x2', 'y2', false, scaleToBounds);\n\t\t}\n\t\tvar color = applyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\tcolor._scaleToBounds = scaleToBounds;\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\treturn importNode(child, options, isRoot);\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node);\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\tgetPoint(node).add(size.divide(2)));\n\t\t\t\tthis.translate(center);\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new SymbolDefinition(\n\t\t\t\t\timportGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node);\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof SymbolDefinition\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(\n\t\t\t\t\tgetPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\treturn new Shape.Rectangle(new Rectangle(\n\t\t\t\t\t\tgetPoint(node),\n\t\t\t\t\t\tgetSize(node)\n\t\t\t\t\t), getSize(node, 'rx', 'ry'));\n\t\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(\n\t\t\t\t\tgetPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node).add(\n\t\t\t\t\tgetPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t}\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tif (item.transform) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.append(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',\n\t\t\tcolor = item[key] && item[key]();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SvgStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\tif (item[entry.set]) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color') {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tif (color._scaleToBounds) {\n\t\t\t\t\t\t\tvar bounds = item.getBounds();\n\t\t\t\t\t\t\tcolor.transform(new Matrix()\n\t\t\t\t\t\t\t\t.translate(bounds.getPoint())\n\t\t\t\t\t\t\t\t.scale(bounds.getSize()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tif (item.setOffset) {\n\t\t\t\tvar percent = value.match(/(.*)%$/);\n\t\t\t\titem.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n\t\t\t}\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, null, null, true),\n\t\t\t\tgroup,\n\t\t\t\tmatrix;\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? size.divide(rect.getSize()) : 1,\n\t\t\t\tmatrix = new Matrix().scale(scale)\n\t\t\t\t\t\t.translate(rect.getPoint().negate());\n\t\t\t\tgroup = item;\n\t\t\t} else if (item instanceof SymbolDefinition) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tgroup = item._item;\n\t\t\t}\n\t\t\tif (group)  {\n\t\t\t\tif (getAttribute(node, 'overflow', styles) !== 'visible') {\n\t\t\t\t\tvar clip = new Shape.Rectangle(rect);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t\tif (matrix)\n\t\t\t\t\tgroup.transform(matrix);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value ? undefined\n\t\t\t\t: value === 'none' ? null\n\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tif (node.style) {\n\t\t\tvar parent = node.parentNode,\n\t\t\t\tstyles = {\n\t\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\t\tparent: !isRoot && !/^defs$/i.test(parent.tagName)\n\t\t\t\t\t\t\t&& DomElement.getStyles(parent) || {}\n\t\t\t\t};\n\t\t\tBase.each(attributes, function(apply, name) {\n\t\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\t\titem = value !== undefined\n\t\t\t\t\t\t&& apply(item, value, name, node, styles) || item;\n\t\t\t});\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/),\n\t\t\tname = match && match[1],\n\t\t\tres = name && definitions[window\n\t\t\t\t\t? name.replace(window.location.href.split('#')[0] + '#', '')\n\t\t\t\t\t: name];\n\t\tif (res && res._scaleToBounds) {\n\t\t\tres = res.clone();\n\t\t\tres._scaleToBounds = true;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction importNode(node, options, isRoot) {\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\tisElement = type !== '#document',\n\t\t\tbody = document.body,\n\t\t\tcontainer,\n\t\t\tparent,\n\t\t\tnext;\n\t\tif (isRoot && isElement) {\n\t\t\trootSize = paper.getView().getSize();\n\t\t\trootSize = getSize(node, null, null, true) || rootSize;\n\t\t\tcontainer = SvgElement.create('svg', {\n\t\t\t\tstyle: 'stroke-width: 1px; stroke-miterlimit: 10'\n\t\t\t});\n\t\t\tparent = node.parentNode;\n\t\t\tnext = node.nextSibling;\n\t\t\tcontainer.appendChild(node);\n\t\t\tbody.appendChild(container);\n\t\t}\n\t\tvar settings = paper.settings,\n\t\t\tapplyMatrix = settings.applyMatrix,\n\t\t\tinsertItems = settings.insertItems;\n\t\tsettings.applyMatrix = false;\n\t\tsettings.insertItems = false;\n\t\tvar importer = importers[type],\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.insertItems = insertItems;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (isElement && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport,\n\t\t\t\tdata = isElement && node.getAttribute('data-paper-data');\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (container) {\n\t\t\tbody.removeChild(container);\n\t\t\tif (parent) {\n\t\t\t\tif (next) {\n\t\t\t\t\tparent.insertBefore(node, next);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importSVG(source, options, owner) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\toptions = typeof options === 'function' ? { onLoad: options }\n\t\t\t\t: options || {};\n\t\tvar scope = paper,\n\t\t\titem = null;\n\n\t\tfunction onLoad(svg) {\n\t\t\ttry {\n\t\t\t\tvar node = typeof svg === 'object' ? svg : new self.DOMParser()\n\t\t\t\t\t\t.parseFromString(svg, 'image/svg+xml');\n\t\t\t\tif (!node.nodeName) {\n\t\t\t\t\tnode = null;\n\t\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\t\t}\n\t\t\t\tpaper = scope;\n\t\t\t\titem = importNode(node, options, true);\n\t\t\t\tif (!options || options.insert !== false) {\n\t\t\t\t\towner._insertItem(undefined, item);\n\t\t\t\t}\n\t\t\t\tvar onLoad = options.onLoad;\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad(item, svg);\n\t\t\t} catch (e) {\n\t\t\t\tonError(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction onError(message, status) {\n\t\t\tvar onError = options.onError;\n\t\t\tif (onError) {\n\t\t\t\tonError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\tvar node = document.getElementById(source);\n\t\t\tif (node) {\n\t\t\t\tonLoad(node);\n\t\t\t} else {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: source,\n\t\t\t\t\tasync: true,\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function() {\n\t\t\t\tonLoad(reader.result);\n\t\t\t};\n\t\t\treader.onerror = function() {\n\t\t\t\tonError(reader.error);\n\t\t\t};\n\t\t\treturn reader.readAsText(source);\n\t\t} else {\n\t\t\tonLoad(source);\n\t\t}\n\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = function() {\n\tvar global = this,\n\t\tacorn = global.acorn;\n\tif (!acorn && typeof require !== 'undefined') {\n\t\ttry { acorn = require('acorn'); } catch(e) {}\n\t}\n\tif (!acorn) {\n\t\tvar exports, module;\n\t\tacorn = exports = module = {};\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports);\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod);\n  mod(root.acorn || (root.acorn = {}));\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.0\";\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\treturn parseTopLevel(options.program);\n  };\n\n  var defaultOptions = exports.defaultOptions = {\n\tecmaVersion: 5,\n\tstrictSemicolons: false,\n\tallowTrailingCommas: true,\n\tforbidReserved: false,\n\tallowReturnOutsideFunction: false,\n\tlocations: false,\n\tonComment: null,\n\tranges: false,\n\tprogram: null,\n\tsourceFile: null,\n\tdirectSourceFile: null\n  };\n\n  function setOptions(opts) {\n\toptions = opts || {};\n\tfor (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n\t  options[opt] = defaultOptions[opt];\n\tsourceFile = options.sourceFile || null;\n  }\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n\tfor (var line = 1, cur = 0;;) {\n\t  lineBreak.lastIndex = cur;\n\t  var match = lineBreak.exec(input);\n\t  if (match && match.index < offset) {\n\t\t++line;\n\t\tcur = match.index + match[0].length;\n\t  } else break;\n\t}\n\treturn {line: line, column: offset - cur};\n  };\n\n  exports.tokenize = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\n\tvar t = {};\n\tfunction getToken(forceRegexp) {\n\t  lastEnd = tokEnd;\n\t  readToken(forceRegexp);\n\t  t.start = tokStart; t.end = tokEnd;\n\t  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n\t  t.type = tokType; t.value = tokVal;\n\t  return t;\n\t}\n\tgetToken.jumpTo = function(pos, reAllowed) {\n\t  tokPos = pos;\n\t  if (options.locations) {\n\t\ttokCurLine = 1;\n\t\ttokLineStart = lineBreak.lastIndex = 0;\n\t\tvar match;\n\t\twhile ((match = lineBreak.exec(input)) && match.index < pos) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = match.index + match[0].length;\n\t\t}\n\t  }\n\t  tokRegexpAllowed = reAllowed;\n\t  skipSpace();\n\t};\n\treturn getToken;\n  };\n\n  var tokPos;\n\n  var tokStart, tokEnd;\n\n  var tokStartLoc, tokEndLoc;\n\n  var tokType, tokVal;\n\n  var tokRegexpAllowed;\n\n  var tokCurLine, tokLineStart;\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  var inFunction, labels, strict;\n\n  function raise(pos, message) {\n\tvar loc = getLineInfo(input, pos);\n\tmessage += \" (\" + loc.line + \":\" + loc.column + \")\";\n\tvar err = new SyntaxError(message);\n\terr.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n\tthrow err;\n  }\n\n  var empty = [];\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n\t\t\t\t\t  \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n\t\t\t\t\t  \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n\t\t\t\t\t  \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n\t\t\t\t\t  \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n\t\t\t\t\t  \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n\t\t\t\t\t  \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n\t\t\t\t\t  \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n\t\t\t\t\t  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n\t\t\t\t\t  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n\t\t\t\t\t  num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  function makePredicate(words) {\n\twords = words.split(\" \");\n\tvar f = \"\", cats = [];\n\tout: for (var i = 0; i < words.length; ++i) {\n\t  for (var j = 0; j < cats.length; ++j)\n\t\tif (cats[j][0].length == words[i].length) {\n\t\t  cats[j].push(words[i]);\n\t\t  continue out;\n\t\t}\n\t  cats.push([words[i]]);\n\t}\n\tfunction compareTo(arr) {\n\t  if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n\t  f += \"switch(str){\";\n\t  for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n\t  f += \"return true}return false;\";\n\t}\n\n\tif (cats.length > 3) {\n\t  cats.sort(function(a, b) {return b.length - a.length;});\n\t  f += \"switch(str.length){\";\n\t  for (var i = 0; i < cats.length; ++i) {\n\t\tvar cat = cats[i];\n\t\tf += \"case \" + cat[0].length + \":\";\n\t\tcompareTo(cat);\n\t  }\n\t  f += \"}\";\n\n\t} else {\n\t  compareTo(words);\n\t}\n\treturn new Function(\"str\", f);\n  }\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n\tif (code < 65) return code === 36;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n\tif (code < 48) return code === 36;\n\tif (code < 58) return true;\n\tif (code < 65) return false;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  function line_loc_t() {\n\tthis.line = tokCurLine;\n\tthis.column = tokPos - tokLineStart;\n  }\n\n  function initTokenState() {\n\ttokCurLine = 1;\n\ttokPos = tokLineStart = 0;\n\ttokRegexpAllowed = true;\n\tskipSpace();\n  }\n\n  function finishToken(type, val) {\n\ttokEnd = tokPos;\n\tif (options.locations) tokEndLoc = new line_loc_t;\n\ttokType = type;\n\tskipSpace();\n\ttokVal = val;\n\ttokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n\tif (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n\ttokPos = end + 2;\n\tif (options.locations) {\n\t  lineBreak.lastIndex = start;\n\t  var match;\n\t  while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n\t\t++tokCurLine;\n\t\ttokLineStart = match.index + match[0].length;\n\t  }\n\t}\n\tif (options.onComment)\n\t  options.onComment(true, input.slice(start + 2, end), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n\tvar start = tokPos;\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar ch = input.charCodeAt(tokPos+=2);\n\twhile (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n\t  ++tokPos;\n\t  ch = input.charCodeAt(tokPos);\n\t}\n\tif (options.onComment)\n\t  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipSpace() {\n\twhile (tokPos < inputLen) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === 32) {\n\t\t++tokPos;\n\t  } else if (ch === 13) {\n\t\t++tokPos;\n\t\tvar next = input.charCodeAt(tokPos);\n\t\tif (next === 10) {\n\t\t  ++tokPos;\n\t\t}\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch === 10 || ch === 8232 || ch === 8233) {\n\t\t++tokPos;\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch > 8 && ch < 14) {\n\t\t++tokPos;\n\t  } else if (ch === 47) {\n\t\tvar next = input.charCodeAt(tokPos + 1);\n\t\tif (next === 42) {\n\t\t  skipBlockComment();\n\t\t} else if (next === 47) {\n\t\t  skipLineComment();\n\t\t} else break;\n\t  } else if (ch === 160) {\n\t\t++tokPos;\n\t  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t\t++tokPos;\n\t  } else {\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  function readToken_dot() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next >= 48 && next <= 57) return readNumber(true);\n\t++tokPos;\n\treturn finishToken(_dot);\n  }\n\n  function readToken_slash() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (tokRegexpAllowed) {++tokPos; return readRegexp();}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) {\n\t  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n\t\t  newline.test(input.slice(lastEnd, tokPos))) {\n\t\ttokPos += 3;\n\t\tskipLineComment();\n\t\tskipSpace();\n\t\treturn readToken();\n\t  }\n\t  return finishOp(_incDec, 2);\n\t}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tvar size = 1;\n\tif (next === code) {\n\t  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n\t  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n\t  return finishOp(_bitShift, size);\n\t}\n\tif (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n\t\tinput.charCodeAt(tokPos + 3) == 45) {\n\t  tokPos += 4;\n\t  skipLineComment();\n\t  skipSpace();\n\t  return readToken();\n\t}\n\tif (next === 61)\n\t  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n\treturn finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n\treturn finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n\tswitch(code) {\n\tcase 46:\n\t  return readToken_dot();\n\n\tcase 40: ++tokPos; return finishToken(_parenL);\n\tcase 41: ++tokPos; return finishToken(_parenR);\n\tcase 59: ++tokPos; return finishToken(_semi);\n\tcase 44: ++tokPos; return finishToken(_comma);\n\tcase 91: ++tokPos; return finishToken(_bracketL);\n\tcase 93: ++tokPos; return finishToken(_bracketR);\n\tcase 123: ++tokPos; return finishToken(_braceL);\n\tcase 125: ++tokPos; return finishToken(_braceR);\n\tcase 58: ++tokPos; return finishToken(_colon);\n\tcase 63: ++tokPos; return finishToken(_question);\n\n\tcase 48:\n\t  var next = input.charCodeAt(tokPos + 1);\n\t  if (next === 120 || next === 88) return readHexNumber();\n\tcase 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:\n\t  return readNumber(false);\n\n\tcase 34: case 39:\n\t  return readString(code);\n\n\tcase 47:\n\t  return readToken_slash(code);\n\n\tcase 37: case 42:\n\t  return readToken_mult_modulo();\n\n\tcase 124: case 38:\n\t  return readToken_pipe_amp(code);\n\n\tcase 94:\n\t  return readToken_caret();\n\n\tcase 43: case 45:\n\t  return readToken_plus_min(code);\n\n\tcase 60: case 62:\n\t  return readToken_lt_gt(code);\n\n\tcase 61: case 33:\n\t  return readToken_eq_excl(code);\n\n\tcase 126:\n\t  return finishOp(_prefix, 1);\n\t}\n\n\treturn false;\n  }\n\n  function readToken(forceRegexp) {\n\tif (!forceRegexp) tokStart = tokPos;\n\telse tokPos = tokStart + 1;\n\tif (options.locations) tokStartLoc = new line_loc_t;\n\tif (forceRegexp) return readRegexp();\n\tif (tokPos >= inputLen) return finishToken(_eof);\n\n\tvar code = input.charCodeAt(tokPos);\n\tif (isIdentifierStart(code) || code === 92 ) return readWord();\n\n\tvar tok = getTokenFromCode(code);\n\n\tif (tok === false) {\n\t  var ch = String.fromCharCode(code);\n\t  if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n\t  raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n\t}\n\treturn tok;\n  }\n\n  function finishOp(type, size) {\n\tvar str = input.slice(tokPos, tokPos + size);\n\ttokPos += size;\n\tfinishToken(type, str);\n  }\n\n  function readRegexp() {\n\tvar content = \"\", escaped, inClass, start = tokPos;\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n\t  var ch = input.charAt(tokPos);\n\t  if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n\t  if (!escaped) {\n\t\tif (ch === \"[\") inClass = true;\n\t\telse if (ch === \"]\" && inClass) inClass = false;\n\t\telse if (ch === \"/\" && !inClass) break;\n\t\tescaped = ch === \"\\\\\";\n\t  } else escaped = false;\n\t  ++tokPos;\n\t}\n\tvar content = input.slice(start, tokPos);\n\t++tokPos;\n\tvar mods = readWord1();\n\tif (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n\ttry {\n\t  var value = new RegExp(content, mods);\n\t} catch (e) {\n\t  if (e instanceof SyntaxError) raise(start, e.message);\n\t  raise(e);\n\t}\n\treturn finishToken(_regexp, value);\n  }\n\n  function readInt(radix, len) {\n\tvar start = tokPos, total = 0;\n\tfor (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t  var code = input.charCodeAt(tokPos), val;\n\t  if (code >= 97) val = code - 97 + 10;\n\t  else if (code >= 65) val = code - 65 + 10;\n\t  else if (code >= 48 && code <= 57) val = code - 48;\n\t  else val = Infinity;\n\t  if (val >= radix) break;\n\t  ++tokPos;\n\t  total = total * radix + val;\n\t}\n\tif (tokPos === start || len != null && tokPos - start !== len) return null;\n\n\treturn total;\n  }\n\n  function readHexNumber() {\n\ttokPos += 2;\n\tvar val = readInt(16);\n\tif (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\treturn finishToken(_num, val);\n  }\n\n  function readNumber(startsWithDot) {\n\tvar start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n\tif (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n\tif (input.charCodeAt(tokPos) === 46) {\n\t  ++tokPos;\n\t  readInt(10);\n\t  isFloat = true;\n\t}\n\tvar next = input.charCodeAt(tokPos);\n\tif (next === 69 || next === 101) {\n\t  next = input.charCodeAt(++tokPos);\n\t  if (next === 43 || next === 45) ++tokPos;\n\t  if (readInt(10) === null) raise(start, \"Invalid number\");\n\t  isFloat = true;\n\t}\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n\tvar str = input.slice(start, tokPos), val;\n\tif (isFloat) val = parseFloat(str);\n\telse if (!octal || str.length === 1) val = parseInt(str, 10);\n\telse if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n\telse val = parseInt(str, 8);\n\treturn finishToken(_num, val);\n  }\n\n  function readString(quote) {\n\ttokPos++;\n\tvar out = \"\";\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === quote) {\n\t\t++tokPos;\n\t\treturn finishToken(_string, out);\n\t  }\n\t  if (ch === 92) {\n\t\tch = input.charCodeAt(++tokPos);\n\t\tvar octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n\t\tif (octal) octal = octal[0];\n\t\twhile (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n\t\tif (octal === \"0\") octal = null;\n\t\t++tokPos;\n\t\tif (octal) {\n\t\t  if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n\t\t  out += String.fromCharCode(parseInt(octal, 8));\n\t\t  tokPos += octal.length - 1;\n\t\t} else {\n\t\t  switch (ch) {\n\t\t  case 110: out += \"\\n\"; break;\n\t\t  case 114: out += \"\\r\"; break;\n\t\t  case 120: out += String.fromCharCode(readHexChar(2)); break;\n\t\t  case 117: out += String.fromCharCode(readHexChar(4)); break;\n\t\t  case 85: out += String.fromCharCode(readHexChar(8)); break;\n\t\t  case 116: out += \"\\t\"; break;\n\t\t  case 98: out += \"\\b\"; break;\n\t\t  case 118: out += \"\\u000b\"; break;\n\t\t  case 102: out += \"\\f\"; break;\n\t\t  case 48: out += \"\\0\"; break;\n\t\t  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;\n\t\t  case 10:\n\t\t\tif (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n\t\t\tbreak;\n\t\t  default: out += String.fromCharCode(ch); break;\n\t\t  }\n\t\t}\n\t  } else {\n\t\tif (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n\t\tout += String.fromCharCode(ch);\n\t\t++tokPos;\n\t  }\n\t}\n  }\n\n  function readHexChar(len) {\n\tvar n = readInt(16, len);\n\tif (n === null) raise(tokStart, \"Bad character escape sequence\");\n\treturn n;\n  }\n\n  var containsEsc;\n\n  function readWord1() {\n\tcontainsEsc = false;\n\tvar word, first = true, start = tokPos;\n\tfor (;;) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (isIdentifierChar(ch)) {\n\t\tif (containsEsc) word += input.charAt(tokPos);\n\t\t++tokPos;\n\t  } else if (ch === 92) {\n\t\tif (!containsEsc) word = input.slice(start, tokPos);\n\t\tcontainsEsc = true;\n\t\tif (input.charCodeAt(++tokPos) != 117)\n\t\t  raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n\t\t++tokPos;\n\t\tvar esc = readHexChar(4);\n\t\tvar escStr = String.fromCharCode(esc);\n\t\tif (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n\t\tif (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n\t\t  raise(tokPos - 4, \"Invalid Unicode escape\");\n\t\tword += escStr;\n\t  } else {\n\t\tbreak;\n\t  }\n\t  first = false;\n\t}\n\treturn containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  function readWord() {\n\tvar word = readWord1();\n\tvar type = _name;\n\tif (!containsEsc && isKeyword(word))\n\t  type = keywordTypes[word];\n\treturn finishToken(type, word);\n  }\n\n  function next() {\n\tlastStart = tokStart;\n\tlastEnd = tokEnd;\n\tlastEndLoc = tokEndLoc;\n\treadToken();\n  }\n\n  function setStrict(strct) {\n\tstrict = strct;\n\ttokPos = tokStart;\n\tif (options.locations) {\n\t  while (tokPos < tokLineStart) {\n\t\ttokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n\t\t--tokCurLine;\n\t  }\n\t}\n\tskipSpace();\n\treadToken();\n  }\n\n  function node_t() {\n\tthis.type = null;\n\tthis.start = tokStart;\n\tthis.end = null;\n  }\n\n  function node_loc_t() {\n\tthis.start = tokStartLoc;\n\tthis.end = null;\n\tif (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n\tvar node = new node_t();\n\tif (options.locations)\n\t  node.loc = new node_loc_t();\n\tif (options.directSourceFile)\n\t  node.sourceFile = options.directSourceFile;\n\tif (options.ranges)\n\t  node.range = [tokStart, 0];\n\treturn node;\n  }\n\n  function startNodeFrom(other) {\n\tvar node = new node_t();\n\tnode.start = other.start;\n\tif (options.locations) {\n\t  node.loc = new node_loc_t();\n\t  node.loc.start = other.loc.start;\n\t}\n\tif (options.ranges)\n\t  node.range = [other.range[0], 0];\n\n\treturn node;\n  }\n\n  function finishNode(node, type) {\n\tnode.type = type;\n\tnode.end = lastEnd;\n\tif (options.locations)\n\t  node.loc.end = lastEndLoc;\n\tif (options.ranges)\n\t  node.range[1] = lastEnd;\n\treturn node;\n  }\n\n  function isUseStrict(stmt) {\n\treturn options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n\t  stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  function eat(type) {\n\tif (tokType === type) {\n\t  next();\n\t  return true;\n\t}\n  }\n\n  function canInsertSemicolon() {\n\treturn !options.strictSemicolons &&\n\t  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  function semicolon() {\n\tif (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  function expect(type) {\n\tif (tokType === type) next();\n\telse unexpected();\n  }\n\n  function unexpected() {\n\traise(tokStart, \"Unexpected token\");\n  }\n\n  function checkLVal(expr) {\n\tif (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n\t  raise(expr.start, \"Assigning to rvalue\");\n\tif (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n\t  raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  function parseTopLevel(program) {\n\tlastStart = lastEnd = tokPos;\n\tif (options.locations) lastEndLoc = new line_loc_t;\n\tinFunction = strict = null;\n\tlabels = [];\n\treadToken();\n\n\tvar node = program || startNode(), first = true;\n\tif (!program) node.body = [];\n\twhile (tokType !== _eof) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && isUseStrict(stmt)) setStrict(true);\n\t  first = false;\n\t}\n\treturn finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  function parseStatement() {\n\tif (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n\t  readToken(true);\n\n\tvar starttype = tokType, node = startNode();\n\n\tswitch (starttype) {\n\tcase _break: case _continue:\n\t  next();\n\t  var isBreak = starttype === _break;\n\t  if (eat(_semi) || canInsertSemicolon()) node.label = null;\n\t  else if (tokType !== _name) unexpected();\n\t  else {\n\t\tnode.label = parseIdent();\n\t\tsemicolon();\n\t  }\n\n\t  for (var i = 0; i < labels.length; ++i) {\n\t\tvar lab = labels[i];\n\t\tif (node.label == null || lab.name === node.label.name) {\n\t\t  if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n\t\t  if (node.label && isBreak) break;\n\t\t}\n\t  }\n\t  if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n\t  return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n\tcase _debugger:\n\t  next();\n\t  semicolon();\n\t  return finishNode(node, \"DebuggerStatement\");\n\n\tcase _do:\n\t  next();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  expect(_while);\n\t  node.test = parseParenExpression();\n\t  semicolon();\n\t  return finishNode(node, \"DoWhileStatement\");\n\n\tcase _for:\n\t  next();\n\t  labels.push(loopLabel);\n\t  expect(_parenL);\n\t  if (tokType === _semi) return parseFor(node, null);\n\t  if (tokType === _var) {\n\t\tvar init = startNode();\n\t\tnext();\n\t\tparseVar(init, true);\n\t\tfinishNode(init, \"VariableDeclaration\");\n\t\tif (init.declarations.length === 1 && eat(_in))\n\t\t  return parseForIn(node, init);\n\t\treturn parseFor(node, init);\n\t  }\n\t  var init = parseExpression(false, true);\n\t  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n\t  return parseFor(node, init);\n\n\tcase _function:\n\t  next();\n\t  return parseFunction(node, true);\n\n\tcase _if:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  node.consequent = parseStatement();\n\t  node.alternate = eat(_else) ? parseStatement() : null;\n\t  return finishNode(node, \"IfStatement\");\n\n\tcase _return:\n\t  if (!inFunction && !options.allowReturnOutsideFunction)\n\t\traise(tokStart, \"'return' outside of function\");\n\t  next();\n\n\t  if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n\t  else { node.argument = parseExpression(); semicolon(); }\n\t  return finishNode(node, \"ReturnStatement\");\n\n\tcase _switch:\n\t  next();\n\t  node.discriminant = parseParenExpression();\n\t  node.cases = [];\n\t  expect(_braceL);\n\t  labels.push(switchLabel);\n\n\t  for (var cur, sawDefault; tokType != _braceR;) {\n\t\tif (tokType === _case || tokType === _default) {\n\t\t  var isCase = tokType === _case;\n\t\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t\t  node.cases.push(cur = startNode());\n\t\t  cur.consequent = [];\n\t\t  next();\n\t\t  if (isCase) cur.test = parseExpression();\n\t\t  else {\n\t\t\tif (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n\t\t\tcur.test = null;\n\t\t  }\n\t\t  expect(_colon);\n\t\t} else {\n\t\t  if (!cur) unexpected();\n\t\t  cur.consequent.push(parseStatement());\n\t\t}\n\t  }\n\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t  next();\n\t  labels.pop();\n\t  return finishNode(node, \"SwitchStatement\");\n\n\tcase _throw:\n\t  next();\n\t  if (newline.test(input.slice(lastEnd, tokStart)))\n\t\traise(lastEnd, \"Illegal newline after throw\");\n\t  node.argument = parseExpression();\n\t  semicolon();\n\t  return finishNode(node, \"ThrowStatement\");\n\n\tcase _try:\n\t  next();\n\t  node.block = parseBlock();\n\t  node.handler = null;\n\t  if (tokType === _catch) {\n\t\tvar clause = startNode();\n\t\tnext();\n\t\texpect(_parenL);\n\t\tclause.param = parseIdent();\n\t\tif (strict && isStrictBadIdWord(clause.param.name))\n\t\t  raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n\t\texpect(_parenR);\n\t\tclause.guard = null;\n\t\tclause.body = parseBlock();\n\t\tnode.handler = finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.guardedHandlers = empty;\n\t  node.finalizer = eat(_finally) ? parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t\traise(node.start, \"Missing catch or finally clause\");\n\t  return finishNode(node, \"TryStatement\");\n\n\tcase _var:\n\t  next();\n\t  parseVar(node);\n\t  semicolon();\n\t  return finishNode(node, \"VariableDeclaration\");\n\n\tcase _while:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  return finishNode(node, \"WhileStatement\");\n\n\tcase _with:\n\t  if (strict) raise(tokStart, \"'with' in strict mode\");\n\t  next();\n\t  node.object = parseParenExpression();\n\t  node.body = parseStatement();\n\t  return finishNode(node, \"WithStatement\");\n\n\tcase _braceL:\n\t  return parseBlock();\n\n\tcase _semi:\n\t  next();\n\t  return finishNode(node, \"EmptyStatement\");\n\n\tdefault:\n\t  var maybeName = tokVal, expr = parseExpression();\n\t  if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n\t\tfor (var i = 0; i < labels.length; ++i)\n\t\t  if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t\tvar kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n\t\tlabels.push({name: maybeName, kind: kind});\n\t\tnode.body = parseStatement();\n\t\tlabels.pop();\n\t\tnode.label = expr;\n\t\treturn finishNode(node, \"LabeledStatement\");\n\t  } else {\n\t\tnode.expression = expr;\n\t\tsemicolon();\n\t\treturn finishNode(node, \"ExpressionStatement\");\n\t  }\n\t}\n  }\n\n  function parseParenExpression() {\n\texpect(_parenL);\n\tvar val = parseExpression();\n\texpect(_parenR);\n\treturn val;\n  }\n\n  function parseBlock(allowStrict) {\n\tvar node = startNode(), first = true, strict = false, oldStrict;\n\tnode.body = [];\n\texpect(_braceL);\n\twhile (!eat(_braceR)) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && allowStrict && isUseStrict(stmt)) {\n\t\toldStrict = strict;\n\t\tsetStrict(strict = true);\n\t  }\n\t  first = false;\n\t}\n\tif (strict && !oldStrict) setStrict(false);\n\treturn finishNode(node, \"BlockStatement\");\n  }\n\n  function parseFor(node, init) {\n\tnode.init = init;\n\texpect(_semi);\n\tnode.test = tokType === _semi ? null : parseExpression();\n\texpect(_semi);\n\tnode.update = tokType === _parenR ? null : parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForStatement\");\n  }\n\n  function parseForIn(node, init) {\n\tnode.left = init;\n\tnode.right = parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForInStatement\");\n  }\n\n  function parseVar(node, noIn) {\n\tnode.declarations = [];\n\tnode.kind = \"var\";\n\tfor (;;) {\n\t  var decl = startNode();\n\t  decl.id = parseIdent();\n\t  if (strict && isStrictBadIdWord(decl.id.name))\n\t\traise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n\t  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n\t  node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n\t  if (!eat(_comma)) break;\n\t}\n\treturn node;\n  }\n\n  function parseExpression(noComma, noIn) {\n\tvar expr = parseMaybeAssign(noIn);\n\tif (!noComma && tokType === _comma) {\n\t  var node = startNodeFrom(expr);\n\t  node.expressions = [expr];\n\t  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n\t  return finishNode(node, \"SequenceExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseMaybeAssign(noIn) {\n\tvar left = parseMaybeConditional(noIn);\n\tif (tokType.isAssign) {\n\t  var node = startNodeFrom(left);\n\t  node.operator = tokVal;\n\t  node.left = left;\n\t  next();\n\t  node.right = parseMaybeAssign(noIn);\n\t  checkLVal(left);\n\t  return finishNode(node, \"AssignmentExpression\");\n\t}\n\treturn left;\n  }\n\n  function parseMaybeConditional(noIn) {\n\tvar expr = parseExprOps(noIn);\n\tif (eat(_question)) {\n\t  var node = startNodeFrom(expr);\n\t  node.test = expr;\n\t  node.consequent = parseExpression(true);\n\t  expect(_colon);\n\t  node.alternate = parseExpression(true, noIn);\n\t  return finishNode(node, \"ConditionalExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprOps(noIn) {\n\treturn parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  function parseExprOp(left, minPrec, noIn) {\n\tvar prec = tokType.binop;\n\tif (prec != null && (!noIn || tokType !== _in)) {\n\t  if (prec > minPrec) {\n\t\tvar node = startNodeFrom(left);\n\t\tnode.left = left;\n\t\tnode.operator = tokVal;\n\t\tvar op = tokType;\n\t\tnext();\n\t\tnode.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n\t\tvar exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n\t\treturn parseExprOp(exprNode, minPrec, noIn);\n\t  }\n\t}\n\treturn left;\n  }\n\n  function parseMaybeUnary() {\n\tif (tokType.prefix) {\n\t  var node = startNode(), update = tokType.isUpdate;\n\t  node.operator = tokVal;\n\t  node.prefix = true;\n\t  tokRegexpAllowed = true;\n\t  next();\n\t  node.argument = parseMaybeUnary();\n\t  if (update) checkLVal(node.argument);\n\t  else if (strict && node.operator === \"delete\" &&\n\t\t\t   node.argument.type === \"Identifier\")\n\t\traise(node.start, \"Deleting local variable in strict mode\");\n\t  return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t}\n\tvar expr = parseExprSubscripts();\n\twhile (tokType.postfix && !canInsertSemicolon()) {\n\t  var node = startNodeFrom(expr);\n\t  node.operator = tokVal;\n\t  node.prefix = false;\n\t  node.argument = expr;\n\t  checkLVal(expr);\n\t  next();\n\t  expr = finishNode(node, \"UpdateExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprSubscripts() {\n\treturn parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n\tif (eat(_dot)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseIdent(true);\n\t  node.computed = false;\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (eat(_bracketL)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseExpression();\n\t  node.computed = true;\n\t  expect(_bracketR);\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (!noCalls && eat(_parenL)) {\n\t  var node = startNodeFrom(base);\n\t  node.callee = base;\n\t  node.arguments = parseExprList(_parenR, false);\n\t  return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n\t} else return base;\n  }\n\n  function parseExprAtom() {\n\tswitch (tokType) {\n\tcase _this:\n\t  var node = startNode();\n\t  next();\n\t  return finishNode(node, \"ThisExpression\");\n\tcase _name:\n\t  return parseIdent();\n\tcase _num: case _string: case _regexp:\n\t  var node = startNode();\n\t  node.value = tokVal;\n\t  node.raw = input.slice(tokStart, tokEnd);\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _null: case _true: case _false:\n\t  var node = startNode();\n\t  node.value = tokType.atomValue;\n\t  node.raw = tokType.keyword;\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _parenL:\n\t  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n\t  next();\n\t  var val = parseExpression();\n\t  val.start = tokStart1;\n\t  val.end = tokEnd;\n\t  if (options.locations) {\n\t\tval.loc.start = tokStartLoc1;\n\t\tval.loc.end = tokEndLoc;\n\t  }\n\t  if (options.ranges)\n\t\tval.range = [tokStart1, tokEnd];\n\t  expect(_parenR);\n\t  return val;\n\n\tcase _bracketL:\n\t  var node = startNode();\n\t  next();\n\t  node.elements = parseExprList(_bracketR, true, true);\n\t  return finishNode(node, \"ArrayExpression\");\n\n\tcase _braceL:\n\t  return parseObj();\n\n\tcase _function:\n\t  var node = startNode();\n\t  next();\n\t  return parseFunction(node, false);\n\n\tcase _new:\n\t  return parseNew();\n\n\tdefault:\n\t  unexpected();\n\t}\n  }\n\n  function parseNew() {\n\tvar node = startNode();\n\tnext();\n\tnode.callee = parseSubscripts(parseExprAtom(), true);\n\tif (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n\telse node.arguments = empty;\n\treturn finishNode(node, \"NewExpression\");\n  }\n\n  function parseObj() {\n\tvar node = startNode(), first = true, sawGetSet = false;\n\tnode.properties = [];\n\tnext();\n\twhile (!eat(_braceR)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (options.allowTrailingCommas && eat(_braceR)) break;\n\t  } else first = false;\n\n\t  var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n\t  if (eat(_colon)) {\n\t\tprop.value = parseExpression(true);\n\t\tkind = prop.kind = \"init\";\n\t  } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n\t\t\t\t (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n\t\tisGetSet = sawGetSet = true;\n\t\tkind = prop.kind = prop.key.name;\n\t\tprop.key = parsePropertyName();\n\t\tif (tokType !== _parenL) unexpected();\n\t\tprop.value = parseFunction(startNode(), false);\n\t  } else unexpected();\n\n\t  if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n\t\tfor (var i = 0; i < node.properties.length; ++i) {\n\t\t  var other = node.properties[i];\n\t\t  if (other.key.name === prop.key.name) {\n\t\t\tvar conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n\t\t\t  kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n\t\t\tif (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n\t\t\tif (conflict) raise(prop.key.start, \"Redefinition of property\");\n\t\t  }\n\t\t}\n\t  }\n\t  node.properties.push(prop);\n\t}\n\treturn finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n\tif (tokType === _num || tokType === _string) return parseExprAtom();\n\treturn parseIdent(true);\n  }\n\n  function parseFunction(node, isStatement) {\n\tif (tokType === _name) node.id = parseIdent();\n\telse if (isStatement) unexpected();\n\telse node.id = null;\n\tnode.params = [];\n\tvar first = true;\n\texpect(_parenL);\n\twhile (!eat(_parenR)) {\n\t  if (!first) expect(_comma); else first = false;\n\t  node.params.push(parseIdent());\n\t}\n\n\tvar oldInFunc = inFunction, oldLabels = labels;\n\tinFunction = true; labels = [];\n\tnode.body = parseBlock(true);\n\tinFunction = oldInFunc; labels = oldLabels;\n\n\tif (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n\t  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n\t\tvar id = i < 0 ? node.id : node.params[i];\n\t\tif (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n\t\t  raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n\t\tif (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n\t\t  raise(id.start, \"Argument name clash in strict mode\");\n\t  }\n\t}\n\n\treturn finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n\tvar elts = [], first = true;\n\twhile (!eat(close)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n\t  } else first = false;\n\n\t  if (allowEmpty && tokType === _comma) elts.push(null);\n\t  else elts.push(parseExpression(true));\n\t}\n\treturn elts;\n  }\n\n  function parseIdent(liberal) {\n\tvar node = startNode();\n\tif (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n\tif (tokType === _name) {\n\t  if (!liberal &&\n\t\t  (options.forbidReserved &&\n\t\t   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||\n\t\t   strict && isStrictReservedWord(tokVal)) &&\n\t\t  input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n\t\traise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n\t  node.name = tokVal;\n\t} else if (liberal && tokType.keyword) {\n\t  node.name = tokType.keyword;\n\t} else {\n\t  unexpected();\n\t}\n\ttokRegexpAllowed = false;\n\tnext();\n\treturn finishNode(node, \"Identifier\");\n  }\n\n});\n\n\t\tif (!acorn.version)\n\t\t\tacorn = null;\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn (global.acorn || acorn).parse(code, options);\n\t}\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': '__equals',\n\t\t'!=': '__equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': '__self'\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{\n\t\t\t__self: function() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction compile(code, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction walkAST(node, parent) {\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tfor (var key in node) {\n\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar value = node[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\twalkAST(value, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\t\texp = left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')';\n\t\t\t\t\t\t\treplaceCode(node, /^\\(.*\\)$/.test(getCode(node))\n\t\t\t\t\t\t\t\t\t? '(' + exp + ')' : exp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction encodeVLQ(value) {\n\t\t\tvar res = '',\n\t\t\t\tbase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\tvalue = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n\t\t\twhile (value || !res) {\n\t\t\t\tvar next = value & (32 - 1);\n\t\t\t\tvalue >>= 5;\n\t\t\t\tif (value)\n\t\t\t\t\tnext |= 32;\n\t\t\t\tres += base64[next];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar url = options.url || '',\n\t\t\tagent = paper.agent,\n\t\t\tversion = agent.versionNumber,\n\t\t\toffsetCode = false,\n\t\t\tsourceMaps = options.sourceMaps,\n\t\t\tsource = options.source || code,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg,\n\t\t\toffset = options.offset || 0,\n\t\t\tmap;\n\t\tif (sourceMaps && (agent.chrome && version >= 30\n\t\t\t\t|| agent.webkit && version >= 537.76\n\t\t\t\t|| agent.firefox && version >= 23\n\t\t\t\t|| agent.node)) {\n\t\t\tif (agent.node) {\n\t\t\t\toffset -= 2;\n\t\t\t} else if (window && url && !window.location.href.indexOf(url)) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\toffsetCode = offset > 0 && !(\n\t\t\t\t\tagent.chrome && version >= 36 ||\n\t\t\t\t\tagent.safari && version >= 600 ||\n\t\t\t\t\tagent.firefox && version >= 40 ||\n\t\t\t\t\tagent.node);\n\t\t\tvar mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1\n\t\t\t\t\t+ (offsetCode ? offset : 0);\n\t\t\tmap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url],\n\t\t\t\tsourcesContent: [source]\n\t\t\t};\n\t\t}\n\t\twalkAST(parse(code, { ranges: true, preserveParens: true }));\n\t\tif (map) {\n\t\t\tif (offsetCode) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code;\n\t\t\t}\n\t\t\tif (/^(inline|both)$/.test(sourceMaps)) {\n\t\t\t\tcode += \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ self.btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(map))));\n\t\t\t}\n\t\t\tcode += \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn {\n\t\t\turl: url,\n\t\t\tsource: source,\n\t\t\tcode: code,\n\t\t\tmap: map\n\t\t};\n\t}\n\n\tfunction execute(code, scope, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/\n\t\t\t\t\t.test(code) && !/\\bnew\\s+Tool\\b/.test(code)\n\t\t\t\t\t\t? new Tool() : null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc,\n\t\t\tcompiled = typeof code === 'object' ? code : compile(code, options);\n\t\tcode = compiled.code;\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\thandlers = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t}\n\t\t}, []).join(', ');\n\t\tif (handlers)\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\tvar agent = paper.agent;\n\t\tif (document && (agent.chrome\n\t\t\t\t|| agent.firefox && agent.versionNumber < 40)) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (agent.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = paper._execute;\n\t\t\tdelete paper._execute;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar res = func.apply(scope, args) || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = res[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (res.onResize)\n\t\t\t\tview.setOnResize(res.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (res.onFrame)\n\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\tview.requestUpdate();\n\t\t}\n\t\treturn compiled;\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: src,\n\t\t\t\t\tasync: async,\n\t\t\t\t\tmimeType: 'text/plain',\n\t\t\t\t\tonLoad: function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document && document.getElementsByTagName('script'),\n\t\t\t\tloadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (window) {\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse\n\t};\n\n}.call(this);\n\npaper = new (PaperScope.inject(Base.exports, {\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key,\n\tDomEvent: DomEvent,\n\tDomElement: DomElement,\n\tdocument: document,\n\twindow: window,\n\tSymbol: SymbolDefinition,\n\tPlacedSymbol: SymbolItem\n}))();\n\nif (paper.agent.node) {\n\trequire('./node/extend.js')(paper);\n}\n\nif (typeof define === 'function' && define.amd) {\n\tdefine('paper', paper);\n} else if (typeof module === 'object' && module) {\n\tmodule.exports = paper;\n}\n\nreturn paper;\n}.call(this, typeof self === 'object' ? self : null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/paper/dist/paper-full.js\n// module id = 19\n// module chunks = 1"],"sourceRoot":""}