{"version":3,"sources":["webpack:///js/app.patterns.js","webpack:///./src/js/app.patterns.js","webpack:///./~/acorn/dist/acorn.js","webpack:///./src/js/modules/patterns/index.js","webpack:///./src/js/utilities/settings.js","webpack:///./~/paper/dist/paper-full.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_helpers","_patterns","app","init","confetti","background","domReady","global","factory","this","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","nonASCIIidentifierStart","test","String","fromCharCode","astralIdentifierStartCodes","isIdentifierChar","nonASCIIidentifier","astralIdentifierCodes","binop","name","prec","TokenType","beforeExpr","kw","options","keyword","keywordTypes","isNewLine","has","obj","propName","hasOwnProperty","call","getLineInfo","input","offset","line","cur","lineBreakG","lastIndex","match","exec","index","Position","getOptions","opts","opt","defaultOptions","ecmaVersion","allowReserved","isArray","onToken","tokens","token","push","onComment","pushComment","array","block","text","start","end","startLoc","endLoc","comment","type","value","locations","loc","SourceLocation","ranges","range","keywordRegexp","words","RegExp","replace","finishNodeAt","node","tryCreateRegexp","src","flags","throwErrorAt","parser","e","undefined","SyntaxError","raise","message","codePointToString","parse","Parser","parseExpressionAt","p","nextToken","parseExpression","tokenizer","addLooseExports","plugins","parse_dammit","LooseParser","pluginsLoose","reservedWords","3","5","6","strict","strictBind","ecma5AndLessKeywords","keywords","nonASCIIidentifierStartChars","nonASCIIidentifierChars","label","conf","startsExpr","isLoop","isAssign","prefix","postfix","updateContext","tt","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","source","nonASCIIwhitespace","skipWhiteSpace","ref","Object","prototype","toString","Array","col","column","n","sourceFile","sourceType","onInsertedSemicolon","onTrailingComma","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","program","directSourceFile","preserveParens","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","isKeyword","word","isReservedWord","extend","f","pluginConfigs","this$1","plugin","Error","startNode","parseTopLevel","pp","literal","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","body","stmt","parseStatement","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","enterLexicalScope","parseFor","init$1","parseVar","declarations","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","isFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","statementStart","generator","createNewLexicalScope","update","left","right","isFor","decl","parseVarId","parseMaybeAssign","id","isStatement","allowExpressionBody","initFunction","async","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","method","isGenerator","isMaybeStatic","parsePropertyName","static","computed","key","isGetSet","parseClassMethod","paramCount","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","local","checkPatternExport","pat","properties","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","pp$2","isBinding","prop","toAssignableList","operator","exprList","last","arg","parseSpread","parseRest","allowNonIdent","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","startNodeAt","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","redefinition","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","canBeArrow","parseLiteral","regex","pattern","raw","parseParenAndDistinguishExpression","parseNew","val","spreadStart","innerParenStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isPattern","parsePropertyValue","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","liberal","indexOf","delegate","pp$4","err","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","pp$6","TokContext","isExpr","preserveSpace","override","types","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","readTmplToken","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","Token","pp$8","isRhino","Packages","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","ch","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","str","regexpUnicodeSupport","escaped","inClass","content","mods","readWord1","tmp","tmpFlags","validFlags","_match","Number","readInt","radix","total","Infinity","startsWithDot","isFloat","octal","parseFloat","parseInt","readCodePoint","codePos","readHexChar","quote","chunkStart","readEscapedChar","inTemplate","octalStr","substr","escStart","esc","version","tokTypes","tokContexts","defineProperty","_interopRequireDefault","__esModule","default","selector","document","querySelector","window","papers","_paper2","PaperScope","paperObj","install","addEventListener","randColor","_settings2","colors","randNumber","randPosition","view","bounds","width","height","randPositionX","Math","round","Point","random","x","setup","activate","items","shape","Path","Rectangle","point","fillColor","copy","clone","position","blendMode","rotate","scale","children","project","activeLayer","onFrame","rotationDirection","y","top","draw","color","selected","find","_paper","_settings","settings","speed","easing","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","paper","self","Base","inject","dest","enumerable","beans","preserve","field","describe","substring","bean","isFunc","res","prev","beansNames","toLowerCase","isPlainObject","writable","configurable","define","hidden","part","l","create","getOwnPropertyDescriptor","forEach","iter","bind","forIn","dst","each","desc","statics","ctor","initialize","apply","constructor","pick","a","b","list","begin","_id","_name","Formatter","instance","number","join","getClassName","importJSON","json","exportJSON","toJSON","serialize","props","exclude","filter","_prioritize","equals","obj1","obj2","keys","read","amount","peek","__index","readIndex","_readIndex","readNull","__read","filtered","__filtered","remain","readList","entry","readNamed","getNamed","hasObject","__unfiltered","_hasObject","hasNamed","prioritize","handleKey","processed","isPlainValue","asString","compact","dictionary","isRoot","formatter","precision","definitions","references","add","unshift","_serialize","_compactSerialize","deserialize","_data","_setDictionary","_isRoot","isFirst","hasDictionary","isDictionary","args","JSON","stringify","useTarget","Item","Layer","insert","splice","remove","append","_index","removed","capitalize","toUpperCase","camelize","chr","hyphenate","Emitter","on","func","_eventTypes","handlers","_callbacks","off","uninstall","once","emit","event","setTarget","currentTarget","stop","responds","attach","detach","fire","_installEvents","events","_events","isString","applyMatrix","insertItems","handleSize","hitTolerance","projects","tools","_scopes","support","ctx","CanvasProvider","getContext","nativeDash","nativeBlendModes","BlendMode","nativeModes","release","agent","user","navigator","userAgent","os","platform","browser","v1","v2","rv","chrome","versionNumber","webkit","atom","getView","_view","getPaper","execute","PaperScript","View","updateFocus","scope","that","element","Project","createCanvas","getCanvas","clear","handleAttribute","el","attr","getAttribute","hasAttribute","PaperScopeItem","_scope","_list","_reference","isActive","multiplier","pow","pair","val1","val2","separator","rectangle","Numerical","clamp","min","max","getDiscriminant","c","hi","D","E","abs","ad","bd","cd","dp","q","getNormalizationFactor","norm","log2","abscissas","weights","sqrt","log","LOG2E","EPSILON","MACHINE_EPSILON","CURVETIME_EPSILON","GEOMETRIC_EPSILON","TRIGONOMETRIC_EPSILON","KAPPA","isZero","integrate","w","A","B","m","sum","Ax","findRoot","df","tolerance","fx","dx","nx","solveQuadratic","roots","x1","x2","Q","R","count","boundless","minB","maxB","isFinite","solveCubic","d","evaluate","x0","b1","c2","qd","t","r","s","td","rd","UID","_pools","pool","arg0","arg1","reading","hasY","_set","setAngle","angle","getLength","setLength","_angle","cos","sin","getAngle","getAngleInRadians","PI","setAngleInRadians","getAngleInDegrees","setAngleInDegrees","div","NaN","acos","atan2","getQuadrant","getDirectedAngle","cross","getDistance","normalize","current","center","subtract","transform","matrix","_transformPoint","multiply","divide","negate","isInside","contains","isClose","isCollinear","isColinear","isOrthogonal","isNaN","isInQuadrant","point1","point2","y1","y2","LinkedPoint","owner","setter","_x","_y","_owner","_setter","_dontNotify","getX","setX","getY","setY","isSelected","_selection","_getSelection","setSelected","_changeSelection","Size","hasHeight","size1","size2","LinkedSize","_width","_height","getWidth","setWidth","getHeight","setHeight","arg2","arg3","from","to","frm","rect","rt","getPoint","_dontLink","setPoint","getSize","_fw","_fh","setSize","sx","_sx","sy","_sy","h","getLeft","setLeft","getTop","setTop","getRight","setRight","getBottom","setBottom","bottom","getCenterX","setCenterX","getCenterY","setCenterY","getCenter","setCenter","getArea","isEmpty","_containsRectangle","_containsPoint","intersects","epsilon","intersect","unite","include","expand","hor","ver","parts","xFirst","LinkedRectangle","internal","Matrix","ok","_a","_b","_c","_d","_tx","_ty","concat","reset","tx","ty","_changed","getValues","_applyMatrix","mx","recursively","_setApplyMatrix","isIdentity","translate","shear","skew","toRadians","tan","a1","c1","d1","a2","b2","d2","tx2","ty2","prepend","tx1","ty1","appended","prepended","invert","det","inverted","concatenate","preConcatenate","chain","_shiftless","_orNullIfIdentity","isInvertible","isSingular","_transformCoordinates","_transformCorners","coords","_transformBounds","j","inverseTransform","_inverseTransform","decompose","degrees","asin","translation","getTranslation","rotation","scaling","skewing","getScaling","getRotation","applyToContext","Line","arg4","asVector","_px","_py","_vx","_vy","getVector","isInfinite","getSide","getSignedDistance","p1x","p1y","v1x","v1y","p2x","p2y","v2x","v2y","dy","u1","u2","px","py","vx","vy","ccw","_children","_namedChildren","_activeLayer","_currentStyle","Style","_selectionItems","_selectionCount","_updateVersion","_needsUpdate","_requested","_autoUpdate","requestUpdate","changes","_changes","changesById","_changesById","getCurrentStyle","setCurrentStyle","style","getIndex","getLayers","getActiveLayer","getSymbolDefinitions","ids","getItems","class","SymbolItem","definition","_definition","getSymbols","getSelectedItems","selectionItems","selection","isInserted","_updateSelection","selectAll","setFullySelected","deselectAll","addLayer","layer","insertLayer","_remove","_setProject","setName","_insertItem","_created","NO_INSERT","insertChild","_getItems","getItem","removeOn","sets","_removeSets","mousedrag","pixelRatio","save","viewMatrix","matrices","updateMatrix","restore","strokeWidth","_drawSelection","_serializeFields","_canApplyMatrix","_canScaleStroke","_pivot","_visible","_blendMode","_opacity","_locked","_guide","_clipMask","_selectBounds","_selectChildren","pivot","visible","opacity","locked","guide","clipMask","data","_countItemEvent","_animateItem","onLoad","onError","_itemHandlers","_initialize","hasProps","_matrix","_parent","_style","fields","fontSize","Group","_defaults","symbol","_symbol","cacheParent","_project","_bounds","_position","_decomposed","_globalMatrix","_clearBoundsCache","getId","getName","_removeNamed","_getOwner","namedChildren","getStyle","setStyle","getSelection","setSelection","flag","isFullySelected","isClipMask","setClipMask","setFillColor","setStrokeColor","getData","setData","getPosition","getBounds","setPosition","getPivot","setPivot","getStrokeBounds","stroke","getHandleBounds","handle","getInternalBounds","hasMatrix","_boundsOptions","getStrokeScaling","cacheItem","_getCachedBounds","setBounds","_backup","_getBounds","_updateBoundsCache","_getBoundsCacheKey","noInternal","cacheKey","cached","nonscaling","hasStroke","_getStrokeMatrix","_item","getViewMatrix","_boundsCache","cache","_decompose","decomposed","setRotation","setScaling","getMatrix","setMatrix","getGlobalMatrix","_dontClone","updateVersion","getApplyMatrix","setApplyMatrix","getTransformContent","setTransformContent","getProject","installEvents","getLayer","getParent","setParent","addChild","getChildren","setChildren","removeChildren","addChildren","getFirstChild","getLastChild","getNextSibling","getPreviousSibling","_equals","deep","copyAttributes","copyContent","insertAbove","orig","excludeMatrix","rasterize","resolution","getResolution","topLeft","getTopLeft","floor","bottomRight","getBottomRight","ceil","raster","Raster","canvas","setCanvas","_contains","_asPathItem","getIntersections","hitTest","_hitTest","HitResult","hitTestAll","all","hitTestChildren","_exclude","child","_hitTestChildren","parentViewMatrix","hit","checkPoint","pt","tolerancePadding","guides","_tolerancePadding","_getStrokePadding","checkSelf","checkPosition","checkCenter","checkBounds","points","_hitTestSelf","fill","hasFill","matches","compare","matchObject","firstOnly","overlapping","inside","recursive","path","childMatrix","insertChildren","inserted","notifySelf","_insertAt","insertBelow","sendToBack","bringToFront","appendTop","appendBottom","moveAbove","moveBelow","addTo","copyTo","reduce","namedArray","notifyParent","replaceWith","reverseChildren","reverse","isEditable","hasShadow","_getOrder","getList","list1","list2","hasChildren","isAbove","isBelow","isParent","isChild","isDescendant","isAncestor","isSibling","isGroupedWith","_applyRecursively","getFillColor","strokeColor","getStrokeColor","_transformContent","decomp","applyRecursively","globalToLocal","localToGlobal","parentToLocal","localToParent","fitBounds","itemRatio","rectRatio","newBounds","_setStyles","fillStyle","toCanvasStyle","strokeStyle","lineWidth","getStrokeWidth","strokeJoin","getStrokeJoin","strokeCap","getStrokeCap","miterLimit","getMiterLimit","lineJoin","lineCap","dashArray","getDashArray","dashOffset","getDashOffset","setLineDash","lineDashOffset","mozDash","mozDashOffset","blur","getShadowBlur","getShadowOffset","shadowColor","getShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","parentStrokeMatrix","globalMatrix","mainCtx","itemOffset","prevOffset","normalBlend","nativeBlend","direct","dontStart","clip","_canComposite","strokeMatrix","clipItem","globalAlpha","globalCompositeOperation","setTransform","_draw","dontFinish","process","_isUpdated","CompoundPath","updated","itemSelected","boundsSelected","positionSelected","_drawSelected","getSelectedColor","half","beginPath","arc","deltas","delta","moveTo","lineTo","closePath","fillRect","hash","_clipItem","_getClipItem","isClipped","setClipped","clipped","Shape","radius","_type","_size","_radius","setType","setRadius","getType","getShape","setShape","getRadius","rad","toPath","toShape","dontPaint","untransformed","isCircle","rx","ry","kappa","cx","cy","bezierCurveTo","getFillRule","getCornerCenter","halfSize","dir","corner","quadrant","isOnEllipseStroke","padding","vector","hitStroke","hitFill","strokeRadius","strokePadding","outer","inner","createShape","Circle","Ellipse","ellipse","_readEllipse","crossOrigin","image","getElementById","setImage","setSource","_loaded","getSource","_image","_canvas","_setImage","copyCanvas","drawImage","_crossOrigin","getElement","getLoaded","u","getPpi","getImage","Event","setTimeout","DomEvent","load","error","complete","naturalWidth","naturalHeight","_context","modify","setContext","toDataURL","Image","getCrossOrigin","setCrossOrigin","getSubCanvas","getSubRaster","getAverageColor","PathItem","_sampleContext","clearRect","sampleSize","pixels","getImageData","channels","alpha","Color","getPixel","setPixel","components","_convert","_alpha","imageData","createImageData","putImageData","setImageData","setDefinition","SymbolDefinition","getDefinition","getSymbol","setSymbol","dontCenter","setItem","_dontCenter","place","values","segments","handles","ends","Segment","arg5","handleIn","handleOut","SegmentPoint","_point","hasHandles","_handleIn","_handleOut","_path","curve","curves","_curves","_closed","getHandleIn","setHandleIn","getHandleOut","setHandleOut","isSmooth","clearHandles","oldSelection","getPath","getCurve","_segments","getCurves","getLocation","CurveLocation","_segment1","getNext","smooth","_first","_last","factor","getPrevious","p0","p1","p2","k","d1_a","d1_2a","d2_a","d2_2a","N","isLast","reversed","removeSegment","segment","interpolate","handleIn1","handleIn2","handleOut2","handleOut1","change","Curve","arg6","arg7","seg1","seg2","handle1","handle2","segment1","segment2","_segment2","getPoint1","getHandle1","getHandle2","getPoint2","_length","classify","setPoint1","setPoint2","setHandle1","setHandle2","getSegment1","getSegment2","getPoints","getLine","getPart","getPartLength","divideAt","location","divideAtTime","time","getTimeAt","_setHandles","subdivide","setHandles","splitAt","splitAtTime","getLocationAtTime","isTime","straight","h1","h2","y0","x3","y3","x4","y4","x5","y5","x6","y6","x7","y7","x8","y8","x9","y9","getMonoCurves","io","o0","o1","o2","o3","isStraight","sort","coord","v0","v3","getTimeOf","p3","getNearestTime","refine","dist","minDist","minT","step","flip","isFlatEnough","flatness","ux","uy","_addBounds","minPad","maxPad","s1","s2","isLinear","third","hasLength","isHorizontal","getTangentAtTime","isVertical","getLocationAt","_isTime","getParameterAt","getOffsetAtTime","getLocationOf","getOffsetOf","getOffset","getParameterOf","getNearestLocation","getNearestPoint","methods","_evaluateMethods","getLengthIntegrand","ax","bx","ay","by","getIterations","normalized","t1","t2","hasRoots","t1Ok","t2Ok","a3","d3","f1","f2","ds","forward","rangeLength","diff","guess","getTangent","getWeightedTangent","getNormal","getWeightedNormal","getCurvature","getPeaks","addLocation","overlap","excludeStart","excludeEnd","loc1","loc2","_intersection","addCurveIntersections","recursion","calls","tMin","tMax","uMin","uMax","tMinClip","tMaxClip","q0x","q0y","q3x","q3y","dMin","dMax","dp0","dp1","dp2","dp3","hull","getConvexHull","clipConvexHull","tMinNew","tMaxNew","dq0","dq1","dq2","dq3","dist1","dist2","distRatio","hullTop","hullBottom","clipConvexHullPart","threshold","qx","qy","getCurveLineIntersections","addCurveLineIntersections","addLineIntersection","getCurveIntersections","overlaps","getOverlaps","straight1","straight2","before","i1","i2","getLoopIntersection","info","curves1","curves2","matrix1","matrix2","_returnFirst","length1","length2","values2","arrays","curve1","values1","path1","getSquaredLineLength","straightBoth","l1","l2","pairs","_overlap","_distance","_setCurve","_time","getPointAtTime","_next","_previous","_version","_curve","_segment","_setSegment","getSegment","getTime","trySegment","_offset","_curveOffset","getParameter","getCurveOffset","getIntersection","getLastSegment","_ignoreOther","isTouching","inter","curve2","isCrossing","addOffsets","offsets","isInRange","t1Inside","t2Inside","c4","c3","getPointAt","v4","a4","hasOverlap","merge","search","found","path2","expanded","compound","pathData","isClockwise","setClockwise","clockwise","setPathData","getCoord","relative","previous","control","command","lower","move","cubicCurveTo","quadraticCurveTo","arcTo","winding","_getWinding","onPath","windingL","windingR","getCrossings","minLoc","isPath","itemsFrom","itemsTo","setClosed","paths1","paths2","matched","closed","setSegments","_segmentSelection","_area","getSegments","fullySelected","_add","getFirstSegment","_countCurves","getFirstCurve","getLastCurve","isClosed","getPathData","_precision","addSegment","skipLine","curX","curY","inX","inY","outX","prevX","outY","prevY","segs","_adjustCurves","insertSegment","addSegments","insertSegments","removeSegments","_includeCurves","area","_selectSegments","newSelection","last1","last2","first2","first1","simplify","flatten","flattener","PathFlattener","PathFitter","fit","asymmetric","paddingLeft","paddingRight","knots","n_1","rf","hx","hy","seg3","seg4","isArc","pt1","pt2","topCenter","pos2","end2","pos1","end1","start2","isCloseEnough","checkSegmentPoint","seg","anchor","checkSegmentPoints","addToArea","checkSegmentStroke","isJoin","numSegments","cap","_addBevelJoin","_addSquareCap","hitCurves","drawHandles","drawHandle","hX","hY","pX","pY","drawSegments","drawSegment","dashLength","drawPart","getCurrentSegment","moveBy","curveTo","through","extent","middle","large","rxSq","rySq","xSq","ySq","throughSide","centerSide","ext","inc","z","lineBy","curveBy","parameter","cubicCurveBy","quadraticCurveBy","arcBy","processSegment","prevCoords","addPoint","addRound","joinBounds","addJoin","addCap","phi","isArea","normal1","getNormalAtTime","normal2","normal","joinPadding","joinRadius","SQRT2","paddingX","paddingY","xn","xx","yn","yx","createPath","createEllipse","ellipseSegments","bl","getBottomLeft","tl","tr","getTopRight","br","RoundRectangle","Oval","Arc","RegularPolygon","sides","three","Star","radius1","radius2","paths","getCurrentPath","check","preparePath","resolve","resolveCrossings","reorient","createResult","traceBoolean","operation","collect","_overlapsOnly","trace","splitBoolean","_path1","_path2","operators","crossings","divideLocations","propagateWinding","_winding","tracePaths","reorientPaths","addPath","added","linkIntersections","clearCurveHandles","lookup","container","sorted","entry1","getInteriorPoint","containerWinding","entry2","clearLater","renormalizeLocs","prevCurve","prevTime","results","clearCurves","clearLookup","origTime","newCurve","getWinding","dontFlip","addWinding","po","a0","ia","paR","paL","windingPrev","vPrev","a3Prev","pathWindingL","pathWindingR","pa","qualityEpsilon","quality","handleCurve","monoCurves","vClose","pv","onAnyPath","totalLength","curveLength","operand","SQRT1_2","wind","isValid","_visited","isStart","starts","visitPath","inter1","inter2","over1","over2","branch","visited","valid","finished","branches","collectStarts","nextInter","_prev","shift","1","2","-1","hasOverlaps","hasCrossings","intersections","nonZero","intercepts","mv","mo0","mo3","maxRecursion","ignoreStraight","addCurve","computeParts","minSpan","halves","tMid","_get","fitCubic","tan1","tan2","uPrime","chordLengthParameterize","maxError","parametersInOrder","generateBezier","findMaxError","reparameterize","tanCenter","C","X","b0","b3","alpha1","alpha2","detC0C1","detC0X","c0","segLength","eps","degree","maxDist","P","TextItem","_content","_lines","setContent","getContent","getCharacterStyle","setCharacterStyle","getParagraphStyle","setParagraphStyle","PointText","lines","leading","getLeading","font","getFontStyle","textAlign","getJustification","fillText","strokeText","numLines","justification","getTextWidth","fromCSS","colorCache","colorCtx","gray","rgb","hsb","hsl","gradient","componentParsers","hsbIndices","converters","rgb-hsb","g","hsb-rgb","rgb-hsl","achromatic","hsl-rgb","t3s","t3","rgb-gray","gray-rgb","gray-hsb","gray-hsl","gradient-rgb","rgb-gradient","_components","Gradient","_removeOwner","_addOwner","_properties","argType","parsers","stops","radial","getComponents","_canvasStyle","converter","convert","getAlpha","setAlpha","hasAlpha","isGradient","toCSS","hex","canvasGradient","_stops","origin","destination","highlight","inverse","_radial","createRadialGradient","createLinearGradient","addColorStop","_color","_types","components1","components2","setStops","setRadial","_owners","getStops","GradientStop","getRadial","stops1","stops2","rampPoint","setColor","setOffset","getRampPoint","setRampPoint","getColor","itemDefaults","fillRule","strokeScaling","shadowOffset","selectedColor","groupDefaults","fontFamily","fontWeight","textDefaults","_values","isColor","isPoint","old","_dontMerge","childValue","Font","WindingRule","isStyle","style1","style2","secondary","defaults2","value1","value2","getFontSize","getFontWeight","getFontFamily","getFont","setFont","getPixelSize","DomElement","handlePrefix","prefixes","suffix","getStyles","doc","nodeType","ownerDocument","defaultView","getComputedStyle","viewport","html","documentElement","getBoundingClientRect","clientLeft","clientTop","pageXOffset","scrollLeft","pageYOffset","scrollTop","getViewportBounds","innerWidth","clientWidth","innerHeight","clientHeight","isInvisible","isInView","getPrefixed","setPrefixed","removeEventListener","targetTouches","changedTouches","pageX","clientX","pageY","clientY","getTarget","srcElement","getRelatedTarget","relatedTarget","toElement","requestAnimationFrame","handleCallbacks","functions","callbacks","requested","nativeRequest","timer","callback","setInterval","getCanvasSize","setAttribute","_viewEvents","userDrag","userSelect","touchCallout","contentZooming","tapHighlightColor","_windowEvents","resize","setViewSize","Stats","_stats","stats","domElement","appendChild","_element","_pixelRatio","devicePixelRatio","_setElementSize","_viewSize","_views","_viewsById","_focused","_frameItems","_frameItemCount","_itemEvents","native","virtual","_animate","play","pause","_count","getAutoUpdate","setAutoUpdate","autoUpdate","_handleFrame","now","Date","animate","_handleFrameItems","getPixelRatio","getViewSize","isVisible","parentNode","temp","createElement","removeChild","getZoom","setZoom","zoom","scrollBy","projectToView","viewToProject","getEventPoint","CanvasView","tempFocus","handleMouseMove","_handleMouseEvent","emitMouseEvent","prevPoint","stopItem","mouseEvent","MouseEvent","called","prevented","stopped","fallback","fallbacks","emitMouseEvents","hitItem","dragItem","prevFocus","mousedown","mousemove","mouseup","dragging","mouseDown","pointerEnabled","msPointerEnabled","viewEvents","docEvents","mouseout","nodeName","scroll","overView","downPoint","lastPoint","downItem","overItem","clickItem","clickTime","dblClick","doubleclick","wasInView","itemEventsMap","click","mouseenter","mouseleave","itemEvents","tool","hitItems","nativeMove","inView","mouse","drag","down","up","preventDefault","_handleKeyEvent","character","keyEvent","KeyEvent","sign","HTMLCanvasElement","deviceRatio","backingStoreRatio","firefox","prevFont","measureText","stopPropagation","getTimeStamp","timeStamp","getModifiers","Key","modifiers","getKey","keyIdentifier","keyCode","keyLookup","keyMap","charMap","mac","metaFixMap","downKey","\t"," ","\b","","Spacebar","Del","Win","Esc","charLookup","tab","space","enter","alt","capsLock","option","keydown","altKey","metaKey","ctrlKey","keypress","charCode","keyup","isDown","ToolEvent","_choosePoint","toolPoint","getLastPoint","_lastPoint","setLastPoint","getDownPoint","_downPoint","setDownPoint","getMiddlePoint","_middlePoint","setMiddlePoint","middlePoint","getDelta","_delta","setDelta","getCount","setCount","Tool","_moveCount","_downCount","getMinDistance","_minDistance","setMinDistance","minDistance","_maxDistance","getMaxDistance","setMaxDistance","maxDistance","getFixedDistance","setFixedDistance","distance","Http","request","xhr","XMLHttpRequest","open","url","mimeType","overrideMimeType","onload","status","responseText","onerror","send","canvases","getLum","setLum","dr","dg","db","mn","lmn","ln","mxl","getSat","setSat","md","sr","sg","sb","sa","bg","bb","ba","modes","screen","overlay","soft-light","hard-light","color-dodge","color-burn","darken","lighten","difference","exclusion","hue","saturation","luminosity","average","negation","mode","srcContext","dstContext","srcCanvas","dstData","SvgElement","attributes","createElementNS","svg","namespace","attributeNamespace","getAttributeNS","setAttributeNS","xmlns","xlink","href","xmlns:xlink","SvgStyles","true","false","attribute","toSVG","fromSVG","exportFilter","getTransform","coordinates","attrs","trans","exportGroup","childNode","exportSVG","clip-path","exportRaster","embedImages","exportPath","matchShapes","exportShape","exportCompoundPath","exportSymbolItem","definitionItem","viewBox","overflow","exportGradient","gradientNode","getGradient","getOrigin","getDestination","getHighlight","fy","gradientUnits","stopColor","exportText","textContent","applyStyle","visibility","svgs","__id","typeId","exportDefinitions","defs","insertBefore","firstChild","XMLSerializer","serializeToString","exporter","exporters","onExport","setOptions","getValue","allowNull","allowPercent","rootSize","convertValue","map","importGroup","childNodes","isClip","isDefs","currentStyle","applyAttributes","querySelectorAll","importNode","importPoly","importPath","importGradient","scaleToBounds","_scaleToBounds","applyTransform","transforms","applyOpacity","styles","tagName","isElement","nextSibling","importer","importers","onImport","expandShapes","importSVG","DOMParser","parseFromString","File","reader","FileReader","readAsText","#document","clippath","polygon","polyline","lineargradient","radialgradient","use","circle","trim","gradientTransform","fill-opacity","stroke-opacity","setVisible","display","stop-color","stop-opacity","percent","group","acorn","__$__","binaryOperators","$__","unaryOperators","compile","insertions","insertion","getCode","getBetween","replaceCode","walkAST","between","parentType","exp","offsetCode","sourceMaps","lineBreaks","getElementsByTagName","innerHTML","safari","mappings","file","names","sourceRoot","sourcesContent","btoa","unescape","encodeURIComponent","expose","toolHandlers","compiled","script","head","createTextNode","_execute","Function","onResize","setOnResize","setOnFrame","loadScript","canvasId","baseURI","loadAll","root","mod","tokPos","makePredicate","compareTo","arr","cats","cat","line_loc_t","tokCurLine","tokLineStart","initTokenState","tokRegexpAllowed","tokEnd","tokEndLoc","tokVal","inputLen","_dot","_assign","_slash","readToken_mult_modulo","_multiplyModulo","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseAND","_bitwiseXOR","newline","lastEnd","_incDec","_plusMin","_bitShift","_relational","_equality","_eq","_prefix","_parenL","_parenR","_semi","_comma","_bracketL","_bracketR","_braceL","_braceR","_colon","_question","readHexNumber","forceRegexp","tokStart","tokStartLoc","_eof","tok","_regexp","_num","_string","escStr","lastStart","lastEndLoc","setStrict","strct","node_t","node_loc_t","startNodeFrom","isUseStrict","strictSemicolons","isStrictBadIdWord","guard","guardedHandlers","allowStrict","noComma","isUpdate","atomValue","tokStartLoc1","tokStart1","sawGetSet","allowTrailingCommas","conflict","isStrictReservedWord","forbidReserved","isReservedWord3","isReservedWord5","inpt","tokenize","jumpTo","reAllowed","break","case","catch","continue","debugger","do","else","finally","for","function","if","return","switch","throw","try","while","with","null","new","in","instanceof","typeof","void","delete","+","-","*","/","%","==","!=","__self","readyState","PlacedSymbol"],"mappings":"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","file":"js/app.patterns.js","sourcesContent":["webpackJsonp([1],[\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _helpers = __webpack_require__(0);\n\nvar _patterns = __webpack_require__(11);\n\nvar app = {\n  init: function init() {\n    (0, _patterns.confetti)('#pattern-cover');\n    (0, _patterns.background)('#pattern-reference', 'cyan');\n    (0, _patterns.background)('#pattern-availability', 'yellow');\n    (0, _patterns.background)('#pattern-resume', 'purple');\n  }\n};\n\n(0, _helpers.domReady)(app.init);\n\n/***/ }),\n/* 3 */,\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36\n  if (code < 58) return true\n  if (code < 65) return false\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label\n  this.keyword = conf.keyword\n  this.beforeExpr = !!conf.beforeExpr\n  this.startsExpr = !!conf.startsExpr\n  this.isLoop = !!conf.isLoop\n  this.isAssign = !!conf.isAssign\n  this.prefix = !!conf.prefix\n  this.postfix = !!conf.postfix\n  this.binop = conf.binop || null\n  this.updateContext = null\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n// Map keyword names to token types.\n\nvar keywordTypes = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name\n  return keywordTypes[name] = new TokenType(name, options)\n}\n\nvar tt = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\nvar lineBreakG = new RegExp(lineBreak.source, \"g\")\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); })\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line\n  this.column = col\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start\n  this.end = end\n  if (p.sourceFile !== null) this.source = p.sourceFile\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    var match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {}\n\n  for (var opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (options.ecmaVersion >= 2015)\n    options.ecmaVersion -= 2009\n\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken\n    options.onToken = function (token) { return tokens.push(token); }\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n// Registered plugins\nvar plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options)\n  this.sourceFile = options.sourceFile\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n  var reserved = \"\"\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      if (reserved = reservedWords[v]) break\n    if (options.sourceType == \"module\") reserved += \" await\"\n  }\n  this.reservedWords = keywordRegexp(reserved)\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n  this.reservedWordsStrict = keywordRegexp(reservedStrict)\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n  this.input = String(input)\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false\n\n  // Load plugins\n  this.loadPlugins(options.plugins)\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n  } else {\n    this.pos = this.lineStart = 0\n    this.curLine = 1\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = tt.eof\n  // For tokens that include more information than their type, the value\n  this.value = null\n  // Its start and end offset\n  this.start = this.end = this.pos\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition()\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null\n  this.lastTokStart = this.lastTokEnd = this.pos\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext()\n  this.exprAllowed = true\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\"\n  this.strict = this.inModule || this.strictDirective(this.pos)\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0\n  // Labels in scope.\n  this.labels = []\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    this.skipLineComment(2)\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = []\n  this.enterFunctionScope()\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode()\n  this.nextToken()\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^']|\\.)*)'|\"((?:[^\"]|\\.)*)\"|;)/\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start\n    start += skipWhiteSpace.exec(this$1.input)[0].length\n    var match = literal.exec(this$1.input.slice(start))\n    if (!match) return false\n    if ((match[1] || match[2]) == \"use strict\") return true\n    start += match[0].length\n  }\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    if (!notNext)\n      this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1\n};\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) return\n  if (refDestructuringErrors.trailingComma > -1)\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\")\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind\n  if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1\n  if (!andThrow) return pos >= 0\n  if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\")\n  if (this.awaitPos)\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\")\n}\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    return this.isSimpleAssignTarget(expr.expression)\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n}\n\nvar pp$1 = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    var stmt = this$1.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\npp$1.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) ++pos\n    var ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp$1.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.enterLexicalScope()\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  var isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init$1, true, kind)\n    this.finishNode(init$1, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      return this.parseForIn(node, init$1)\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors\n  var init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp$1.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp$1.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n  this.enterLexicalScope()\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur\n  for (var sawDefault = false; this.type != tt.braceR;) {\n    if (this$1.type === tt._case || this$1.type === tt._default) {\n      var isCase = this$1.type === tt._case\n      if (cur) this$1.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this$1.startNode())\n      cur.consequent = []\n      this$1.next()\n      if (isCase) {\n        cur.test = this$1.parseExpression()\n      } else {\n        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this$1.expect(tt.colon)\n    } else {\n      if (!cur) this$1.unexpected()\n      cur.consequent.push(this$1.parseStatement(true))\n    }\n  }\n  this.exitLexicalScope()\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp$1.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = []\n\npp$1.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    var clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.enterLexicalScope()\n    this.checkLVal(clause.param, \"let\")\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock(false)\n    this.exitLexicalScope()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp$1.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp$1.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.labels.length; ++i)\n    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n    var label = this$1.labels[i$1]\n    if (label.statementStart == node.start) {\n      label.statementStart = this$1.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  if (createNewLexicalScope) {\n    this.enterLexicalScope()\n  }\n  while (!this.eat(tt.braceR)) {\n    var stmt = this$1.parseStatement(true)\n    node.body.push(stmt)\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope()\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  this.exitLexicalScope()\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  this.exitLexicalScope()\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    var decl = this$1.startNode()\n    this$1.parseVarId(decl, kind)\n    if (this$1.eat(tt.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n    if (!this$1.eat(tt.comma)) break\n  }\n  return node\n}\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind)\n  this.checkLVal(decl.id, kind, false)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != tt.name ? null : this.parseIdent()\n    if (node.id) {\n      this.checkLVal(node.id, \"var\")\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n  this.enterFunctionScope()\n\n  if (!isStatement)\n    node.id = this.type == tt.name ? this.parseIdent() : null\n\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next()\n\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  var classBody = this.startNode()\n  var hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this$1.eat(tt.semi)) continue\n    var method = this$1.startNode()\n    var isGenerator = this$1.eat(tt.star)\n    var isAsync = false\n    var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n    this$1.parsePropertyName(method)\n    method.static = isMaybeStatic && this$1.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this$1.unexpected()\n      isGenerator = this$1.eat(tt.star)\n      this$1.parsePropertyName(method)\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    var isGetSet = false\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this$1.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start\n        if (method.kind === \"get\")\n          this$1.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null\n}\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    var isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync)\n    } else if (this.type === tt._class) {\n      var cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, \"nullableID\")\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n          this$1.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (has(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (var i = 0; i < pat.properties.length; ++i)\n      this$1.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1]\n      if (elt) this$1.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) return\n  for (var i = 0; i < decls.length; i++)\n    this$1.checkPatternExport(exports, decls[i].id)\n}\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node = this$1.startNode()\n    node.local = this$1.parseIdent(true)\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n    this$1.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, \"let\")\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    var node$1 = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node$1.local = this.parseIdent()\n    this.checkLVal(node$1.local, \"let\")\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node$2 = this$1.startNode()\n    node$2.imported = this$1.parseIdent(true)\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent()\n    } else {\n      node$2.local = node$2.imported\n      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n    }\n    this$1.checkLVal(node$2.local, \"let\")\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n\nvar pp$2 = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (var i = 0; i < node.properties.length; i++) {\n        var prop = node.properties[i]\n        if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this$1.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length\n  if (end) {\n    var last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      var arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i]\n    if (elt) this$1.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp$2.parseRest = function(allowNonIdent) {\n  var node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    var node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this$1.expect(tt.comma)\n    if (allowEmpty && this$1.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === tt.ellipsis) {\n      var rest = this$1.parseRest(allowNonIdent)\n      this$1.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n      this$1.expect(close)\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n      this$1.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp$2.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"))\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name)\n      } else {\n        this.declareLexicalName(expr.name)\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) this.raiseRecoverable(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0; i < expr.properties.length; i++)\n      this$1.checkLVal(expr.properties[i].value, bindingType, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n      var elem = expr.elements[i$1]\n      if (elem) this$1.checkLVal(elem, bindingType, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  var key = prop.key;\n  var name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  var other = propHash[name]\n  if (other) {\n    var redefinition\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set\n    } else {\n      redefinition = other.init || other[kind]\n    }\n    if (redefinition)\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    oldTrailingComma = refDestructuringErrors.trailingComma\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  var startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    var node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      var op = this.value\n      this.next()\n      var startPos = this.start, startLoc = this.startLoc\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.operator = this$1.value\n      node$1.prefix = false\n      node$1.argument = expr\n      this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$1, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprAtom(refDestructuringErrors)\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  var result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (var computed;;) {\n    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this$1.expect(tt.bracketR)\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this$1.eat(tt.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos\n      this$1.yieldPos = 0\n      this$1.awaitPos = 0\n      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false)\n        this$1.checkYieldAwaitInDefaultParams()\n        this$1.yieldPos = oldYieldPos\n        this$1.awaitPos = oldAwaitPos\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true)\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.callee = base\n      node$1.arguments = exprList\n      base = this$1.finishNode(node$1, \"CallExpression\")\n    } else if (this$1.type === tt.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc)\n      node$2.tag = base\n      node$2.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    var startPos = this.start, startLoc = this.startLoc\n    var id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    var value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp$3.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  var val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc\n    var exprList = [], first = true, lastIsComma = false\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        spreadStart = this$1.start\n        exprList.push(this$1.parseParenItem(this$1.parseRest()))\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this$1.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this$1.start\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp$3.parseParenItem = function(item) {\n  return item\n}\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = []\n\npp$3.parseNew = function() {\n  var node = this.startNode()\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty$1\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp$3.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.expect(tt.dollarBraceL)\n    node.expressions.push(this$1.parseExpression())\n    this$1.expect(tt.braceR)\n    node.quasis.push(curElt = this$1.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start\n        startLoc = this$1.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this$1.eat(tt.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL &&\n        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this$1.checkPropClash(prop, propHash)\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    var paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n  this.enterFunctionScope()\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.enterFunctionScope()\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== tt.braceL\n  var oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n    this.checkParams(node, false)\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params))\n    node.body = this.parseBlock(false)\n    node.expression = false\n    this.labels = oldLabels\n  }\n  this.exitFunctionScope()\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\")\n  }\n  this.strict = oldStrict\n}\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {}\n  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], \"var\", allowDuplicates ? null : nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n    } else first = false\n\n    var elt\n    if (allowEmpty && this$1.type === tt.comma)\n      elt = null\n    else if (this$1.type === tt.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this$1.start\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal) {\n  var node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\nvar pp$4 = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  var err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp$4.raiseRecoverable = pp$4.raise\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n}\n\nvar pp$5 = Parser.prototype\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0; i < sources.length; i++) {\n    var source = sources[i]\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  }\n  return target\n}\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}})\n}\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop()\n}\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1]\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}}\n\n  this.scopeStack.push(childScope)\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical)\n}\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop()\n  var parentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar)\n}\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n}\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n}\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true\n}\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true\n}\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\"\n  this.start = pos\n  this.end = 0\n  if (parser.options.locations)\n    this.loc = new SourceLocation(parser, loc)\n  if (parser.options.directSourceFile)\n    this.sourceFile = parser.options.directSourceFile\n  if (parser.options.ranges)\n    this.range = [pos, 0]\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n}\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type\n  node.end = pos\n  if (this.options.locations)\n    node.loc.end = loc\n  if (this.options.ranges)\n    node.range[1] = pos\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n}\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n}\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token\n  this.isExpr = !!isExpr\n  this.preserveSpace = !!preserveSpace\n  this.override = override\n  this.generator = !!generator\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n}\n\nvar pp$7 = Parser.prototype\n\npp$7.initialContext = function() {\n  return [types.b_stat]\n}\n\npp$7.braceIsBlock = function(prevType) {\n  if (prevType === tt.colon) {\n    var parent = this.curContext()\n    if (parent === types.b_stat || parent === types.b_expr)\n      return !parent.isExpr\n  }\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR || prevType == tt.arrow)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 0; i--)\n    if (this$1.context[i].generator) return true\n  return false\n}\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  var out = this.context.pop(), cur\n  if (out === types.b_stat && (cur = this.curContext()) && cur.token === \"function\") {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n\ntt.star.updateContext = function(prevType) {\n  if (prevType == tt._function) {\n    if (this.curContext() === types.f_expr)\n      this.context[this.context.length - 1] = types.f_expr_gen\n    else\n      this.context.push(types.f_gen)\n  }\n  this.exprAllowed = true\n}\n\ntt.name.updateContext = function(prevType) {\n  var allowed = false\n  if (this.options.ecmaVersion >= 6) {\n    if (this.value == \"of\" && !this.exprAllowed ||\n        this.value == \"yield\" && this.inGeneratorContext())\n      allowed = true\n  }\n  this.exprAllowed = allowed\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type\n  this.value = p.value\n  this.start = p.start\n  this.end = p.end\n  if (p.options.locations)\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n  if (p.options.ranges)\n    this.range = [p.start, p.end]\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    this.options.onToken(new Token(this))\n\n  this.lastTokEnd = this.end\n  this.lastTokStart = this.start\n  this.lastTokEndLoc = this.endLoc\n  this.lastTokStartLoc = this.startLoc\n  this.nextToken()\n}\n\npp$8.getToken = function() {\n  this.next()\n  return new Token(this)\n}\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken()\n        return {\n          done: token.type === tt.eof,\n          value: token\n        }\n      }\n    }\n  }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext()\n  if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n  this.start = this.pos\n  if (this.options.locations) this.startLoc = this.curPosition()\n  if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n  if (curContext.override) return curContext.override(this)\n  else this.readToken(this.fullCharCodeAtPos())\n}\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    return this.readWord()\n\n  return this.getTokenFromCode(code)\n}\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n  var next = this.input.charCodeAt(this.pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition()\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n  this.pos = end + 2\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start\n    var match\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine\n      this$1.lineStart = match.index + match[0].length\n    }\n  }\n  if (this.options.onComment)\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos\n  var startLoc = this.options.onComment && this.curPosition()\n  var ch = this.input.charCodeAt(this.pos += startSkip)\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this$1.pos\n    ch = this$1.input.charCodeAt(this$1.pos)\n  }\n  if (this.options.onComment)\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment()\n        break\n      case 47:\n        this$1.skipLineComment(2)\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos\n      } else {\n        break loop\n      }\n    }\n  }\n}\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos\n  if (this.options.locations) this.endLoc = this.curPosition()\n  var prevType = this.type\n  this.type = type\n  this.value = val\n\n  this.updateContext(prevType)\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next >= 48 && next <= 57) return this.readNumber(true)\n  var next2 = this.input.charCodeAt(this.pos + 2)\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3\n    return this.finishToken(tt.ellipsis)\n  } else {\n    ++this.pos\n    return this.finishToken(tt.dot)\n  }\n}\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.slash, 1)\n}\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  var tokentype = code === 42 ? tt.star : tt.modulo\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size\n    tokentype = tt.starstar\n    next = this.input.charCodeAt(this.pos + 2)\n  }\n\n  if (next === 61) return this.finishOp(tt.assign, size + 1)\n  return this.finishOp(tokentype, size)\n}\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n}\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.bitwiseXOR, 1)\n}\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    return this.finishOp(tt.incDec, 2)\n  }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.plusMin, 1)\n}\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tt.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected()\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4)\n    this.skipSpace()\n    return this.nextToken()\n  }\n  if (next === 61) size = 2\n  return this.finishOp(tt.relational, size)\n}\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2\n    return this.finishToken(tt.arrow)\n  }\n  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n}\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(tt.parenL)\n  case 41: ++this.pos; return this.finishToken(tt.parenR)\n  case 59: ++this.pos; return this.finishToken(tt.semi)\n  case 44: ++this.pos; return this.finishToken(tt.comma)\n  case 91: ++this.pos; return this.finishToken(tt.bracketL)\n  case 93: ++this.pos; return this.finishToken(tt.bracketR)\n  case 123: ++this.pos; return this.finishToken(tt.braceL)\n  case 125: ++this.pos; return this.finishToken(tt.braceR)\n  case 58: ++this.pos; return this.finishToken(tt.colon)\n  case 63: ++this.pos; return this.finishToken(tt.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) break\n    ++this.pos\n    return this.finishToken(tt.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(tt.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n}\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size)\n  this.pos += size\n  return this.finishToken(type, str)\n}\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n    var ch = this$1.input.charAt(this$1.pos)\n    if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n    if (!escaped) {\n      if (ch === \"[\") inClass = true\n      else if (ch === \"]\" && inClass) inClass = false\n      else if (ch === \"/\" && !inClass) break\n      escaped = ch === \"\\\\\"\n    } else escaped = false\n    ++this$1.pos\n  }\n  var content = this.input.slice(start, this.pos)\n  ++this.pos\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1()\n  var tmp = content, tmpFlags = \"\"\n  if (mods) {\n    var validFlags = /^[gim]*$/\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\"\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code)\n          if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n          return \"x\"\n        })\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n        tmpFlags = tmpFlags.replace(\"u\", \"\")\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this)\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods)\n  }\n  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n}\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val\n    if (code >= 97) val = code - 97 + 10 // a\n    else if (code >= 65) val = code - 65 + 10 // A\n    else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n    else val = Infinity\n    if (val >= radix) break\n    ++this$1.pos\n    total = total * radix + val\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null\n\n  return total\n}\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2 // 0x\n  var val = this.readInt(radix)\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n  return this.finishToken(tt.num, val)\n}\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n  if (octal && this.pos == start + 1) octal = false\n  var next = this.input.charCodeAt(this.pos)\n  if (next === 46 && !octal) { // '.'\n    ++this.pos\n    this.readInt(10)\n    isFloat = true\n    next = this.input.charCodeAt(this.pos)\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos)\n    if (next === 43 || next === 45) ++this.pos // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    isFloat = true\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n  var str = this.input.slice(start, this.pos), val\n  if (isFloat) val = parseFloat(str)\n  else if (!octal || str.length === 1) val = parseInt(str, 10)\n  else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n  else val = parseInt(str, 8)\n  return this.finishToken(tt.num, val)\n}\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected()\n    var codePos = ++this.pos\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos)\n    ++this.pos\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n  } else {\n    code = this.readHexChar(4)\n  }\n  return code\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === quote) break\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(false)\n      chunkStart = this$1.pos\n    } else {\n      if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n      ++this$1.pos\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++)\n  return this.finishToken(tt.string, out)\n}\n\n// Reads template string tokens.\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && this$1.type === tt.template) {\n        if (ch === 36) {\n          this$1.pos += 2\n          return this$1.finishToken(tt.dollarBraceL)\n        } else {\n          ++this$1.pos\n          return this$1.finishToken(tt.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      return this$1.finishToken(tt.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(true)\n      chunkStart = this$1.pos\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      ++this$1.pos\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n      case 10:\n        out += \"\\n\"\n        break\n      default:\n        out += String.fromCharCode(ch)\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      chunkStart = this$1.pos\n    } else {\n      ++this$1.pos\n    }\n  }\n}\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos)\n  ++this.pos\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n      var octal = parseInt(octalStr, 8)\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1)\n        octal = parseInt(octalStr, 8)\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.raise(this.pos - 2, \"Octal literal in strict mode\")\n      }\n      this.pos += octalStr.length - 1\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n}\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos\n  var n = this.readInt(16, len)\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n  return n\n}\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false\n  var word = \"\", first = true, chunkStart = this.pos\n  var astral = this.options.ecmaVersion >= 6\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos()\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true\n      word += this$1.input.slice(chunkStart, this$1.pos)\n      var escStart = this$1.pos\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n      ++this$1.pos\n      var esc = this$1.readCodePoint()\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        this$1.raise(escStart, \"Invalid Unicode escape\")\n      word += codePointToString(esc)\n      chunkStart = this$1.pos\n    } else {\n      break\n    }\n    first = false\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n}\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1()\n  var type = tt.name\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word)\n    type = keywordTypes[word]\n  }\n  return this.finishToken(type, word)\n}\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.0.3\"\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos)\n  p.nextToken()\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\n// eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser, plugins) {\n  exports.parse_dammit = parse // eslint-disable-line camelcase\n  exports.LooseParser = Parser\n  exports.pluginsLoose = plugins\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = tt;\nexports.keywordTypes = keywordTypes;\nexports.TokContext = TokContext;\nexports.tokContexts = types;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\nexports.nonASCIIwhitespace = nonASCIIwhitespace;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n/***/ }),\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.background = exports.confetti = undefined;\n\nvar _paper = __webpack_require__(19);\n\nvar _paper2 = _interopRequireDefault(_paper);\n\nvar _helpers = __webpack_require__(0);\n\nvar _settings = __webpack_require__(15);\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.papers = {};\n\nfunction confetti() {\n  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n  var pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers['' + pattern.id] = new _paper2.default.PaperScope();\n  var paperObj = window.papers['' + pattern.id];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', function () {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function randColor() {\n      var selectedColor = _settings2.default.colors[(0, _helpers.randNumber)(0, _settings2.default.colors.length)];\n      return selectedColor.value;\n    }\n\n    function randPosition() {\n      return [(0, _helpers.randNumber)(1, paperObj.view.bounds.width), (0, _helpers.randNumber)(1, paperObj.view.bounds.height)];\n    }\n\n    function randPositionX() {\n      return Math.round(paperObj.Point.random().x * paperObj.view.size.width);\n    }\n\n    var density = 0.02;\n    var items = Math.round(area() / 100 * density);\n    var shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: randColor()\n    });\n\n    for (var i = 0; i < items; i++) {\n      var copy = shape.clone();\n\n      copy.size = [30, 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.fillColor = randColor();\n      copy.blendMode = 'multiply';\n      copy.rotate((0, _helpers.randNumber)(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale(i / items * (0, _helpers.randNumber)(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n    paperObj.view.update();\n    var children = paperObj.project.activeLayer.children;\n\n    paperObj.view.onFrame = function () {\n      for (var _i = 0; _i < items; _i++) {\n        var item = children[_i];\n        var rotationDirection = _i % 2 ? +1 : -1;\n\n        item.rotate(rotationDirection);\n        item.position.y += item.bounds.width / 30 + 1;\n\n        if (item.bounds.top > paperObj.view.size.height) {\n          item.position.y = -item.bounds.width;\n          item.position.x = randPositionX();\n        }\n      }\n    };\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nfunction background() {\n  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'white';\n\n  var pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers['' + pattern.id] = new _paper2.default.PaperScope();\n  var paperObj = window.papers['' + pattern.id];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', function () {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function selectColor(name) {\n      var selected = _settings2.default.colors.find(function (item) {\n        return item.name === name;\n      });\n      return selected ? selected.value : name;\n    }\n\n    function randPosition() {\n      return [(0, _helpers.randNumber)(1, paperObj.view.bounds.width), (0, _helpers.randNumber)(1, paperObj.view.bounds.height)];\n    }\n\n    var density = 0.02;\n    var items = Math.round(area() / 100 * density);\n    var shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: selectColor(color)\n    });\n\n    for (var i = 0; i < items; i++) {\n      var copy = shape.clone();\n\n      copy.size = [30, 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.rotate((0, _helpers.randNumber)(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale(i / items * (0, _helpers.randNumber)(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nexports.confetti = confetti;\nexports.background = background;\n\n/***/ }),\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar settings = {\n  speed: 500,\n  easing: 'easeInOutExpo',\n  colors: [{ name: 'red', value: '#DF6C74' }, { name: 'green', value: '#99C46D' }, { name: 'yellow', value: '#ecce79' }, { name: 'blue', value: '#63ADF5' }, { name: 'cyan', value: '#59B6C4' }, { name: 'orange', value: '#D09B5C' }, { name: 'purple', value: '#C575E4' }, { name: 'slate', value: '#5F697F' }]\n};\n\nexports.default = settings;\n\n/***/ }),\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Paper.js v0.11.4 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Wed Jun 7 16:56:44 2017 +0200\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2016 Juerg Lehni\n * http://scratchdisk.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * http://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = function(self, undefined) {\n\nself = self || __webpack_require__(25);\nvar window = self.window,\n\tdocument = self.document;\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\tarray = [],\n\t\tslice = array.slice,\n\t\tcreate = Object.create,\n\t\tdescribe = Object.getOwnPropertyDescriptor,\n\t\tdefine = Object.defineProperty,\n\n\t\tforEach = array.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this) {\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tset = Object.assign || function(dst) {\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tfor (var key in src) {\n\t\t\t\t\tif (src.hasOwnProperty(key))\n\t\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\n\t\teach = function(obj, iter, bind) {\n\t\t\tif (obj) {\n\t\t\t\tvar desc = describe(obj, 'length');\n\t\t\t\t(desc && typeof desc.value === 'number' ? forEach : forIn)\n\t\t\t\t\t.call(obj, iter, bind = bind || obj);\n\t\t\t}\n\t\t\treturn bind;\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res)) {\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t}\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable != null ? enumerable : !bean;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tvar src = arguments[i];\n\t\t\tif (src)\n\t\t\t\tset(this, src);\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn inject(Base, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, null, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, obj, l = arguments.length;\n\t\t\t\t\ti < l && !(ctor && proto); i++) {\n\t\t\t\tobj = arguments[i];\n\t\t\t\tctor = ctor || obj.initialize;\n\t\t\t\tproto = proto || obj.prototype;\n\t\t\t}\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = proto || create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}).inject({\n\t\tenumerable: false,\n\n\t\tinitialize: Base,\n\n\t\tset: Base,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src) {\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\tset: set,\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t},\n\n\t\t\tslice: function(list, begin, end) {\n\t\t\t\treturn slice.call(list, begin, end);\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (true)\n\tmodule.exports = Base;\n\nBase.inject({\n\tenumerable: false,\n\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\timportJSON: function(json) {\n\t\treturn Base.importJSON(json, this);\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\tset: function(props, exclude) {\n\t\tif (props)\n\t\t\tBase.filter(this, props, exclude, this._prioritize);\n\t\treturn this;\n\t}\n}, {\n\nbeans: false,\nstatics: {\n\texports: {},\n\n\textend: function extend() {\n\t\tvar res = extend.base.apply(this, arguments),\n\t\t\tname = res.prototype._class;\n\t\tif (name && !Base.exports[name])\n\t\t\tBase.exports[name] = res;\n\t\treturn res;\n\t},\n\n\tequals: function(obj1, obj2) {\n\t\tif (obj1 === obj2)\n\t\t\treturn true;\n\t\tif (obj1 && obj1.equals)\n\t\t\treturn obj1.equals(obj2);\n\t\tif (obj2 && obj2.equals)\n\t\t\treturn obj2.equals(obj1);\n\t\tif (obj1 && obj2\n\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\tvar length = obj1.length;\n\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\tlength = keys.length;\n\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tread: function(list, start, options, amount) {\n\t\tif (this === Base) {\n\t\t\tvar value = this.peek(list, start);\n\t\t\tlist.__index++;\n\t\t\treturn value;\n\t\t}\n\t\tvar proto = this.prototype,\n\t\t\treadIndex = proto._readIndex,\n\t\t\tbegin = start || readIndex && list.__index || 0,\n\t\t\tlength = list.length,\n\t\t\tobj = list[begin];\n\t\tamount = amount || length - begin;\n\t\tif (obj instanceof this\n\t\t\t|| options && options.readNull && obj == null && amount <= 1) {\n\t\t\tif (readIndex)\n\t\t\t\tlist.__index = begin + 1;\n\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t}\n\t\tobj = Base.create(proto);\n\t\tif (readIndex)\n\t\t\tobj.__read = true;\n\t\tobj = obj.initialize.apply(obj, begin > 0 || begin + amount < length\n\t\t\t\t? Base.slice(list, begin, begin + amount)\n\t\t\t\t: list) || obj;\n\t\tif (readIndex) {\n\t\t\tlist.__index = begin + obj.__read;\n\t\t\tvar filtered = obj.__filtered;\n\t\t\tif (filtered) {\n\t\t\t\tlist.__filtered = filtered;\n\t\t\t\tobj.__filtered = undefined;\n\t\t\t}\n\t\t\tobj.__read = undefined;\n\t\t}\n\t\treturn obj;\n\t},\n\n\tpeek: function(list, start) {\n\t\treturn list[list.__index = start || list.__index || 0];\n\t},\n\n\tremain: function(list) {\n\t\treturn list.length - (list.__index || 0);\n\t},\n\n\treadList: function(list, start, options, amount) {\n\t\tvar res = [],\n\t\t\tentry,\n\t\t\tbegin = start || 0,\n\t\t\tend = amount ? begin + amount : list.length;\n\t\tfor (var i = begin; i < end; i++) {\n\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t}\n\t\treturn res;\n\t},\n\n\treadNamed: function(list, name, start, options, amount) {\n\t\tvar value = this.getNamed(list, name),\n\t\t\thasObject = value !== undefined;\n\t\tif (hasObject) {\n\t\t\tvar filtered = list.__filtered;\n\t\t\tif (!filtered) {\n\t\t\t\tfiltered = list.__filtered = Base.create(list[0]);\n\t\t\t\tfiltered.__unfiltered = list[0];\n\t\t\t}\n\t\t\tfiltered[name] = undefined;\n\t\t}\n\t\tvar l = hasObject ? [value] : list,\n\t\t\tres = this.read(l, start, options, amount);\n\t\treturn res;\n\t},\n\n\tgetNamed: function(list, name) {\n\t\tvar arg = list[0];\n\t\tif (list._hasObject === undefined)\n\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\tif (list._hasObject)\n\t\t\treturn name ? arg[name] : list.__filtered || arg;\n\t},\n\n\thasNamed: function(list, name) {\n\t\treturn !!this.getNamed(list, name);\n\t},\n\n\tfilter: function(dest, source, exclude, prioritize) {\n\t\tvar processed;\n\n\t\tfunction handleKey(key) {\n\t\t\tif (!(exclude && key in exclude) &&\n\t\t\t\t!(processed && key in processed)) {\n\t\t\t\tvar value = source[key];\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\tdest[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tif (prioritize) {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0, key, l = prioritize.length; i < l; i++) {\n\t\t\t\tif ((key = prioritize[i]) in source) {\n\t\t\t\t\thandleKey(key);\n\t\t\t\t\tkeys[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed = keys;\n\t\t}\n\n\t\tObject.keys(source.__unfiltered || source).forEach(handleKey);\n\t\treturn dest;\n\t},\n\n\tisPlainValue: function(obj, asString) {\n\t\treturn Base.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t|| asString && typeof obj === 'string';\n\t},\n\n\tserialize: function(obj, options, compact, dictionary) {\n\t\toptions = options || {};\n\n\t\tvar isRoot = !dictionary,\n\t\t\tres;\n\t\tif (isRoot) {\n\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\tdictionary = {\n\t\t\t\tlength: 0,\n\t\t\t\tdefinitions: {},\n\t\t\t\treferences: {},\n\t\t\t\tadd: function(item, create) {\n\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t}\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (obj && obj._serialize) {\n\t\t\tres = obj._serialize(options, dictionary);\n\t\t\tvar name = obj._class;\n\t\t\tif (name && !obj._compactSerialize && (isRoot || !compact)\n\t\t\t\t\t&& res[0] !== name) {\n\t\t\t\tres.unshift(name);\n\t\t\t}\n\t\t} else if (Array.isArray(obj)) {\n\t\t\tres = [];\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\tres[i] = Base.serialize(obj[i], options, compact, dictionary);\n\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\tres = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\tdictionary);\n\t\t\t}\n\t\t} else if (typeof obj === 'number') {\n\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t} else {\n\t\t\tres = obj;\n\t\t}\n\t\treturn isRoot && dictionary.length > 0\n\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t: res;\n\t},\n\n\tdeserialize: function(json, create, _data, _setDictionary, _isRoot) {\n\t\tvar res = json,\n\t\t\tisFirst = !_data,\n\t\t\thasDictionary = isFirst && json && json.length\n\t\t\t\t&& json[0][0] === 'dictionary';\n\t\t_data = _data || {};\n\t\tif (Array.isArray(json)) {\n\t\t\tvar type = json[0],\n\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\tif (json.length == 1 && /^#/.test(type)) {\n\t\t\t\treturn _data.dictionary[type];\n\t\t\t}\n\t\t\ttype = Base.exports[type];\n\t\t\tres = [];\n\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++) {\n\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\tisDictionary, hasDictionary));\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tvar args = res;\n\t\t\t\tif (create) {\n\t\t\t\t\tres = create(type, args, isFirst || _isRoot);\n\t\t\t\t} else {\n\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Base.isPlainObject(json)) {\n\t\t\tres = {};\n\t\t\tif (_setDictionary)\n\t\t\t\t_data.dictionary = res;\n\t\t\tfor (var key in json)\n\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t}\n\t\treturn hasDictionary ? res[1] : res;\n\t},\n\n\texportJSON: function(obj, options) {\n\t\tvar json = Base.serialize(obj, options);\n\t\treturn options && options.asString == false\n\t\t\t\t? json\n\t\t\t\t: JSON.stringify(json);\n\t},\n\n\timportJSON: function(json, target) {\n\t\treturn Base.deserialize(\n\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\tfunction(ctor, args, isRoot) {\n\t\t\t\t\tvar useTarget = isRoot && target\n\t\t\t\t\t\t\t&& target.constructor === ctor,\n\t\t\t\t\t\tobj = useTarget ? target\n\t\t\t\t\t\t\t: Base.create(ctor.prototype);\n\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t&& (useTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t}\n\t\t\t\t\t(useTarget ? obj.set : ctor).apply(obj, args);\n\t\t\t\t\tif (useTarget)\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\treturn obj;\n\t\t\t\t});\n\t},\n\n\tsplice: function(list, items, index, remove) {\n\t\tvar amount = items && items.length,\n\t\t\tappend = index === undefined;\n\t\tindex = append ? list.length : index;\n\t\tif (index > list.length)\n\t\t\tindex = list.length;\n\t\tfor (var i = 0; i < amount; i++)\n\t\t\titems[i]._index = index + i;\n\t\tif (append) {\n\t\t\tlist.push.apply(list, items);\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar args = [index, remove];\n\t\t\tif (items)\n\t\t\t\targs.push.apply(args, items);\n\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\tremoved[i]._index = undefined;\n\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\tlist[i]._index = i;\n\t\t\treturn removed;\n\t\t}\n\t},\n\n\tcapitalize: function(str) {\n\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t},\n\n\tcamelize: function(str) {\n\t\treturn str.replace(/-(.)/g, function(match, chr) {\n\t\t\treturn chr.toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(str) {\n\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t}\n}});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, func);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = Base.slice(arguments, 1),\n\t\t\tsetTarget = event && event.target && !event.currentTarget;\n\t\thandlers = handlers.slice();\n\t\tif (setTarget)\n\t\t\tevent.currentTarget = this;\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) == false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t   }\n\t\t}\n\t\tif (setTarget)\n\t\t\tdelete event.currentTarget;\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar types = this._eventTypes,\n\t\t\thandlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tif (types) {\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar entry = types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\tinsertItems: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1) || {};\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\t\tif (!this.agent) {\n\t\t\tvar user = self.navigator.userAgent.toLowerCase(),\n\t\t\t\tos = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],\n\t\t\t\tplatform = os === 'darwin' ? 'mac' : os,\n\t\t\t\tagent = proto.agent = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tagent[platform] = true;\n\t\t\tuser.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g,\n\t\t\t\tfunction(match, n, v1, v2, rv) {\n\t\t\t\t\tif (!agent.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 :\n\t\t\t\t\t\t\t\t/^(node|trident)$/.test(n) ? rv : v1;\n\t\t\t\t\t\tagent.version = v;\n\t\t\t\t\t\tagent.versionNumber = parseFloat(v);\n\t\t\t\t\t\tn = n === 'trident' ? 'msie' : n;\n\t\t\t\t\t\tagent.name = n;\n\t\t\t\t\t\tagent[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (agent.chrome)\n\t\t\t\tdelete agent.webkit;\n\t\t\tif (agent.atom)\n\t\t\t\tdelete agent.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.11.4\",\n\n\tgetView: function() {\n\t\tvar project = this.project;\n\t\treturn project && project._view;\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, options) {\n\t\tpaper.PaperScript.execute(code, this, options);\n\t\tView.updateFocus();\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tcreateCanvas: function(width, height) {\n\t\treturn CanvasProvider.getCanvas(width, height);\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tvar projects = this.projects,\n\t\t\ttools = this.tools;\n\t\tfor (var i = projects.length - 1; i >= 0; i--)\n\t\t\tprojects[i].remove();\n\t\tfor (var i = tools.length - 1; i >= 0; i--)\n\t\t\ttools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._scope.getView();\n\t}\n});\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = Base.pick(precision, 5);\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn this.precision < 16\n\t\t\t\t? Math.round(val * this.multiplier) / this.multiplier : val;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tlog2 = Math.log2 || function(x) {\n\t\t\treturn Math.log(x) * Math.LOG2E;\n\t\t},\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clamp(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\tfunction getDiscriminant(a, b, c) {\n\t\tfunction split(v) {\n\t\t\tvar x = v * 134217729,\n\t\t\t\ty = v - x,\n\t\t\t\thi = y + x,\n\t\t\t\tlo = v - hi;\n\t\t\treturn [hi, lo];\n\t\t}\n\n\t\tvar D = b * b - a * c,\n\t\t\tE = b * b + a * c;\n\t\tif (abs(D) * 3 < E) {\n\t\t\tvar ad = split(a),\n\t\t\t\tbd = split(b),\n\t\t\t\tcd = split(c),\n\t\t\t\tp = b * b,\n\t\t\t\tdp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],\n\t\t\t\tq = a * c,\n\t\t\t\tdq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])\n\t\t\t\t\t\t+ ad[1] * cd[1];\n\t\t\tD = (p - q) + (dp - dq);\n\t\t}\n\t\treturn D;\n\t}\n\n\tfunction getNormalizationFactor() {\n\t\tvar norm = Math.max.apply(Math, arguments);\n\t\treturn norm && (norm < 1e-8 || norm > 1e8)\n\t\t\t\t? pow(2, -Math.round(log2(norm)))\n\t\t\t\t: 0;\n\t}\n\n\treturn {\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 1e-8,\n\t\tGEOMETRIC_EPSILON: 1e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-8,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tclamp: clamp,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance) {\n\t\t\t\t\tx = nx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clamp(x, a, b);\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar x1, x2 = Infinity;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(b) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / b;\n\t\t\t} else {\n\t\t\t\tb *= -0.5;\n\t\t\t\tvar D = getDiscriminant(a, b, c);\n\t\t\t\tif (D && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c));\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\ta *= f;\n\t\t\t\t\t\tb *= f;\n\t\t\t\t\t\tc *= f;\n\t\t\t\t\t\tD = getDiscriminant(a, b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0,\n\t\t\t\tboundless = min == null,\n\t\t\t\tminB = min - EPSILON,\n\t\t\t\tmaxB = max + EPSILON;\n\t\t\tif (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))\n\t\t\t\troots[count++] = boundless ? x1 : clamp(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))\n\t\t\t\troots[count++] = boundless ? x2 : clamp(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),\n\t\t\t\tx, b1, c2, qd, q;\n\t\t\tif (f) {\n\t\t\t\ta *= f;\n\t\t\t\tb *= f;\n\t\t\t\tc *= f;\n\t\t\t\td *= f;\n\t\t\t}\n\n\t\t\tfunction evaluate(x0) {\n\t\t\t\tx = x0;\n\t\t\t\tvar tmp = a * x;\n\t\t\t\tb1 = tmp + b;\n\t\t\t\tc2 = b1 * x + c;\n\t\t\t\tqd = (tmp + b1) * x + c2;\n\t\t\t\tq = c2 * x + d;\n\t\t\t}\n\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tevaluate(-(b / a) / 3);\n\t\t\t\tvar t = q / a,\n\t\t\t\t\tr = pow(abs(t), 1/3),\n\t\t\t\t\ts = t < 0 ? -1 : 1,\n\t\t\t\t\ttd = -qd / a,\n\t\t\t\t\trd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,\n\t\t\t\t\tx0 = x - s * rd;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tevaluate(x0);\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),\n\t\t\t\tboundless = min == null;\n\t\t\tif (isFinite(x) && (count === 0\n\t\t\t\t\t|| count > 0 && x !== roots[0] && x !== roots[1])\n\t\t\t\t\t&& (boundless || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = boundless ? x : clamp(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(name) {\n\t\tif (name) {\n\t\t\tvar pool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasY ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('angle' in obj) {\n\t\t\t\tthis._set(obj.length || 0, 0);\n\t\t\t\tthis.setAngle(obj.angle || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis._set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(arguments);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\ttolerance = Base.read(arguments);\n\t\treturn this.getDistance(point) <= tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.x) && isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tisInQuadrant: function(q) {\n\t\treturn this.x * (q > 1 && q < 4 ? -1 : 1) >= 0\n\t\t\t&& this.y * (q > 2 ? -1 : 1) >= 0;\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\treturn this._setter === 'setPosition' ? 4 : 0;\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasHeight ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.width) && isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar type = typeof arg0,\n\t\t\tread;\n\t\tif (type === 'number') {\n\t\t\tthis._set(arg0, arg1, arg2, arg3);\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0, 0, 0);\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis._set.apply(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis._set(arg0.x || 0, arg0.y || 0,\n\t\t\t\t\t\targ0.width || 0, arg0.height || 0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis._set(0, 0, 0, 0);\n\t\t\t\tBase.filter(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t}\n\t\t}\n\t\tif (read === undefined) {\n\t\t\tvar frm = Point.readNamed(arguments, 'from'),\n\t\t\t\tnext = Base.peek(arguments),\n\t\t\t\tx = frm.x,\n\t\t\t\ty = frm.y,\n\t\t\t\twidth,\n\t\t\t\theight;\n\t\t\tif (next && next.x !== undefined\n\t\t\t\t\t|| Base.hasNamed(arguments, 'to')) {\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\twidth = to.x - x;\n\t\t\t\theight = to.y - y;\n\t\t\t\tif (width < 0) {\n\t\t\t\t\tx = to.x;\n\t\t\t\t\twidth = -width;\n\t\t\t\t}\n\t\t\t\tif (height < 0) {\n\t\t\t\t\ty = to.y;\n\t\t\t\t\theight = -height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\twidth = size.width;\n\t\t\t\theight = size.height;\n\t\t\t}\n\t\t\tthis._set(x, y, width, height);\n\t\t\tread = arguments.__index;\n\t\t\tvar filtered = arguments.__filtered;\n\t\t\tif (filtered)\n\t\t\t\tthis.__filtered = filtered;\n\t\t}\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\t_fw: 1,\n\t_fh: 1,\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tsx = this._sx,\n\t\t\tsy = this._sy,\n\t\t\tw = size.width,\n\t\t\th = size.height;\n\t\tif (sx) {\n\t\t\tthis.x += (this.width - w) * sx;\n\t\t}\n\t\tif (sy) {\n\t\t\tthis.y += (this.height - h) * sy;\n\t\t}\n\t\tthis.width = w;\n\t\tthis.height = h;\n\t\tthis._fw = this._fh = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = left - this.x;\n\t\t\tthis.width -= this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = left;\n\t\tthis._sx = this._fw = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = top - this.y;\n\t\t\tthis.height -= this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = top;\n\t\tthis._sy = this._fh = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = right - this.x;\n\t\t\tthis.width = this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = right - this.width;\n\t\tthis._sx = 1;\n\t\tthis._fw = 0;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = bottom - this.y;\n\t\t\tthis.height = this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = bottom - this.height;\n\t\tthis._sy = 1;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width / 2;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tif (this._fw || this._sx === 0.5) {\n\t\t\tthis.x = x - this.width / 2;\n\t\t} else {\n\t\t\tif (this._sx) {\n\t\t\t\tthis.x += (x - this.x) * 2 * this._sx;\n\t\t\t}\n\t\t\tthis.width = (x - this.x) * 2;\n\t\t}\n\t\tthis._sx = 0.5;\n\t\tthis._fw = 0;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height / 2;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tif (this._fh || this._sy === 0.5) {\n\t\t\tthis.y = y - this.height / 2;\n\t\t} else {\n\t\t\tif (this._sy) {\n\t\t\t\tthis.y += (y - this.y) * 2 * this._sy;\n\t\t\t}\n\t\t\tthis.height = (y - this.y) * 2;\n\t\t}\n\t\tthis._sy = 0.5;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length === 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tepsilon = Base.read(arguments) || 0;\n\t\treturn rect.x + rect.width > this.x - epsilon\n\t\t\t\t&& rect.y + rect.height > this.y - epsilon\n\t\t\t\t&& rect.x < this.x + this.width + epsilon\n\t\t\t\t&& rect.y < this.y + this.height + epsilon;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join(''),\n\t\t\txFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis._set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tinternal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn !!(this._owner._selection & 2);\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner._changeSelection) {\n\t\t\t\t\towner._changeSelection(2, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg, _dontNotify) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count >= 6) {\n\t\t\tthis._set.apply(this, arguments);\n\t\t} else if (count === 1 || count === 2) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,\n\t\t\t\t\t\t_dontNotify);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis._set.apply(this,\n\t\t\t\t\t\t_dontNotify ? arg.concat([_dontNotify]) : arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (!count) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok) {\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t}\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(a, b, c, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._b = b;\n\t\tthis._c = c;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.getValues(), options, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(9);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._c),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._b), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._b = this._c = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t_setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._c;\n\t\tthis._ty += x * this._b + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar scale = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._b *= scale.x;\n\t\tthis._c *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * c;\n\t\tthis._b = cos * b + sin * d;\n\t\tthis._c = -sin * a + cos * c;\n\t\tthis._d = -sin * b + cos * d;\n\t\tthis._tx += tx * a + ty * c;\n\t\tthis._ty += tx * b + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar shear = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tb = this._b;\n\t\tthis._a += shear.y * this._c;\n\t\tthis._b += shear.y * this._d;\n\t\tthis._c += shear.x * a;\n\t\tthis._d += shear.x * b;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar skew = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tappend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * c1;\n\t\t\tthis._c = b2 * a1 + d2 * c1;\n\t\t\tthis._b = a2 * b1 + c2 * d1;\n\t\t\tthis._d = b2 * b1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * c1;\n\t\t\tthis._ty += tx2 * b1 + ty2 * d1;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tprepend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * b1;\n\t\t\tthis._c = a2 * c1 + b2 * d1;\n\t\t\tthis._b = c2 * a1 + d2 * b1;\n\t\t\tthis._d = c2 * c1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tappended: function(mx) {\n\t\treturn this.clone().append(mx);\n\t},\n\n\tprepended: function(mx) {\n\t\treturn this.clone().prepend(mx);\n\t},\n\n\tinvert: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tthis._a = d / det;\n\t\t\tthis._b = -b / det;\n\t\t\tthis._c = -c / det;\n\t\t\tthis._d = a / det;\n\t\t\tthis._tx = (c * ty - d * tx) / det;\n\t\t\tthis._ty = (b * tx - a * ty) / det;\n\t\t\tres = this;\n\t\t}\n\t\treturn res;\n\t},\n\n\tinverted: function() {\n\t\treturn this.clone().invert();\n\t},\n\n\tconcatenate: '#append',\n\tpreConcatenate: '#prepend',\n\tchain: '#appended',\n\n\t_shiftless: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n\t},\n\n\t_orNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\tisInvertible: function() {\n\t\tvar det = this._a * this._d - this._c * this._b;\n\t\treturn det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n\t},\n\n\tisSingular: function() {\n\t\treturn !this.isInvertible();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest._set(\n\t\t\t\tx * this._a + y * this._c + this._tx,\n\t\t\t\tx * this._b + y * this._d + this._ty,\n\t\t\t\t_dontNotify);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tfor (var i = 0, max = 2 * count; i < max; i += 2) {\n\t\t\tvar x = src[i],\n\t\t\t\ty = src[i + 1];\n\t\t\tdst[i] = x * this._a + y * this._c + this._tx;\n\t\t\tdst[i + 1] = x * this._b + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j]) {\n\t\t\t\tmin[j] = val;\n\t\t\t} else if (val > max[j]) {\n\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\tres = dest._set(\n\t\t\t\t\t(x * d - y * c) / det,\n\t\t\t\t\t(y * a - x * b) / det,\n\t\t\t\t\t_dontNotify);\n\t\t}\n\t\treturn res;\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\tdet = a * d - b * c,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tatan2 = Math.atan2,\n\t\t\tdegrees = 180 / Math.PI,\n\t\t\trotate,\n\t\t\tscale,\n\t\t\tskew;\n\t\tif (a !== 0 || b !== 0) {\n\t\t\tvar r = sqrt(a * a + b * b);\n\t\t\trotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n\t\t\tscale = [r, det / r];\n\t\t\tskew = [atan2(a * c + b * d, r * r), 0];\n\t\t} else if (c !== 0 || d !== 0) {\n\t\t\tvar s = sqrt(c * c + d * d);\n\t\t\trotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);\n\t\t\tscale = [det / s, s];\n\t\t\tskew = [0, atan2(a * c + b * d, s * s)];\n\t\t} else {\n\t\t\trotate = 0;\n\t\t\tskew = scale = [0, 0];\n\t\t}\n\t\treturn {\n\t\t\ttranslation: this.getTranslation(),\n\t\t\trotation: rotate * degrees,\n\t\t\tscaling: new Point(scale),\n\t\t\tskewing: new Point(skew[0] * degrees, skew[1] * degrees)\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._b, this._c, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn (this.decompose() || {}).scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn (this.decompose() || {}).rotation;\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tif (!this.isIdentity()) {\n\t\t\tctx.transform(this._a, this._b, this._c, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t}\n\t}\n}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {\n\tvar part = Base.capitalize(key),\n\t\tprop = '_' + key;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(this.getSignedDistance(point));\n\t},\n\n\tgetSignedDistance: function(point) {\n\t\treturn Line.getSignedDistance(this._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true);\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (!isInfinite && Numerical.isZero(ccw)) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t},\n\n\t\tgetDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\treturn Math.abs(\n\t\t\t\t\tLine.getSignedDistance(px, py, vx, vy, x, y, asVector));\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\t_compactSerialize: true,\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis._activeLayer = null;\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectionItems = {};\n\t\tthis._selectionCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this._children, options, true, dictionary);\n\t},\n\n\t_changed: function(flags, item) {\n\t\tif (flags & 1) {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview._needsUpdate = true;\n\t\t\t\tif (!view._requested && view._autoUpdate)\n\t\t\t\t\tview.requestUpdate();\n\t\t\t}\n\t\t}\n\t\tvar changes = this._changes;\n\t\tif (changes && item) {\n\t\t\tvar changesById = this._changesById,\n\t\t\t\tid = item._id,\n\t\t\t\tentry = changesById[id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tchanges.push(changesById[id] = { item: item, flags: flags });\n\t\t\t}\n\t\t}\n\t},\n\n\tclear: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--)\n\t\t\tchildren[i].remove();\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children.length;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.set(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetLayers: function() {\n\t\treturn this._children;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this, insert: true });\n\t},\n\n\tgetSymbolDefinitions: function() {\n\t\tvar definitions = [],\n\t\t\tids = {};\n\t\tthis.getItems({\n\t\t\tclass: SymbolItem,\n\t\t\tmatch: function(item) {\n\t\t\t\tvar definition = item._definition,\n\t\t\t\t\tid = definition._id;\n\t\t\t\tif (!ids[id]) {\n\t\t\t\t\tids[id] = true;\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn definitions;\n\t},\n\n\tgetSymbols: 'getSymbolDefinitions',\n\n\tgetSelectedItems: function() {\n\t\tvar selectionItems = this._selectionItems,\n\t\t\titems = [];\n\t\tfor (var id in selectionItems) {\n\t\t\tvar item = selectionItems[id],\n\t\t\t\tselection = item._selection;\n\t\t\tif ((selection & 1) && item.isInserted()) {\n\t\t\t\titems.push(item);\n\t\t\t} else if (!selection) {\n\t\t\t\tthis._updateSelection(item);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectionItems = this._selectionItems;\n\t\tif (item._selection) {\n\t\t\tif (selectionItems[id] !== item) {\n\t\t\t\tthis._selectionCount++;\n\t\t\t\tselectionItems[id] = item;\n\t\t\t}\n\t\t} else if (selectionItems[id] === item) {\n\t\t\tthis._selectionCount--;\n\t\t\tdelete selectionItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectionItems = this._selectionItems;\n\t\tfor (var i in selectionItems)\n\t\t\tselectionItems[i].setFullySelected(false);\n\t},\n\n\taddLayer: function(layer) {\n\t\treturn this.insertLayer(undefined, layer);\n\t},\n\n\tinsertLayer: function(index, layer) {\n\t\tif (layer instanceof Layer) {\n\t\t\tlayer._remove(false, true);\n\t\t\tBase.splice(this._children, [layer], index, 0);\n\t\t\tlayer._setProject(this, true);\n\t\t\tvar name = layer._name;\n\t\t\tif (name)\n\t\t\t\tlayer.setName(name);\n\t\t\tif (this._changes)\n\t\t\t\tlayer._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = layer;\n\t\t} else {\n\t\t\tlayer = null;\n\t\t}\n\t\treturn layer;\n\t},\n\n\t_insertItem: function(index, item, _created) {\n\t\titem = this.insertLayer(index, item)\n\t\t\t\t|| (this._activeLayer || this._insertItem(undefined,\n\t\t\t\t\t\tnew Layer(Item.NO_INSERT), true))\n\t\t\t\t\t\t.insertChild(index, item);\n\t\tif (_created && item.activate)\n\t\t\titem.activate();\n\t\treturn item;\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tremoveOn: function(type) {\n\t\tvar sets = this._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar children = this._children,\n\t\t\tparam = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].draw(ctx, param);\n\t\t}\n\t\tctx.restore();\n\n\t\tif (this._selectionCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectionItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items) {\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = Base.set({},\n\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_name: null,\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_canScaleStroke: false,\n\t_pivot: null,\n\t_visible: true,\n\t_blendMode: 'normal',\n\t_opacity: 1,\n\t_locked: false,\n\t_guide: false,\n\t_clipMask: false,\n\t_selection: 0,\n\t_selectBounds: true,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tlocked: false,\n\t\tguide: false,\n\t\tclipMask: false,\n\t\tselected: false,\n\t\tdata: {}\n\t},\n\t_prioritize: ['applyMatrix']\n},\nnew function() {\n\tvar handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];\n\treturn Base.each(handlers,\n\t\tfunction(name) {\n\t\t\tthis._events[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, 1);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, -1);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\t_events: {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tonLoad: {},\n\t\t\t\tonError: {}\n\t\t\t},\n\t\t\tstatics: {\n\t\t\t\t_itemHandlers: handlers\n\t\t\t}\n\t\t}\n\t);\n}, {\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project,\n\t\t\tsettings = paper.settings;\n\t\tthis._id = internal ? null : UID.get();\n\t\tthis._parent = this._index = null;\n\t\tthis._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (internal || hasProps && props.insert == false\n\t\t\t|| !settings.insertItems && !(hasProps && props.insert === true)) {\n\t\t\tthis._setProject(project);\n\t\t} else {\n\t\t\t(hasProps && props.parent || project)\n\t\t\t\t\t._insertItem(undefined, this, true);\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT) {\n\t\t\tthis.set(props, {\n\t\t\t\tinternal: true, insert: true, project: true, parent: true\n\t\t\t});\n\t\t}\n\t\treturn hasProps;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._symbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\tthis._globalMatrix = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 40)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project)\n\t\t\tproject._changed(flags, this);\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar owner = this._getOwner();\n\t\tif (name && owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tif (!(name in children))\n\t\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(128);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tkey = '_' + name,\n\t\t\tflags = {\n\t\t\t\tlocked: 128,\n\t\t\t\tvisible: 137\n\t\t\t};\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[key];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[key]) {\n\t\t\t\tthis[key] = value;\n\t\t\t\tthis._changed(flags[name] || 129);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tif (selection !== this._selection) {\n\t\t\tthis._selection = selection;\n\t\t\tvar project = this._project;\n\t\t\tif (project) {\n\t\t\t\tproject._updateSelection(this);\n\t\t\t\tthis._changed(129);\n\t\t\t}\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn !!(this._selection & 1);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisFullySelected: function() {\n\t\tvar children = this._children,\n\t\t\tselected = !!(this._selection & 1);\n\t\tif (children && selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(129);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(1024);\n\t\t}\n\t},\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar position = this._position,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\tif (!position) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tposition = this._position = pivot\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t}\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\tgetPivot: function() {\n\t\tvar pivot = this._pivot;\n\t\treturn pivot\n\t\t\t\t? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')\n\t\t\t\t: null;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t}\n}, Base.each({\n\t\tgetStrokeBounds: { stroke: true },\n\t\tgetHandleBounds: { handle: true },\n\t\tgetInternalBounds: { internal: true }\n\t},\n\tfunction(options, key) {\n\t\tthis[key] = function(matrix) {\n\t\t\treturn this.getBounds(matrix, options);\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\tgetBounds: function(matrix, options) {\n\t\tvar hasMatrix = options || matrix instanceof Matrix,\n\t\t\topts = Base.set({}, hasMatrix ? options : matrix,\n\t\t\t\t\tthis._boundsOptions);\n\t\tif (!opts.stroke || this.getStrokeScaling())\n\t\t\topts.cacheItem = this;\n\t\tvar rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n\t\treturn !arguments.length\n\t\t\t\t? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,\n\t\t\t\t\tthis, 'setBounds')\n\t\t\t\t: rect;\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\t_matrix = this._matrix,\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tif (!_matrix.isInvertible()) {\n\t\t\t\t_matrix.set(_matrix._backup\n\t\t\t\t\t\t|| new Matrix().translate(_matrix.getTranslation()));\n\t\t\t\tbounds = this.getBounds();\n\t\t\t}\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width !== 0 ? rect.width / bounds.width : 0,\n\t\t\t\t\tbounds.height !== 0 ? rect.height / bounds.height : 0);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar children = this._children;\n\t\tif (!children || !children.length)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, options.cacheItem);\n\t\treturn Item._getBounds(children, matrix, options);\n\t},\n\n\t_getBoundsCacheKey: function(options, internal) {\n\t\treturn [\n\t\t\toptions.stroke ? 1 : 0,\n\t\t\toptions.handle ? 1 : 0,\n\t\t\tinternal ? 1 : 0\n\t\t].join('');\n\t},\n\n\t_getCachedBounds: function(matrix, options, noInternal) {\n\t\tmatrix = matrix && matrix._orNullIfIdentity();\n\t\tvar internal = options.internal && !noInternal,\n\t\t\tcacheItem = options.cacheItem,\n\t\t\t_matrix = internal ? null : this._matrix._orNullIfIdentity(),\n\t\t\tcacheKey = cacheItem && (!matrix || matrix.equals(_matrix))\n\t\t\t\t&& this._getBoundsCacheKey(options, internal),\n\t\t\tbounds = this._bounds;\n\t\tItem._updateBoundsCache(this._parent || this._symbol, cacheItem);\n\t\tif (cacheKey && bounds && cacheKey in bounds) {\n\t\t\tvar cached = bounds[cacheKey];\n\t\t\treturn {\n\t\t\t\trect: cached.rect.clone(),\n\t\t\t\tnonscaling: cached.nonscaling\n\t\t\t};\n\t\t}\n\t\tvar res = this._getBounds(matrix || _matrix, options),\n\t\t\trect = res.rect || res,\n\t\t\tstyle = this._style,\n\t\t\tnonscaling = res.nonscaling || style.hasStroke()\n\t\t\t\t&& !style.getStrokeScaling();\n\t\tif (cacheKey) {\n\t\t\tif (!bounds) {\n\t\t\t\tthis._bounds = bounds = {};\n\t\t\t}\n\t\t\tvar cached = bounds[cacheKey] = {\n\t\t\t\trect: rect.clone(),\n\t\t\t\tnonscaling: nonscaling,\n\t\t\t\tinternal: internal\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trect: rect,\n\t\t\tnonscaling: nonscaling\n\t\t};\n\t},\n\n\t_getStrokeMatrix: function(matrix, options) {\n\t\tvar parent = this.getStrokeScaling() ? null\n\t\t\t\t: options && options.internal ? this\n\t\t\t\t\t: this._parent || this._symbol && this._symbol._item,\n\t\t\tmx = parent ? parent.getViewMatrix().invert() : matrix;\n\t\treturn mx && mx._shiftless();\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent && item) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getBounds: function(items, matrix, options) {\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2,\n\t\t\t\tnonscaling = false;\n\t\t\toptions = options || {};\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._visible && !item.isEmpty()) {\n\t\t\t\t\tvar bounds = item._getCachedBounds(\n\t\t\t\t\t\tmatrix && matrix.appended(item._matrix), options, true),\n\t\t\t\t\t\trect = bounds.rect;\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t\tif (bounds.nonscaling)\n\t\t\t\t\t\tnonscaling = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\trect: isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle(),\n\t\t\t\tnonscaling: nonscaling\n\t\t\t};\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._applyMatrix\n\t\t\t? null\n\t\t\t: this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed ? decomposed.rotation : 0;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\ts = decomposed && decomposed.scaling;\n\t\treturn new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling && !current.equals(scaling)) {\n\t\t\tvar rotation = this.getRotation(),\n\t\t\t\tdecomposed = this._decomposed,\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tcenter = this.getPosition(true);\n\t\t\tmatrix.translate(center);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(rotation);\n\t\t\tmatrix.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(-rotation);\n\t\t\tmatrix.translate(center.negate());\n\t\t\tthis.transform(matrix);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix,\n\t\t\tupdateVersion = this._project._updateVersion;\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\tmatrix = null;\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.prepend(parent.getGlobalMatrix(true));\n\t\t\tmatrix._updateVersion = updateVersion;\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetViewMatrix: function() {\n\t\treturn this.getGlobalMatrix().prepend(this.getView()._matrix);\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\t_getOwner: '#getParent',\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(options) {\n\t\tvar copy = new this.constructor(Item.NO_INSERT),\n\t\t\tchildren = this._children,\n\t\t\tinsert = Base.pick(options ? options.insert : undefined,\n\t\t\t\t\toptions === undefined || options === true),\n\t\t\tdeep = Base.pick(options ? options.deep : undefined, true);\n\t\tif (children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (!children || deep)\n\t\t\tcopy.copyContent(this);\n\t\tif (!children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (insert)\n\t\t\tcopy.insertAbove(this);\n\t\tvar name = this._name,\n\t\t\tparent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\tif (name !== orig)\n\t\t\t\tcopy.setName(name);\n\t\t}\n\t\treturn copy;\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar children = source._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tthis.addChild(children[i].clone(false), true);\n\t\t}\n\t},\n\n\tcopyAttributes: function(source, excludeMatrix) {\n\t\tthis.setStyle(source._style);\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (source.hasOwnProperty(key))\n\t\t\t\tthis[key] = source[key];\n\t\t}\n\t\tif (!excludeMatrix)\n\t\t\tthis._matrix.set(source._matrix, true);\n\t\tthis.setApplyMatrix(source._applyMatrix);\n\t\tthis.setPivot(source._pivot);\n\t\tthis.setSelection(source._selection);\n\t\tvar data = source._data,\n\t\t\tname = source._name;\n\t\tthis._data = data ? Base.clone(data) : null;\n\t\tif (name)\n\t\t\tthis.setName(name);\n\t},\n\n\trasterize: function(resolution, insert) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\tif (!size.isZero()) {\n\t\t\tvar canvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t\traster.setCanvas(canvas);\n\t\t}\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t.scale(1 / scale));\n\t\tif (insert === undefined || insert)\n\t\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\treturn !!this._contains(\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t},\n\n\t_contains: function(point) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tif (children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix, true).length > 0;\n\t}\n},\nnew function() {\n\tfunction hitTest() {\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(arguments),\n\t\t\t\tHitResult.getOptions(arguments));\n\t}\n\n\tfunction hitTestAll() {\n\t\tvar point = Point.read(arguments),\n\t\t\toptions = HitResult.getOptions(arguments),\n\t\t\tall = [];\n\t\tthis._hitTest(point, Base.set({ all: all }, options));\n\t\treturn all;\n\t}\n\n\tfunction hitTestChildren(point, options, viewMatrix, _exclude) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar res = child !== _exclude && child._hitTest(point, options,\n\t\t\t\t\t\tviewMatrix);\n\t\t\t\tif (res && !options.all)\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tProject.inject({\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTest: hitTestChildren\n\t});\n\n\treturn {\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTestChildren: hitTestChildren,\n\t};\n}, {\n\n\t_hitTest: function(point, options, parentViewMatrix) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar matrix = this._matrix,\n\t\t\tviewMatrix = parentViewMatrix\n\t\t\t\t\t? parentViewMatrix.appended(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().prepend(this.getView()._matrix),\n\t\t\ttolerance = Math.max(options.tolerance, 1e-12),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\tPath._getStrokePadding(tolerance,\n\t\t\t\t\t\tmatrix._shiftless().invert()));\n\t\tpoint = matrix._inverseTransform(point);\n\t\tif (!point || !this._children &&\n\t\t\t!this.getBounds({ internal: true, stroke: true, handle: true })\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this.isSelected()\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tmatch = options.match,\n\t\t\tthat = this,\n\t\t\tbounds,\n\t\t\tres;\n\n\t\tfunction filter(hit) {\n\t\t\tif (hit && match && !match(hit))\n\t\t\t\thit = null;\n\t\t\tif (hit && options.all)\n\t\t\t\toptions.all.push(hit);\n\t\t\treturn hit;\n\t\t}\n\n\t\tfunction checkPoint(type, part) {\n\t\t\tvar pt = part ? bounds['get' + part]() : that.getPosition();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1) {\n\t\t\t\treturn new HitResult(type, that, {\n\t\t\t\t\tname: part ? Base.hyphenate(part) : type,\n\t\t\t\t\tpoint: pt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar checkPosition = options.position,\n\t\t\tcheckCenter = options.center,\n\t\t\tcheckBounds = options.bounds;\n\t\tif (checkSelf && this._parent\n\t\t\t\t&& (checkPosition || checkCenter || checkBounds)) {\n\t\t\tif (checkCenter || checkBounds) {\n\t\t\t\tbounds = this.getInternalBounds();\n\t\t\t}\n\t\t\tres = checkPosition && checkPoint('position') ||\n\t\t\t\t\tcheckCenter && checkPoint('center', 'Center');\n\t\t\tif (!res && checkBounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++) {\n\t\t\t\t\tres = checkPoint('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = filter(res);\n\t\t}\n\n\t\tif (!res) {\n\t\t\tres = this._hitTestChildren(point, options, viewMatrix)\n\t\t\t\t|| checkSelf\n\t\t\t\t\t&& filter(this._hitTestSelf(point, options, viewMatrix,\n\t\t\t\t\t\tthis.getStrokeScaling() ? null\n\t\t\t\t\t\t\t: viewMatrix._shiftless().invert()))\n\t\t\t\t|| null;\n\t\t}\n\t\tif (res && res.point) {\n\t\t\tres.point = matrix.transform(res.point);\n\t\t}\n\t\treturn res;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else if (name === 'match') {\n\t\t\treturn compare(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (name === 'class') {\n\t\t\t\tif (typeof compare === 'function')\n\t\t\t\t\treturn this instanceof compare;\n\t\t\t\tvalue = this._class;\n\t\t\t}\n\t\t\tif (typeof compare === 'function') {\n\t\t\t\treturn !!compare(value);\n\t\t\t} else if (compare) {\n\t\t\t\tif (compare.test) {\n\t\t\t\t\treturn compare.test(value);\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\treturn matchObject(compare, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Base.equals(value, compare);\n\t\t}\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix, null, true)[0]\n\t\t\t\t|| null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(item, options, matrix, param, firstOnly) {\n\t\t\tif (!param) {\n\t\t\t\tvar obj = typeof options === 'object' && options,\n\t\t\t\t\toverlapping = obj && obj.overlapping,\n\t\t\t\t\tinside = obj && obj.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\trecursive: obj && obj.recursive !== false,\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (obj) {\n\t\t\t\t\toptions = Base.filter({}, options, {\n\t\t\t\t\t\trecursive: true, inside: true, overlapping: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = item._children,\n\t\t\t\titems = param.items,\n\t\t\t\trect = param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.appended(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(rect.contains(bounds)\n\t\t\t\t\t\t\t|| param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(options)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (param.recursive !== false) {\n\t\t\t\t\t_getItems(child, options, childMatrix, param, firstOnly);\n\t\t\t\t}\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this ? this.addChild(res) : res;\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tvar res = item ? this.insertChildren(index, [item]) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items) {\n\t\treturn this.insertChildren(this._children.length, items);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Base.slice(items);\n\t\t\tvar inserted = {};\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tid = item && item._id;\n\t\t\t\tif (!item || inserted[id]) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\titem._remove(false, true);\n\t\t\t\t\tinserted[id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tname = item._name;\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(project, true);\n\t\t\t\tif (name)\n\t\t\t\t\titem.setName(name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\titem._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertItem: '#insertChild',\n\n\t_insertAt: function(item, offset) {\n\t\tvar owner = item && item._getOwner(),\n\t\t\tres = item !== this && owner ? this : null;\n\t\tif (res) {\n\t\t\tres._remove(false, true);\n\t\t\towner._insertItem(item._index + offset, res);\n\t\t}\n\t\treturn res;\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn this._insertAt(item, 1);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn this._insertAt(item, 0);\n\t},\n\n\tsendToBack: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(0, this) : null;\n\t},\n\n\tbringToFront: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(undefined, this) : null;\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\taddTo: function(owner) {\n\t\treturn owner._insertItem(undefined, this);\n\t},\n\n\tcopyTo: function(owner) {\n\t\treturn this.clone(false).addTo(owner);\n\t},\n\n\treduce: function(options) {\n\t\tvar children = this._children;\n\t\tif (children && children.length === 1) {\n\t\t\tvar child = children[0].reduce(options);\n\t\t\tif (this._parent) {\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tthis.remove();\n\t\t\t} else {\n\t\t\t\tchild.remove();\n\t\t\t}\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar owner = this._getOwner();\n\t\tif (owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[0];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar owner = this._getOwner(),\n\t\t\tproject = this._project,\n\t\t\tindex = this._index;\n\t\tif (owner) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (index != null) {\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(owner._children, null, index, 1);\n\t\t\t}\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent)\n\t\t\t\towner._changed(11, this);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(start, end) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, start, end - start);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function() {\n\t\tvar children = this._children;\n\t\treturn !children || !children.length;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent === item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t_setApplyMatrix) {\n\t\tvar _matrix = this._matrix,\n\t\t\ttransform = matrix && !matrix.isIdentity(),\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t&& ((!_matrix.isIdentity() || transform)\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\tif (!transform && !applyMatrix)\n\t\t\treturn this;\n\t\tif (transform) {\n\t\t\tif (!matrix.isInvertible() && _matrix.isInvertible())\n\t\t\t\t_matrix._backup = _matrix.getValues();\n\t\t\t_matrix.prepend(matrix, true);\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\t\tif (applyMatrix && (applyMatrix = this._transformContent(_matrix,\n\t\t\t\t_applyRecursively, _setApplyMatrix))) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tif (transform || applyMatrix) {\n\t\t\tthis._changed(9);\n\t\t}\n\t\tvar decomp = transform && bounds && matrix.decompose();\n\t\tif (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar cache = bounds[key];\n\t\t\t\tif (cache.nonscaling) {\n\t\t\t\t\tdelete bounds[key];\n\t\t\t\t} else if (applyMatrix || !cache.internal) {\n\t\t\t\t\tvar rect = cache.rect;\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bounds = bounds;\n\t\t\tvar cached = bounds[this._getBoundsCacheKey(\n\t\t\t\t\tthis._boundsOptions || {})];\n\t\t\tif (cached) {\n\t\t\t\tthis._position = cached.rect.getCenter(true);\n\t\t\t}\n\t\t} else if (transform && position && this._pivot) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\tsetApplyMatrix);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t}\n}), {\n\n\t_setStyles: function(ctx, param, viewMatrix) {\n\t\tvar style = this._style,\n\t\t\tmatrix = this._matrix;\n\t\tif (style.hasFill()) {\n\t\t\tctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n\t\t}\n\t\tif (style.hasStroke()) {\n\t\t\tctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n\t\t\tctx.lineWidth = style.getStrokeWidth();\n\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\tif (strokeJoin)\n\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\tif (strokeCap)\n\t\t\t\tctx.lineCap = strokeCap;\n\t\t\tif (miterLimit)\n\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\tif (paper.support.nativeDash) {\n\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (style.hasShadow()) {\n\t\t\tvar pixelRatio = param.pixelRatio || 1,\n\t\t\t\tmx = viewMatrix._shiftless().prepend(\n\t\t\t\t\tnew Matrix().scale(pixelRatio, pixelRatio)),\n\t\t\t\tblur = mx.transform(new Point(style.getShadowBlur(), 0)),\n\t\t\t\toffset = mx.transform(this.getShadowOffset());\n\t\t\tctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n\t\t\tctx.shadowBlur = blur.getLength();\n\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\tctx.shadowOffsetY = offset.y;\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].appended(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tviewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)\n\t\t\t\t: globalMatrix;\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = this._opacity,\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(viewMatrix);\n\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\treturn;\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.appended(matrix)\n\t\t\t\t: this._canScaleStroke && !this.getStrokeScaling(true)\n\t\t\t\t\t&& viewMatrix,\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform) {\n\t\t\t(direct ? matrix : viewMatrix).applyToContext(ctx);\n\t\t}\n\t\tif (clip) {\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, viewMatrix, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish)\n\t\t\tctx.clip();\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n\t\tvar selection = this._selection,\n\t\t\titemSelected = selection & 1,\n\t\t\tboundsSelected = selection & 2\n\t\t\t\t\t|| itemSelected && this._selectBounds,\n\t\t\tpositionSelected = selection & 4;\n\t\tif (!this._drawSelected)\n\t\t\titemSelected = false;\n\t\tif ((itemSelected || boundsSelected || positionSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar layer,\n\t\t\t\tcolor = this.getSelectedColor(true) || (layer = this.getLayer())\n\t\t\t\t\t&& layer.getSelectedColor(true),\n\t\t\t\tmx = matrix.appended(this.getGlobalMatrix(true)),\n\t\t\t\thalf = size / 2;\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (itemSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectionItems);\n\t\t\tif (positionSelected) {\n\t\t\t\tvar point = this.getPosition(true),\n\t\t\t\t\tx = point.x,\n\t\t\t\t\ty = point.y;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.stroke();\n\t\t\t\tvar deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],\n\t\t\t\t\tstart = half,\n\t\t\t\t\tend = size + 1;\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar delta = deltas[i],\n\t\t\t\t\t\tdx = delta[0],\n\t\t\t\t\t\tdy = delta[1];\n\t\t\t\t\tctx.moveTo(x + dx * start, y + dy * start);\n\t\t\t\t\tctx.lineTo(x + dx * end, y + dy * end);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (boundsSelected) {\n\t\t\t\tvar coords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(key) {\n\tthis['removeOn' + Base.capitalize(key)] = function() {\n\t\tvar hash = {};\n\t\thash[key] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}));\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectBounds: false,\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 1026) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i]._clipMask) {\n\t\t\t\t\tclipItem = children[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_getBounds: function _getBounds(matrix, options) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn clipItem\n\t\t\t? clipItem._getCachedBounds(\n\t\t\t\tmatrix && matrix.appended(clipItem._matrix),\n\t\t\t\tBase.set({}, options, { stroke: false }))\n\t\t\t: _getBounds.base.call(this, matrix, options);\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn (!clipItem || clipItem.contains(point))\n\t\t\t\t&& _hitTestChildren.base.call(this, point, options, viewMatrix,\n\t\t\t\t\tclipItem);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem();\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tctx.beginPath();\n\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar item = children[i];\n\t\t\tif (item !== clipItem)\n\t\t\t\titem.draw(ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer() {\n\t\tGroup.apply(this, arguments);\n\t},\n\n\t_getOwner: function() {\n\t\treturn this._parent || this._index != null && this._project;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_hitTestSelf: function() {\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_canScaleStroke: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props, point) {\n\t\tthis._initialize(props, point);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setType(source._type);\n\t\tthis.setSize(source._size);\n\t\tthis.setRadius(source._radius);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tthis._radius.set(Size.min(this._radius, size.divide(2)));\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius._set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size._set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size._set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size._set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t});\n\t\tpath.copyAttributes(this);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\tif (insert === undefined || insert)\n\t\t\tpath.insertAbove(this);\n\t\treturn path;\n\t},\n\n\ttoShape: '#clone',\n\n\t_asPathItem: function() {\n\t\treturn this.toPath(false);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\tstyle = this._style,\n\t\t\tstrokeWidth = options.stroke && style.hasStroke()\n\t\t\t\t\t&& style.getStrokeWidth();\n\t\tif (matrix)\n\t\t\trect = matrix._transformBounds(rect);\n\t\treturn strokeWidth\n\t\t\t\t? rect.expand(Path._getStrokePadding(strokeWidth,\n\t\t\t\t\tthis._getStrokeMatrix(matrix, options)))\n\t\t\t\t: rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var q = 1; q <= 4; q++) {\n\t\t\t\tvar dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(\n\t\t\t\t\t\t\texpand ? corner.add(dir.multiply(expand)) : corner,\n\t\t\t\t\t\t\tcenter);\n\t\t\t\tif (rect.contains(point))\n\t\t\t\t\treturn { point: center, quadrant: q };\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isOnEllipseStroke(point, radius, padding, quadrant) {\n\t\tvar vector = point.divide(radius);\n\t\treturn (!quadrant || vector.isInQuadrant(quadrant)) &&\n\t\t\t\tvector.subtract(vector.normalize()).multiply(radius)\n\t\t\t\t\t.divide(padding).length <= 1;\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center.point).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,\n\t\t\t\tstrokeMatrix) {\n\t\t\tvar hit = false,\n\t\t\t\tstyle = this._style,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill();\n\t\t\tif (hitStroke || hitFill) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\t\tstrokePadding = options._tolerancePadding.add(\n\t\t\t\t\t\tPath._getStrokePadding(strokeRadius,\n\t\t\t\t\t\t\t!style.getStrokeScaling() && strokeMatrix));\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar padding = strokePadding.multiply(2),\n\t\t\t\t\t\tcenter = getCornerCenter(this, point, padding);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\thit = isOnEllipseStroke(point.subtract(center.point),\n\t\t\t\t\t\t\t\tradius, strokePadding, center.quadrant);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(padding),\n\t\t\t\t\t\t\tinner = rect.expand(padding.negate());\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thit = isOnEllipseStroke(point, radius, strokePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = new Shape(Base.getNamed(args), point);\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\treturn item;\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targuments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, arguments);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: false, handle: false },\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\t_prioritize: ['crossOrigin'],\n\n\tinitialize: function Raster(object, position) {\n\t\tif (!this._initialize(object,\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\tvar image = typeof object === 'string'\n\t\t\t\t\t? document.getElementById(object) : object;\n\t\t\tif (image) {\n\t\t\t\tthis.setImage(image);\n\t\t\t} else {\n\t\t\t\tthis.setSource(object);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar image = source._image,\n\t\t\tcanvas = source._canvas;\n\t\tif (image) {\n\t\t\tthis._setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(source._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tthis._setImage(copyCanvas);\n\t\t}\n\t\tthis._crossOrigin = source._crossOrigin;\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = this.getElement();\n\t\t\t\tthis._setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element)\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tgetLoaded: function() {\n\t\treturn this._loaded;\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tvar that = this;\n\n\t\tfunction emit(event) {\n\t\t\tvar view = that.getView(),\n\t\t\t\ttype = event && event.type || 'load';\n\t\t\tif (view && that.responds(type)) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.emit(type, new Event(event));\n\t\t\t}\n\t\t}\n\n\t\tthis._setImage(image);\n\t\tif (this._loaded) {\n\t\t\tsetTimeout(emit, 0);\n\t\t} else if (image) {\n\t\t\tDomEvent.add(image, {\n\t\t\t\tload: function(event) {\n\t\t\t\t\tthat._setImage(image);\n\t\t\t\t\temit(event);\n\t\t\t\t},\n\t\t\t\terror: emit\n\t\t\t});\n\t\t}\n\t},\n\n\t_setImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = !!(image && image.src && image.complete);\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(521);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(modify) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (modify) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(513);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar image = new self.Image(),\n\t\t\tcrossOrigin = this._crossOrigin;\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\timage.src = src;\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tvar image = this._image;\n\t\tif (image)\n\t\t\timage.crossOrigin = crossOrigin;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster._setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.prepend(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar image = this._image,\n\t\t\tsrc = image && image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (typeof object === 'object') {\n\t\t\tif ('width' in object) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if ('x' in object) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t}\n\t\tif (!bounds)\n\t\t\treturn null;\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcolor = Color.read(arguments),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx) {\n\t\tvar element = this.getElement();\n\t\tif (element) {\n\t\t\tctx.globalAlpha = this._opacity;\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar SymbolItem = Item.extend({\n\t_class: 'SymbolItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: true },\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function SymbolItem(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setDefinition(arg0 instanceof SymbolDefinition ?\n\t\t\t\t\targ0 : new SymbolDefinition(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._definition === item._definition;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setDefinition(source._definition);\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(definition) {\n\t\tthis._definition = definition;\n\t\tthis._changed(9);\n\t},\n\n\tgetSymbol: '#getDefinition',\n\tsetSymbol: '#setDefinition',\n\n\tisEmpty: function() {\n\t\treturn this._definition._item.isEmpty();\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar item = this._definition._item;\n\t\treturn item._getCachedBounds(item._matrix.prepended(matrix), options);\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix) {\n\t\tvar res = this._definition._item._hitTest(point, options, viewMatrix);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis._definition._item.draw(ctx, param);\n\t}\n\n});\n\nvar SymbolDefinition = Base.extend({\n\t_class: 'SymbolDefinition',\n\n\tinitialize: function SymbolDefinition(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tif (item)\n\t\t\tthis.setItem(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._item],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8)\n\t\t\tItem._clearBoundsCache(this);\n\t\tif (flags & 1)\n\t\t\tthis.project._changed(flags);\n\t},\n\n\tgetItem: function() {\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item, _dontCenter) {\n\t\tif (item._symbol)\n\t\t\titem = item.clone();\n\t\tif (this._item)\n\t\t\tthis._item._symbol = null;\n\t\tthis._item = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._symbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tgetDefinition: '#getItem',\n\tsetDefinition: '#setItem',\n\n\tplace: function(position) {\n\t\treturn new SymbolItem(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new SymbolDefinition(this._item.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this._item.equals(symbol._item)\n\t\t\t\t|| false;\n\t}\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values)\n\t\t\tthis.inject(values);\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(args) {\n\t\t\tvar options = args && Base.read(args);\n\t\t\treturn Base.set({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tposition: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\t_selection: 0,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut, selection;\n\t\tif (count > 0) {\n\t\t\tif (arg0 == null || typeof arg0 === 'object') {\n\t\t\t\tif (count === 1 && arg0 && 'point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t\tselection = arg0.selection;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t\thandleIn = arg1;\n\t\t\t\t\thandleOut = arg2;\n\t\t\t\t\tselection = arg3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\tif (selection)\n\t\t\tthis.setSelection(selection);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar point = this._point,\n\t\t\tselection = this._selection,\n\t\t\tobj = selection || this.hasHandles()\n\t\t\t\t\t? [point, this._handleIn, this._handleOut]\n\t\t\t\t\t: point;\n\t\tif (selection)\n\t\t\tobj.push(selection);\n\t\treturn Base.serialize(obj, options, true, dictionary);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(25);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tthis._point.set(Point.read(arguments));\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tthis._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tthis._handleOut.set(Point.read(arguments));\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tisSmooth: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut;\n\t\treturn !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t&& handleIn.isCollinear(handleOut);\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn._set(0, 0);\n\t\tthis._handleOut._set(0, 0);\n\t},\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tvar oldSelection = this._selection,\n\t\t\tpath = this._path;\n\t\tthis._selection = selection = selection || 0;\n\t\tif (path && selection !== oldSelection) {\n\t\t\tpath._updateSelection(this, oldSelection, selection);\n\t\t\tpath._changed(129);\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._selection & 7);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._changeSelection(7, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tsmooth: function(options, _first, _last) {\n\t\tvar opts = options || {},\n\t\t\ttype = opts.type,\n\t\t\tfactor = opts.factor,\n\t\t\tprev = this.getPrevious(),\n\t\t\tnext = this.getNext(),\n\t\t\tp0 = (prev || this)._point,\n\t\t\tp1 = this._point,\n\t\t\tp2 = (next || this)._point,\n\t\t\td1 = p0.getDistance(p1),\n\t\t\td2 = p1.getDistance(p2);\n\t\tif (!type || type === 'catmull-rom') {\n\t\t\tvar a = factor === undefined ? 0.5 : factor,\n\t\t\t\td1_a = Math.pow(d1, a),\n\t\t\t\td1_2a = d1_a * d1_a,\n\t\t\t\td2_a = Math.pow(d2, a),\n\t\t\t\td2_2a = d2_a * d2_a;\n\t\t\tif (!_first && prev) {\n\t\t\t\tvar A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,\n\t\t\t\t\tN = 3 * d2_a * (d2_a + d1_a);\n\t\t\t\tthis.setHandleIn(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,\n\t\t\t\t\t\t(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t\tif (!_last && next) {\n\t\t\t\tvar A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,\n\t\t\t\t\tN = 3 * d1_a * (d1_a + d2_a);\n\t\t\t\tthis.setHandleOut(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,\n\t\t\t\t\t\t(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t} else if (type === 'geometric') {\n\t\t\tif (prev && next) {\n\t\t\t\tvar vector = p0.subtract(p2),\n\t\t\t\t\tt = factor === undefined ? 0.4 : factor,\n\t\t\t\t\tk = t * d1 / (d1 + d2);\n\t\t\t\tif (!_first)\n\t\t\t\t\tthis.setHandleIn(vector.multiply(k));\n\t\t\t\tif (!_last)\n\t\t\t\t\tthis.setHandleOut(vector.multiply(k - t));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Smoothing method \\'' + type + '\\' not supported.');\n\t\t}\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\ttmp = handleIn.clone();\n\t\thandleIn.set(handleOut);\n\t\thandleOut.set(tmp);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar u = 1 - factor,\n\t\t\tv = factor,\n\t\t\tpoint1 = from._point,\n\t\t\tpoint2 = to._point,\n\t\t\thandleIn1 = from._handleIn,\n\t\t\thandleIn2 = to._handleIn,\n\t\t\thandleOut2 = to._handleOut,\n\t\t\thandleOut1 = from._handleOut;\n\t\tthis._point._set(\n\t\t\t\tu * point1._x + v * point2._x,\n\t\t\t\tu * point1._y + v * point2._y, true);\n\t\tthis._handleIn._set(\n\t\t\t\tu * handleIn1._x + v * handleIn2._x,\n\t\t\t\tu * handleIn1._y + v * handleIn2._y, true);\n\t\tthis._handleOut._set(\n\t\t\t\tu * handleOut1._x + v * handleOut2._x,\n\t\t\t\tu * handleOut1._y + v * handleOut2._y, true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y,\n\t\t\tselected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\t_set: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this._x) && isZero(this._y);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\tvar owner = this._owner;\n\t\treturn this === owner._point ? 1\n\t\t\t: this === owner._handleIn ? 2\n\t\t\t: this === owner._handleOut ? 4\n\t\t\t: 0;\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\tbeans: true,\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (!count) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tclassify: function() {\n\t\treturn Curve.classify(this.getValues());\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tthis._segment1._point.set(Point.read(arguments));\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tthis._segment2._point.set(Point.read(arguments));\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tthis._segment1._handleOut.set(Point.read(arguments));\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tthis._segment2._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._segment1._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t}\n}, {\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tdivideAt: function(location) {\n\t\treturn this.divideAtTime(location && location.curve === this\n\t\t\t\t? location.time : this.getTimeAt(location));\n\t},\n\n\tdivideAtTime: function(time, _setHandles) {\n\t\tvar tMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (time >= tMin && time <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), time),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tseg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tseg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n\t\t\t\tseg2._handleIn._set(right[4] - right[6],right[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(seg1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tthis._changed();\n\t\t\t\tres = new Curve(segment, seg2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar path = this._path;\n\t\treturn path ? path.splitAt(location) : null;\n\t},\n\n\tsplitAtTime: function(time) {\n\t\treturn this.splitAt(this.getLocationAtTime(time));\n\t},\n\n\tdivide: function(offset, isTime) {\n\t\treturn this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\tsplit: function(offset, isTime) {\n\t\treturn this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut._set(0, 0);\n\t\tthis._segment2._handleIn._set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix, straight) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tx1 = p1.x, y1 = p1.y,\n\t\t\tx2 = p2.x, y2 = p2.y,\n\t\t\tvalues = straight\n\t\t\t\t? [ x1, y1, x1, y1, x2, y2, x2, y2 ]\n\t\t\t\t: [\n\t\t\t\t\tx1, y1,\n\t\t\t\t\tx1 + h1._x, y1 + h1._y,\n\t\t\t\t\tx2 + h2._x, y2 + h2._y,\n\t\t\t\t\tx2, y2\n\t\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tx4 = u * x0 + t * x1, y4 = u * y0 + t * y1,\n\t\t\tx5 = u * x1 + t * x2, y5 = u * y1 + t * y2,\n\t\t\tx6 = u * x2 + t * x3, y6 = u * y2 + t * y3,\n\t\t\tx7 = u * x4 + t * x5, y7 = u * y4 + t * y5,\n\t\t\tx8 = u * x5 + t * x6, y8 = u * y5 + t * y6,\n\t\t\tx9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n\t\treturn [\n\t\t\t[x0, y0, x4, y4, x7, y7, x9, y9],\n\t\t\t[x9, y9, x8, y8, x6, y6, x3, y3]\n\t\t];\n\t},\n\n\tgetMonoCurves: function(v, dir) {\n\t\tvar curves = [],\n\t\t\tio = dir ? 0 : 1,\n\t\t\to0 = v[io + 0],\n\t\t\to1 = v[io + 2],\n\t\t\to2 = v[io + 4],\n\t\t\to3 = v[io + 6];\n\t\tif ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)\n\t\t\t\t|| Curve.isStraight(v)) {\n\t\t\tcurves.push(v);\n\t\t} else {\n\t\t\tvar a = 3 * (o1 - o2) - o0 + o3,\n\t\t\t\tb = 2 * (o0 + o2) - 4 * o1,\n\t\t\t\tc = o1 - o0,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [],\n\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\tif (!n) {\n\t\t\t\tcurves.push(v);\n\t\t\t} else {\n\t\t\t\troots.sort();\n\t\t\t\tvar t = roots[0],\n\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\tcurves.push(parts[0]);\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\tcurves.push(parts[0]);\n\t\t\t\t}\n\t\t\t\tcurves.push(parts[1]);\n\t\t\t}\n\t\t}\n\t\treturn curves;\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar v0 = v[coord],\n\t\t\tv1 = v[coord + 2],\n\t\t\tv2 = v[coord + 4],\n\t\t\tv3 = v[coord + 6],\n\t\t\tres = 0;\n\t\tif (  !(v0 < val && v3 < val && v1 < val && v2 < val ||\n\t\t\t\tv0 > val && v3 > val && v1 > val && v2 > val)) {\n\t\t\tvar c = 3 * (v1 - v0),\n\t\t\t\tb = 3 * (v2 - v1) - c,\n\t\t\t\ta = v3 - v0 - c - b;\n\t\t\tres = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n\t\t}\n\t\treturn res;\n\t},\n\n\tgetTimeOf: function(v, point) {\n\t\tvar p0 = new Point(v[0], v[1]),\n\t\t\tp3 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tt = point.isClose(p0, epsilon) ? 0\n\t\t\t  : point.isClose(p3, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t === null) {\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [];\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar u = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, u), geomEpsilon))\n\t\t\t\t\t\treturn u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p0, geomEpsilon) ? 0\n\t\t\t : point.isClose(p3, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestTime: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tvx = x3 - x0, vy = y3 - y0,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getTimeOf(v,\n\t\t\t\t\tnew Point(x0 + u * vx, y0 + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 1e-8) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\tisFlatEnough: function(v, flatness) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tux = 3 * x1 - 2 * x0 - x3,\n\t\t\tuy = 3 * y1 - 2 * y0 - y3,\n\t\t\tvx = 3 * x2 - 2 * x3 - x0,\n\t\t\tvy = 3 * y2 - 2 * y3 - y0;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t<= 16 * flatness * flatness;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)\n\t\t\t\t+ y1 * (x0 - x2) - x1 * (y0 - y2)\n\t\t\t\t+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\n\t\tpadding /= 2;\n\t\tvar minPad = min[coord] - padding,\n\t\t\tmaxPad = max[coord] + padding;\n\t\tif (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||\n\t\t\t\tv0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n\t\t\tif (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n\t\t\t\tadd(v0, padding);\n\t\t\t\tadd(v3, padding);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0,\n\t\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\t\ttMin = 1e-8,\n\t\t\t\t\ttMax = 1 - tMin;\n\t\t\t\tadd(v3, 0);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar t = roots[i],\n\t\t\t\t\t\tu = 1 - t;\n\t\t\t\t\tif (tMin <= t && t <= tMax)\n\t\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\t\tpadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false, this._path);\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(p1, h1, h2, p2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar v = p2.subtract(p1);\n\t\t\tif (v.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n\t\t\t\tvar l = new Line(p1, p2),\n\t\t\t\t\tepsilon = 1e-7;\n\t\t\t\tif (l.getDistance(p1.add(h1)) < epsilon &&\n\t\t\t\t\tl.getDistance(p2.add(h2)) < epsilon) {\n\t\t\t\t\tvar div = v.dot(v),\n\t\t\t\t\t\ts1 = v.dot(h1) / div,\n\t\t\t\t\t\ts2 = v.dot(h2) / div;\n\t\t\t\t\treturn s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(p1, h1, h2, p2) {\n\t\tvar third = p2.subtract(p1).divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function(epsilon) {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,\n\t\t\t\tepsilon);\n\t};\n\n\tthis.statics[name] = function(v, epsilon) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn test(\n\t\t\t\tnew Point(x0, y0),\n\t\t\t\tnew Point(v[2] - x0, v[3] - y0),\n\t\t\t\tnew Point(v[4] - x3, v[5] - y3),\n\t\t\t\tnew Point(x3, y3), epsilon);\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\thasLength: function(epsilon) {\n\t\treturn (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())\n\t\t\t\t&& this.getLength() > (epsilon || 0);\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)\n\t\t\t\t< 1e-8;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)\n\t\t\t\t< 1e-8;\n\t}\n}), {\n\tbeans: false,\n\n\tgetLocationAt: function(offset, _isTime) {\n\t\treturn this.getLocationAtTime(\n\t\t\t\t_isTime ? offset : this.getTimeAt(offset));\n\t},\n\n\tgetLocationAtTime: function(t) {\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetTimeAt: function(offset, start) {\n\t\treturn Curve.getTimeAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterAt: '#getTimeAt',\n\n\tgetOffsetAtTime: function(t) {\n\t\treturn this.getPartLength(0, t);\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetTimeOf: function() {\n\t\treturn Curve.getTimeOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetParameterOf: '#getTimeOf',\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestTime(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(location, _isTime) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, _isTime ? location\n\t\t\t\t\t\t: Curve.getTimeAt(values, location));\n\t\t\t};\n\n\t\t\tthis[name + 'AtTime'] = function(time) {\n\t\t\t\treturn Curve[name](this.getValues(), time);\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\t_evaluateMethods: methods\n\t\t\t}\n\t\t}\n\t);\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\n\t\t\tax = 9 * (x1 - x2) + 3 * (x3 - x0),\n\t\t\tbx = 6 * (x0 + x2) - 12 * x1,\n\t\t\tcx = 3 * (x1 - x0),\n\n\t\t\tay = 9 * (y1 - y2) + 3 * (y3 - y0),\n\t\t\tby = 6 * (y0 + y2) - 12 * y1,\n\t\t\tcy = 3 * (y1 - y0);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tisZero = Numerical.isZero;\n\t\tif (isZero(x1 - x0) && isZero(y1 - y0)) {\n\t\t\tx1 = x0;\n\t\t\ty1 = y0;\n\t\t}\n\t\tif (isZero(x2 - x3) && isZero(y2 - y3)) {\n\t\t\tx2 = x3;\n\t\t\ty2 = y3;\n\t\t}\n\t\tvar cx = 3 * (x1 - x0),\n\t\t\tbx = 3 * (x2 - x1) - cx,\n\t\t\tax = x3 - x0 - cx - bx,\n\t\t\tcy = 3 * (y1 - y0),\n\t\t\tby = 3 * (y2 - y1) - cy,\n\t\t\tay = y3 - y0 - cy - by,\n\t\t\tx, y;\n\t\tif (type === 0) {\n\t\t\tx = t === 0 ? x0 : t === 1 ? x3\n\t\t\t\t\t: ((ax * t + bx) * t + cx) * t + x0;\n\t\t\ty = t === 0 ? y0 : t === 1 ? y3\n\t\t\t\t\t: ((ay * t + by) * t + cy) * t + y0;\n\t\t} else {\n\t\t\tvar tMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t < tMin) {\n\t\t\t\tx = cx;\n\t\t\t\ty = cy;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tx = 3 * (x3 - x2);\n\t\t\t\ty = 3 * (y3 - y2);\n\t\t\t} else {\n\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t}\n\t\t\tif (normalized) {\n\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\tx = x2 - x1;\n\t\t\t\t\ty = y2 - y1;\n\t\t\t\t}\n\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\tif (len) {\n\t\t\t\t\tx /= len;\n\t\t\t\t\ty /= len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type === 3) {\n\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tclassify: function(v) {\n\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\ta1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,\n\t\t\t\ta2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,\n\t\t\t\ta3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,\n\t\t\t\td3 = 3 * a3,\n\t\t\t\td2 = d3 - a2,\n\t\t\t\td1 = d2 - a2 + a1,\n\t\t\t\tl = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),\n\t\t\t\ts = l !== 0 ? 1 / l : 0,\n\t\t\t\tisZero = Numerical.isZero,\n\t\t\t\tserpentine = 'serpentine';\n\t\t\td1 *= s;\n\t\t\td2 *= s;\n\t\t\td3 *= s;\n\n\t\t\tfunction type(type, t1, t2) {\n\t\t\t\tvar hasRoots = t1 !== undefined,\n\t\t\t\t\tt1Ok = hasRoots && t1 > 0 && t1 < 1,\n\t\t\t\t\tt2Ok = hasRoots && t2 > 0 && t2 < 1;\n\t\t\t\tif (hasRoots && (!(t1Ok || t2Ok)\n\t\t\t\t\t\t|| type === 'loop' && !(t1Ok && t2Ok))) {\n\t\t\t\t\ttype = 'arch';\n\t\t\t\t\tt1Ok = t2Ok = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: type,\n\t\t\t\t\troots: t1Ok || t2Ok\n\t\t\t\t\t\t\t? t1Ok && t2Ok\n\t\t\t\t\t\t\t\t? t1 < t2 ? [t1, t2] : [t2, t1]\n\t\t\t\t\t\t\t\t: [t1Ok ? t1 : t2]\n\t\t\t\t\t\t\t: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isZero(d1)) {\n\t\t\t\treturn isZero(d2)\n\t\t\t\t\t\t? type(isZero(d3) ? 'line' : 'quadratic')\n\t\t\t\t\t\t: type(serpentine, d3 / (3 * d2));\n\t\t\t}\n\t\t\tvar d = 3 * d2 * d2 - 4 * d1 * d3;\n\t\t\tif (isZero(d)) {\n\t\t\t\treturn type('cusp', d2 / (2 * d1));\n\t\t\t}\n\t\t\tvar f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),\n\t\t\t\tf2 = 2 * d1;\n\t\t\treturn type(d > 0 ? serpentine : 'loop',\n\t\t\t\t\t(d2 + f1) / f2,\n\t\t\t\t\t(d2 - f1) / f2);\n\t\t},\n\n\t\tgetLength: function(v, a, b, ds) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar c = v;\n\t\t\t\tif (b < 1) {\n\t\t\t\t\tc = Curve.subdivide(c, b)[0];\n\t\t\t\t\ta /= b;\n\t\t\t\t}\n\t\t\t\tif (a > 0) {\n\t\t\t\t\tc = Curve.subdivide(c, a)[1];\n\t\t\t\t}\n\t\t\t\tvar dx = c[6] - c[0],\n\t\t\t\t\tdy = c[7] - c[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\treturn Numerical.integrate(ds || getLengthIntegrand(v), a, b,\n\t\t\t\t\tgetIterations(a, b));\n\t\t},\n\n\t\tgetTimeAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0;\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Curve.getLength(v, a, b, ds),\n\t\t\t\tdiff = abs(offset) - rangeLength;\n\t\t\tif (abs(diff) < epsilon) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (diff > epsilon) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t},\n\n\t\tgetPeaks: function(v) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tax =     -x0 + 3 * x1 - 3 * x2 + x3,\n\t\t\t\tbx =  3 * x0 - 6 * x1 + 3 * x2,\n\t\t\t\tcx = -3 * x0 + 3 * x1,\n\t\t\t\tay =     -y0 + 3 * y1 - 3 * y2 + y3,\n\t\t\t\tby =  3 * y0 - 6 * y1 + 3 * y2,\n\t\t\t\tcy = -3 * y0 + 3 * y1,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [];\n\t\t\tNumerical.solveCubic(\n\t\t\t\t\t9 * (ax * ax + ay * ay),\n\t\t\t\t\t9 * (ax * bx + by * ay),\n\t\t\t\t\t2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),\n\t\t\t\t\t(cx * bx + by * cy),\n\t\t\t\t\troots, tMin, tMax);\n\t\t\treturn roots.sort();\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, include, c1, t1, c2, t2, overlap) {\n\t\tvar excludeStart = !overlap && c1.getPrevious() === c2,\n\t\t\texcludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&\n\t\t\tt1 <= (excludeEnd ? tMax : 1)) {\n\t\t\tif (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&\n\t\t\t\tt2 <= (excludeStart ? tMax : 1)) {\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1, null, overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2, null, overlap);\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc1)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc1, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, include, flip,\n\t\t\trecursion, calls, tMin, tMax, uMin, uMax) {\n\t\tif (++calls >= 4096 || ++recursion >= 40)\n\t\t\treturn calls;\n\t\tvar fatLineEpsilon = 1e-9,\n\t\t\tq0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif (d1 === 0 && d2 === 0\n\t\t\t\t&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0\n\t\t\t|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null\n\t\t\t|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn calls;\n\t\tvar tMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n\t\t\tvar t = (tMinNew + tMaxNew) / 2,\n\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tflip ? c2 : c1, flip ? u : t,\n\t\t\t\t\tflip ? c1 : c2, flip ? t : u);\n\t\t} else {\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tif (tMaxClip - tMinClip > 0.8) {\n\t\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = (tMinNew + tMaxNew) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[0], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, t);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[1], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, t, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[0], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, u, tMinNew, tMaxNew);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[1], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, u, uMax, tMinNew, tMaxNew);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (uMax - uMin >= fatLineEpsilon) {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, include, flip,\n\t\t\t\t\t\t\trecursion, calls, tMinNew, tMaxNew, uMin, uMax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn calls;\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= 0.5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getCurveLineIntersections(v, px, py, vx, vy) {\n\t\tvar isZero = Numerical.isZero;\n\t\tif (isZero(vx) && isZero(vy)) {\n\t\t\tvar t = Curve.getTimeOf(v, new Point(px, py));\n\t\t\treturn t === null ? [] : [t];\n\t\t}\n\t\tvar angle = Math.atan2(-vy, vx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trv = [],\n\t\t\troots = [];\n\t\tfor (var i = 0; i < 8; i += 2) {\n\t\t\tvar x = v[i] - px,\n\t\t\t\ty = v[i + 1] - py;\n\t\t\trv.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tCurve.solveCubic(rv, 1, 0, roots, 0, 1);\n\t\treturn roots;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, include,\n\t\t\tflip) {\n\t\tvar x1 = v2[0], y1 = v2[1],\n\t\t\tx2 = v2[6], y2 = v2[7],\n\t\t\troots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n\t\tfor (var i = 0, l = roots.length; i < l; i++) {\n\t\t\tvar t1 = roots[i],\n\t\t\t\tp1 = Curve.getPoint(v1, t1),\n\t\t\t\tt2 = Curve.getTimeOf(v2, p1);\n\t\t\tif (t2 !== null) {\n\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\tflip ? c2 : c1, flip ? t2 : t1,\n\t\t\t\t\t\tflip ? c1 : c2, flip ? t1 : t2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, include) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, Curve.getTimeOf(v1, pt),\n\t\t\t\t\tc2, Curve.getTimeOf(v2, pt));\n\t\t}\n\t}\n\n\tfunction getCurveIntersections(v1, v2, c1, c2, locations, include) {\n\t\tvar epsilon = 1e-12,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max;\n\n\t\tif (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >\n\t\t\tmin(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmin(v1[0], v1[2], v1[4], v1[6]) - epsilon <\n\t\t\tmax(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmax(v1[1], v1[3], v1[5], v1[7]) + epsilon >\n\t\t\tmin(v2[1], v2[3], v2[5], v2[7]) &&\n\t\t\tmin(v1[1], v1[3], v1[5], v1[7]) - epsilon <\n\t\t\tmax(v2[1], v2[3], v2[5], v2[7])) {\n\t\t\tvar overlaps = getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\tc1, overlap[0],\n\t\t\t\t\t\t\tc2, overlap[1], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tflip = straight1 && !straight2,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tflip ? v2 : v1, flip ? v1 : v2,\n\t\t\t\t\t\t\tflip ? c2 : c1, flip ? c1 : c2,\n\t\t\t\t\t\t\tlocations, include, flip,\n\t\t\t\t\t\t\t0, 0, 0, 1, 0, 1);\n\t\t\t\tif (!straight || locations.length === before) {\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tvar t1 = i >> 1,\n\t\t\t\t\t\t\tt2 = i & 1,\n\t\t\t\t\t\t\ti1 = t1 * 6,\n\t\t\t\t\t\t\ti2 = t2 * 6,\n\t\t\t\t\t\t\tp1 = new Point(v1[i1], v1[i1 + 1]),\n\t\t\t\t\t\t\tp2 = new Point(v2[i2], v2[i2 + 1]);\n\t\t\t\t\t\tif (p1.isClose(p2, epsilon)) {\n\t\t\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\t\t\tc1, t1,\n\t\t\t\t\t\t\t\t\tc2, t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getLoopIntersection(v1, c1, locations, include) {\n\t\tvar info = Curve.classify(v1);\n\t\tif (info.type === 'loop') {\n\t\t\tvar roots = info.roots;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, roots[0],\n\t\t\t\t\tc1, roots[1]);\n\t\t}\n\t  return locations;\n\t}\n\n\tfunction getIntersections(curves1, curves2, include, matrix1, matrix2,\n\t\t\t_returnFirst) {\n\t\tvar self = !curves2;\n\t\tif (self)\n\t\t\tcurves2 = curves1;\n\t\tvar length1 = curves1.length,\n\t\t\tlength2 = curves2.length,\n\t\t\tvalues2 = [],\n\t\t\tarrays = [],\n\t\t\tlocations,\n\t\t\tcurrent;\n\t\tfor (var i = 0; i < length2; i++)\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvar curve1 = curves1[i],\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\tpath1 = curve1.getPath();\n\t\t\tif (path1 !== current) {\n\t\t\t\tcurrent = path1;\n\t\t\t\tlocations = [];\n\t\t\t\tarrays.push(locations);\n\t\t\t}\n\t\t\tif (self) {\n\t\t\t\tgetLoopIntersection(values1, curve1, locations, include);\n\t\t\t}\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\treturn locations;\n\t\t\t\tgetCurveIntersections(values1, values2[j], curve1, curves2[j],\n\t\t\t\t\t\tlocations, include);\n\t\t\t}\n\t\t}\n\t\tlocations = [];\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getOverlaps(v1, v2) {\n\n\t\tfunction getSquaredLineLength(v) {\n\t\t\tvar x = v[6] - v[0],\n\t\t\t\ty = v[7] - v[1];\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tvar abs = Math.abs,\n\t\t\tgetDistance = Line.getDistance,\n\t\t\ttimeEpsilon = 1e-8,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\tstraightBoth = straight1 && straight2,\n\t\t\tflip = getSquaredLineLength(v1) < getSquaredLineLength(v2),\n\t\t\tl1 = flip ? v2 : v1,\n\t\t\tl2 = flip ? v1 : v2,\n\t\t\tpx = l1[0], py = l1[1],\n\t\t\tvx = l1[6] - px, vy = l1[7] - py;\n\t\tif (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&\n\t\t\tgetDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n\t\t\tif (!straightBoth &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {\n\t\t\t\tstraight1 = straight2 = straightBoth = true;\n\t\t\t}\n\t\t} else if (straightBoth) {\n\t\t\treturn null;\n\t\t}\n\t\tif (straight1 ^ straight2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar v = [v1, v2],\n\t\t\tpairs = [];\n\t\tfor (var i = 0; i < 4 && pairs.length < 2; i++) {\n\t\t\tvar i1 = i & 1,\n\t\t\t\ti2 = i1 ^ 1,\n\t\t\t\tt1 = i >> 1,\n\t\t\t\tt2 = Curve.getTimeOf(v[i1], new Point(\n\t\t\t\t\tv[i2][t1 ? 6 : 0],\n\t\t\t\t\tv[i2][t1 ? 7 : 1]));\n\t\t\tif (t2 != null) {\n\t\t\t\tvar pair = i1 ? [t1, t2] : [t2, t1];\n\t\t\t\tif (!pairs.length ||\n\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon) {\n\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && !pairs.length)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pairs.length !== 2) {\n\t\t\tpairs = null;\n\t\t} else if (!straightBoth) {\n\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\tpairs = null;\n\t\t}\n\t\treturn pairs;\n\t}\n\n\treturn {\n\t\tgetIntersections: function(curve) {\n\t\t\tvar v1 = this.getValues(),\n\t\t\t\tv2 = curve && curve !== this && curve.getValues();\n\t\t\treturn v2 ? getCurveIntersections(v1, v2, this, curve, [])\n\t\t\t\t\t  : getLoopIntersection(v1, this, []);\n\t\t},\n\n\t\tstatics: {\n\t\t\tgetOverlaps: getOverlaps,\n\t\t\tgetIntersections: getIntersections,\n\t\t\tgetCurveLineIntersections: getCurveLineIntersections\n\t\t}\n\t};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\n\tinitialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n\t\tif (time >= 0.99999999) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\ttime = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._setCurve(curve);\n\t\tthis._time = time;\n\t\tthis._point = point || curve.getPointAtTime(time);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._previous = null;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tvar path = curve._path;\n\t\tthis._path = path;\n\t\tthis._version = path ? path._version : 0;\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tthis._setCurve(segment.getCurve());\n\t\tthis._segment = segment;\n\t\tthis._time = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar segment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tif (time === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (time != null) {\n\t\t\t\tsegment = curve.getPartLength(0, time)\n\t\t\t\t\t< curve.getPartLength(time, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tthis._time = this._offset = this._curveOffset = this._curve = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn this._curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetTime: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this._time;\n\t\treturn curve && time == null\n\t\t\t? this._time = curve.getTimeOf(this._point)\n\t\t\t: time;\n\t},\n\n\tgetParameter: '#getTime',\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar offset = this._curveOffset;\n\t\tif (offset == null) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tthis._curveOffset = offset = time != null && curve\n\t\t\t\t\t&& curve.getPartLength(0, time);\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = curve && curve.divideAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tpath = curve._path,\n\t\t\tres = curve && curve.splitAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(path.getLastSegment());\n\t\t}\n\t\treturn  res;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc;\n\t\tif (!res && loc instanceof CurveLocation) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tp1 = c1._path,\n\t\t\t\tp2 = c2._path;\n\t\t\tif (p1 === p2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tepsilon = 1e-7,\n\t\t\t\t\tdiff = abs(this.getOffset() - loc.getOffset()),\n\t\t\t\t\ti1 = !_ignoreOther && this._intersection,\n\t\t\t\t\ti2 = !_ignoreOther && loc._intersection;\n\t\t\t\tres = (diff < epsilon\n\t\t\t\t\t\t|| p1 && abs(p1.getLength() - diff) < epsilon)\n\t\t\t\t\t&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar time = this.getTime();\n\t\tif (time != null)\n\t\t\tparts.push('time: ' + f.number(time));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getTime(),\n\t\t\tt2 = inter.getTime(),\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tt1Inside = t1 >= tMin && t1 <= tMax,\n\t\t\tt2Inside = t2 >= tMin && t2 <= tMax;\n\t\tif (t1Inside && t2Inside)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = t1 < tMin ? c2.getPrevious() : c2,\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = t2 < tMin ? c4.getPrevious() : c4;\n\t\tif (t1 > tMax)\n\t\t\tc2 = c2.getNext();\n\t\tif (t2 > tMax)\n\t\t\tc4 = c4.getNext();\n\t\tif (!c1 || !c2 || !c3 || !c4)\n\t\t\treturn false;\n\n\t\tvar offsets = [];\n\n\t\tfunction addOffsets(curve, end) {\n\t\t\tvar v = curve.getValues(),\n\t\t\t\troots = Curve.classify(v).roots || Curve.getPeaks(v),\n\t\t\t\tcount = roots.length,\n\t\t\t\tt = end && count > 1 ? roots[count - 1]\n\t\t\t\t\t\t: count > 0 ? roots[0]\n\t\t\t\t\t\t: 0.5;\n\t\t\toffsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);\n\t\t}\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min || angle < max;\n\t\t}\n\n\t\tif (!t1Inside) {\n\t\t\taddOffsets(c1, true);\n\t\t\taddOffsets(c2, false);\n\t\t}\n\t\tif (!t2Inside) {\n\t\t\taddOffsets(c3, true);\n\t\t\taddOffsets(c4, false);\n\t\t}\n\t\tvar pt = this.getPoint(),\n\t\t\toffset = Math.min.apply(Math, offsets),\n\t\t\tv2 = t1Inside ? c2.getTangentAtTime(t1)\n\t\t\t\t\t: c2.getPointAt(offset).subtract(pt),\n\t\t\tv1 = t1Inside ? v2.negate()\n\t\t\t\t\t: c1.getPointAt(-offset).subtract(pt),\n\t\t\tv4 = t2Inside ? c4.getTangentAtTime(t2)\n\t\t\t\t\t: c4.getPointAt(offset).subtract(pt),\n\t\t\tv3 = t2Inside ? v4.negate()\n\t\t\t\t\t: c3.getPointAt(-offset).subtract(pt),\n\t\t\ta1 = v1.getAngle(),\n\t\t\ta2 = v2.getAngle(),\n\t\t\ta3 = v3.getAngle(),\n\t\t\ta4 = v4.getAngle();\n\t\treturn !!(t1Inside\n\t\t\t\t? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&\n\t\t\t\t  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))\n\t\t\t\t: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&\n\t\t\t\t  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));\n\t},\n\n\thasOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve._evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this.getTime();\n\t\treturn time != null && curve && curve[get](time, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t1e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 !== path2\n\t\t\t\t? path1._id - path2._id\n\t\t\t\t: (loc.getIndex() + loc.getTime())\n\t\t\t\t- (loc2.getIndex() + loc2.getTime());\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\t_selectBounds: false,\n\t_canScaleStroke: true,\n\tbeans: true,\n\n\tinitialize: function PathItem() {\n\t},\n\n\tstatics: {\n\t\tcreate: function(arg) {\n\t\t\tvar data,\n\t\t\t\tsegments,\n\t\t\t\tcompound;\n\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\tsegments = arg.segments;\n\t\t\t\tdata = arg.pathData;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tsegments = arg;\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tdata = arg;\n\t\t\t}\n\t\t\tif (segments) {\n\t\t\t\tvar first = segments[0];\n\t\t\t\tcompound = first && Array.isArray(first[0]);\n\t\t\t} else if (data) {\n\t\t\t\tcompound = (data.match(/m/gi) || []).length > 1\n\t\t\t\t\t\t|| /z\\s*\\S+/i.test(data);\n\t\t\t}\n\t\t\tvar ctor = compound ? CompoundPath : Path;\n\t\t\treturn new ctor(arg);\n\t\t}\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tisClockwise: function() {\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis[move ? 'moveTo' : 'lineTo'](current = getPoint(j));\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\t\tmove = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tcurrent = current.clone();\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(1e-12);\n\t\t\t\tcurrent = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = point.isInside(\n\t\t\t\tthis.getBounds({ internal: true, handle: true }))\n\t\t\t\t\t? this._getWinding(point)\n\t\t\t\t\t: {};\n\t\treturn winding.onPath || !!(this.getFillRule() === 'evenodd'\n\t\t\t\t? winding.windingL & 1 || winding.windingR & 1\n\t\t\t\t: winding.winding);\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix._orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix)._orNullIfIdentity();\n\t\treturn self || this.getBounds(matrix1).intersects(\n\t\t\t\tpath.getBounds(matrix2), 1e-12)\n\t\t\t\t? Curve.getIntersections(\n\t\t\t\t\t\tthis.getCurves(), !self && path.getCurves(), include,\n\t\t\t\t\t\tmatrix1, matrix2, _returnFirst)\n\t\t\t\t: [];\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.hasOverlap() || inter.isCrossing();\n\t\t});\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar isPath = !this._children,\n\t\t\tname = isPath ? '_segments' : '_children',\n\t\t\titemsFrom = from[name],\n\t\t\titemsTo = to[name],\n\t\t\titems = this[name];\n\t\tif (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {\n\t\t\tthrow new Error('Invalid operands in interpolate() call: ' +\n\t\t\t\t\tfrom + ', ' + to);\n\t\t}\n\t\tvar current = items.length,\n\t\t\tlength = itemsTo.length;\n\t\tif (current < length) {\n\t\t\tvar ctor = isPath ? Segment : Path;\n\t\t\tfor (var i = current; i < length; i++) {\n\t\t\t\tthis.add(new ctor());\n\t\t\t}\n\t\t} else if (current > length) {\n\t\t\tthis[isPath ? 'removeSegments' : 'removeChildren'](length, current);\n\t\t}\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titems[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n\t\t}\n\t\tif (isPath) {\n\t\t\tthis.setClosed(from._closed);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tcompare: function(path) {\n\t\tvar ok = false;\n\t\tif (path) {\n\t\t\tvar paths1 = this._children || [this],\n\t\t\t\tpaths2 = path._children ? path._children.slice() : [path],\n\t\t\t\tlength1 = paths1.length,\n\t\t\t\tlength2 = paths2.length,\n\t\t\t\tmatched = [],\n\t\t\t\tcount = 0;\n\t\t\tok = true;\n\t\t\tfor (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {\n\t\t\t\tvar path1 = paths1[i1];\n\t\t\t\tok = false;\n\t\t\t\tfor (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {\n\t\t\t\t\tif (path1.compare(paths2[i2])) {\n\t\t\t\t\t\tif (!matched[i2]) {\n\t\t\t\t\t\t\tmatched[i2] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = ok && count === length2;\n\t\t}\n\t\treturn ok;\n\t},\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar segments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: arguments\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? arguments\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._segmentSelection = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setSegments(source._segments);\n\t\tthis._closed = source._closed;\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tthis._length = this._area = undefined;\n\t\t\tif (flags & 16) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 32) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected(),\n\t\t\tlength = segments && segments.length;\n\t\tthis._segments.length = 0;\n\t\tthis._segmentSelection = 0;\n\t\tthis._curves = undefined;\n\t\tif (length) {\n\t\t\tvar last = segments[length - 1];\n\t\t\tif (typeof last === 'boolean') {\n\t\t\t\tthis.setClosed(last);\n\t\t\t\tlength--;\n\t\t\t}\n\t\t\tthis._add(Segment.readList(segments, 0, {}, length));\n\t\t}\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine) {\n\t\t\t\t\t\tvar dx = curX - prevX,\n\t\t\t\t\t\t\tdy = curY - prevY;\n\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t  dx === 0 ? 'v' + f.number(dy)\n\t\t\t\t\t\t\t: dy === 0 ? 'h' + f.number(dx)\n\t\t\t\t\t\t\t: 'l' + f.pair(dx, dy));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair( inX - prevX,  inY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (!length)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._segments.length;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar segments = this._segments,\n\t\t\tcoords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selection);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tstart = index > 0 && index + amount - 1 === total ? index - 1\n\t\t\t\t\t: index,\n\t\t\t\tinsert = start,\n\t\t\t\tend = Math.min(start + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [start, 0].concat(segs._curves));\n\t\t\t\tinsert += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = insert; i < end; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(start, end);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(start, end) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && !start ? segments.length - 1\n\t\t\t\t: start - 1]) {\n\t\t\tcurve._segment2 = segments[start] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[end]) {\n\t\t\tcurve._segment1 = segments[end];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readList(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readList(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(start, end, _includeCurves) {\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(start, end - start),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, segment._selection, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = start, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = start > 0 && end === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? start - 1\n\t\t\t\t\t: start,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\t\tcurves[i]._path = null;\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tvar area = this._area;\n\t\tif (area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tclosed = this._closed;\n\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar last = i + 1 === l;\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[last ? 0 : i + 1],\n\t\t\t\t\t\tnull, last && !closed));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn area;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this.isSelected() && length > 0 && this._segmentSelection\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelection: function setSelection(selection) {\n\t\tif (!(selection & 1))\n\t\t\tthis._selectSegments(false);\n\t\tsetSelection.base.call(this, selection);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tselection = selected ? 7 : 0;\n\t\tthis._segmentSelection = selection * length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tsegments[i]._selection = selection;\n\t},\n\n\t_updateSelection: function(segment, oldSelection, newSelection) {\n\t\tsegment._selection = newSelection;\n\t\tvar selection = this._segmentSelection += newSelection - oldSelection;\n\t\tif (selection > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tdivideAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tcurve;\n\t\treturn loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))\n\t\t\t\t? curve._segment1\n\t\t\t\t: null;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tindex = loc && loc.index,\n\t\t\ttime = loc && loc.time,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (time > tMax) {\n\t\t\tindex++;\n\t\t\ttime = 0;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (time >= tMin) {\n\t\t\t\tcurves[index++].divideAtTime(time);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.copyAttributes(this);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\tsplit: function(index, time) {\n\t\tvar curve,\n\t\t\tlocation = time === undefined ? index\n\t\t\t\t: (curve = this.getCurves()[index])\n\t\t\t\t\t&& curve.getLocationAtTime(time);\n\t\treturn location != null ? this.splitAt(location) : null;\n\t},\n\n\tjoin: function(path, tolerance) {\n\t\tvar epsilon = tolerance || 0;\n\t\tif (path && path !== this) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.isClose(last2._point, epsilon))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.isClose(first2._point, epsilon)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.isClose(first2._point, epsilon))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.isClose(last2._point, epsilon)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.isClose(last._point, epsilon)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\treduce: function(options) {\n\t\tvar curves = this.getCurves(),\n\t\t\tsimplify = options && options.simplify,\n\t\t\ttolerance = simplify ? 1e-7 : 0;\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (!curve.hasLength(tolerance)\n\t\t\t\t\t|| simplify && curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tthis._changed(9);\n\t},\n\n\tflatten: function(flatness) {\n\t\tvar flattener = new PathFlattener(this, flatness || 0.25, 256, true),\n\t\t\tparts = flattener.parts,\n\t\t\tlength = parts.length,\n\t\t\tsegments = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tsegments.push(new Segment(parts[i].curve.slice(0, 2)));\n\t\t}\n\t\tif (!this._closed && length > 0) {\n\t\t\tsegments.push(new Segment(parts[length - 1].curve.slice(6)));\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tvar segments = new PathFitter(this).fit(tolerance || 2.5);\n\t\tif (segments)\n\t\t\tthis.setSegments(segments);\n\t\treturn !!segments;\n\t},\n\n\tsmooth: function(options) {\n\t\tvar that = this,\n\t\t\topts = options || {},\n\t\t\ttype = opts.type || 'asymmetric',\n\t\t\tsegments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tclosed = this._closed;\n\n\t\tfunction getIndex(value, _default) {\n\t\t\tvar index = value && value.index;\n\t\t\tif (index != null) {\n\t\t\t\tvar path = value.path;\n\t\t\t\tif (path && path !== that)\n\t\t\t\t\tthrow new Error(value._class + ' ' + index + ' of ' + path\n\t\t\t\t\t\t\t+ ' is not part of ' + that);\n\t\t\t\tif (_default && value instanceof Curve)\n\t\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tindex = typeof value === 'number' ? value : _default;\n\t\t\t}\n\t\t\treturn Math.min(index < 0 && closed\n\t\t\t\t\t? index % length\n\t\t\t\t\t: index < 0 ? index + length : index, length - 1);\n\t\t}\n\n\t\tvar loop = closed && opts.from === undefined && opts.to === undefined,\n\t\t\tfrom = getIndex(opts.from, 0),\n\t\t\tto = getIndex(opts.to, length - 1);\n\n\t\tif (from > to) {\n\t\t\tif (closed) {\n\t\t\t\tfrom -= length;\n\t\t\t} else {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t}\n\t\tif (/^(?:asymmetric|continuous)$/.test(type)) {\n\t\t\tvar asymmetric = type === 'asymmetric',\n\t\t\t\tmin = Math.min,\n\t\t\t\tamount = to - from + 1,\n\t\t\t\tn = amount - 1,\n\t\t\t\tpadding = loop ? min(amount, 4) : 1,\n\t\t\t\tpaddingLeft = padding,\n\t\t\t\tpaddingRight = padding,\n\t\t\t\tknots = [];\n\t\t\tif (!closed) {\n\t\t\t\tpaddingLeft = min(1, from);\n\t\t\t\tpaddingRight = min(1, length - to - 1);\n\t\t\t}\n\t\t\tn += paddingLeft + paddingRight;\n\t\t\tif (n <= 1)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {\n\t\t\t\tknots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n\t\t\t}\n\n\t\t\tvar x = knots[0]._x + 2 * knots[1]._x,\n\t\t\t\ty = knots[0]._y + 2 * knots[1]._y,\n\t\t\t\tf = 2,\n\t\t\t\tn_1 = n - 1,\n\t\t\t\trx = [x],\n\t\t\t\try = [y],\n\t\t\t\trf = [f],\n\t\t\t\tpx = [],\n\t\t\t\tpy = [];\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tvar internal = i < n_1,\n\t\t\t\t\ta = internal ? 1 : asymmetric ? 1 : 2,\n\t\t\t\t\tb = internal ? 4 : asymmetric ? 2 : 7,\n\t\t\t\t\tu = internal ? 4 : asymmetric ? 3 : 8,\n\t\t\t\t\tv = internal ? 2 : asymmetric ? 0 : 1,\n\t\t\t\t\tm = a / f;\n\t\t\t\tf = rf[i] = b - m;\n\t\t\t\tx = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n\t\t\t\ty = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n\t\t\t}\n\n\t\t\tpx[n_1] = rx[n_1] / rf[n_1];\n\t\t\tpy[n_1] = ry[n_1] / rf[n_1];\n\t\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\t\tpx[i] = (rx[i] - px[i + 1]) / rf[i];\n\t\t\t\tpy[i] = (ry[i] - py[i + 1]) / rf[i];\n\t\t\t}\n\t\t\tpx[n] = (3 * knots[n]._x - px[n_1]) / 2;\n\t\t\tpy[n] = (3 * knots[n]._y - py[n_1]) / 2;\n\n\t\t\tfor (var i = paddingLeft, max = n - paddingRight, j = from;\n\t\t\t\t\ti <= max; i++, j++) {\n\t\t\t\tvar segment = segments[j < 0 ? j + length : j],\n\t\t\t\t\tpt = segment._point,\n\t\t\t\t\thx = px[i] - pt._x,\n\t\t\t\t\thy = py[i] - pt._y;\n\t\t\t\tif (loop || i < max)\n\t\t\t\t\tsegment.setHandleOut(hx, hy);\n\t\t\t\tif (loop || i > paddingLeft)\n\t\t\t\t\tsegment.setHandleIn(-hx, -hy);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = from; i <= to; i++) {\n\t\t\t\tsegments[i < 0 ? i + length : i].smooth(opts,\n\t\t\t\t\t\t!loop && i === from, !loop && i === to);\n\t\t\t}\n\t\t}\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t});\n\t\t\tshape.copyAttributes(this, true);\n\t\t\tshape._matrix.prepend(this._matrix);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\tif (insert === undefined || insert)\n\t\t\t\tshape.insertAbove(this);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\ttoPath: '#clone',\n\n\tcompare: function compare(path) {\n\t\tif (!path || path instanceof CompoundPath)\n\t\t\treturn compare.base.call(this, path);\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = curves2.length;\n\t\tif (!length1 || !length2) {\n\t\t\treturn length1 == length2;\n\t\t}\n\t\tvar v1 = curves1[0].getValues(),\n\t\t\tvalues2 = [],\n\t\t\tpos1 = 0, pos2,\n\t\t\tend1 = 0, end2;\n\t\tfor (var i = 0; i < length2; i++) {\n\t\t\tvar v2 = curves2[i].getValues();\n\t\t\tvalues2.push(v2);\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tpos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n\t\t\t\tend2 = overlaps[0][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar abs = Math.abs,\n\t\t\tepsilon = 1e-8,\n\t\t\tv2 = values2[pos2],\n\t\t\tstart2;\n\t\twhile (v1 && v2) {\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tvar t1 = overlaps[0][0];\n\t\t\t\tif (abs(t1 - end1) < epsilon) {\n\t\t\t\t\tend1 = overlaps[1][0];\n\t\t\t\t\tif (end1 === 1) {\n\t\t\t\t\t\tv1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n\t\t\t\t\t\tend1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = overlaps[0][1];\n\t\t\t\t\tif (abs(t2 - end2) < epsilon) {\n\t\t\t\t\t\tif (!start2)\n\t\t\t\t\t\t\tstart2 = [pos2, t2];\n\t\t\t\t\t\tend2 = overlaps[1][1];\n\t\t\t\t\t\tif (end2 === 1) {\n\t\t\t\t\t\t\tif (++pos2 >= length2)\n\t\t\t\t\t\t\t\tpos2 = 0;\n\t\t\t\t\t\t\tv2 = values2[pos2] || curves2[pos2].getValues();\n\t\t\t\t\t\t\tend2 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v1) {\n\t\t\t\t\t\t\treturn start2[0] === pos2 && start2[1] === end2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tstrokeRadius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (strokeRadius !== null) {\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tstrokePadding = strokePadding.add(\n\t\t\t\t\tPath._getStrokePadding(strokeRadius, strokeMatrix));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tvar isJoin = closed || segment._index > 0\n\t\t\t\t\t&& segment._index < numSegments - 1;\n\t\t\tif ((isJoin ? join : cap) === 'round') {\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t} else {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (isJoin) {\n\t\t\t\t\tif (!segment.isSmooth()) {\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius,\n\t\t\t\t\t\t\t   miterLimit, null, strokeMatrix, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t} else if (cap === 'square') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, null,\n\t\t\t\t\t\t\tstrokeMatrix, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (strokeRadius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar time = loc.getTime();\n\t\t\t\tif (time === 0 || time === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point)\n\t\t\t\t\t\t\t<= miterLimit * strokeRadius\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar loc = this.getLocationAt(offset);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset) {\n\t\tif (typeof offset === 'number') {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength()) {\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\t}\n\t\t} else if (offset && offset.getPath && offset.getPath() === this) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn null;\n\t}\n\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tvar half = size / 2,\n\t\t\tcoords = new Array(6),\n\t\t\tpX, pY;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tselection = segment._selection;\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tpX = coords[0];\n\t\t\tpY = coords[1];\n\t\t\tif (selection & 2)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (selection & 4)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (!(selection & 1)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar flattener = new PathFlattener(this, 0.25, 32, false,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = flattener.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\tflattener.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (!segments.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar abs = Math.abs,\n\t\t\t\tsqrt = Math.sqrt,\n\t\t\t\tcurrent = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(arguments);\n\t\t\t} else {\n\t\t\t\tvar radius = Size.read(arguments),\n\t\t\t\t\tisZero = Numerical.isZero;\n\t\t\t\tif (isZero(radius.width) || isZero(radius.height))\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq = x * x,\n\t\t\t\t\tySq = y * y;\n\t\t\t\tvar factor = sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1) * sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar epsilon = 1e-7,\n\t\t\t\text = abs(extent),\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = to,\n\t\t\t\t\tout = null;\n\t\t\t\tif (i < count) {\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t}\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(tolerance) {\n\t\t\tthis.setClosed(true);\n\t\t\tthis.join(this, tolerance);\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(matrix, options) {\n\t\tvar method = options.handle\n\t\t\t\t? 'getHandleBounds'\n\t\t\t\t: options.stroke\n\t\t\t\t? 'getStrokeBounds'\n\t\t\t\t: 'getBounds';\n\t\treturn Path[method](this._segments, this._closed, this, matrix, options);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, path, matrix, options, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6)),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = style.hasStroke(),\n\t\t\tstrokeWidth = style.getStrokeWidth(),\n\t\t\tstrokeMatrix = stroke && path._getStrokeMatrix(matrix, options),\n\t\t\tstrokePadding = stroke && Path._getStrokePadding(strokeWidth,\n\t\t\t\tstrokeMatrix),\n\t\t\tbounds = Path.getBounds(segments, closed, path, matrix, options,\n\t\t\t\tstrokePadding);\n\t\tif (!stroke)\n\t\t\treturn bounds;\n\t\tvar strokeRadius = strokeWidth / 2,\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = style.getMiterLimit(),\n\t\t\tjoinBounds = new Rectangle(new Size(strokePadding));\n\n\t\tfunction addPoint(point) {\n\t\t\tbounds = bounds.include(point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(\n\t\t\t\t\tjoinBounds.setCenter(segment._point.transform(matrix)));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tif (join === 'round' || segment.isSmooth()) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius, miterLimit,\n\t\t\t\t\t\tmatrix, strokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, matrix,\n\t\t\t\t\t\tstrokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tvar length = segments.length - (closed ? 0 : 1);\n\t\tfor (var i = 1; i < length; i++)\n\t\t\taddJoin(segments[i], join);\n\t\tif (closed) {\n\t\t\taddJoin(segments[0], join);\n\t\t} else if (length > 0) {\n\t\t\taddCap(segments[0], cap);\n\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getStrokePadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar hor = new Point(radius, 0).transform(matrix),\n\t\t\tver = new Point(0, radius).transform(matrix),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = Math.atan2(b * tan, a),\n\t\t\tty = Math.atan2(b, tan * a);\n\t\treturn [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, matrix,\n\t\t\tstrokeMatrix, addPoint, isArea) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPoint1().transform(matrix),\n\t\t\tnormal1 = curve1.getNormalAtTime(1).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\tnormal2 = curve2.getNormalAtTime(0).multiply(radius)\n\t\t\t\t.transform(strokeMatrix);\n\t\tif (normal1.getDirectedAngle(normal2) < 0) {\n\t\t\tnormal1 = normal1.negate();\n\t\t\tnormal2 = normal2.negate();\n\t\t}\n\t\tif (isArea)\n\t\t\taddPoint(point);\n\t\taddPoint(point.add(normal1));\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(point.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(point.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit * radius) {\n\t\t\t\taddPoint(corner);\n\t\t\t}\n\t\t}\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,\n\t\t\taddPoint, isArea) {\n\t\tvar point = segment._point.transform(matrix),\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal()\n\t\t\t\t\t.multiply(loc.getTime() === 0 ? radius : -radius)\n\t\t\t\t\t.transform(strokeMatrix);\n\t\tif (cap === 'square') {\n\t\t\tif (isArea) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tpoint = point.add(normal.rotate(-90));\n\t\t}\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = options.stroke && style.hasStroke(),\n\t\t\tstrokePadding,\n\t\t\tjoinPadding;\n\t\tif (stroke) {\n\t\t\tvar strokeMatrix = path._getStrokeMatrix(matrix, options),\n\t\t\t\tstrokeRadius = style.getStrokeWidth() / 2,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n\t\t\tstrokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n\t\t\tjoinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n\t\t}\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = !j ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && props.insert == false && Item.NO_INSERT);\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props, { insert: true });\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t], false, arguments);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\tpath = new Path(props && props.insert == false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = sides % 3 === 0,\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\tbeans: true,\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items) {\n\t\tvar list = items,\n\t\t\tfirst = list[0];\n\t\tif (first && typeof first[0] === 'number')\n\t\t\tlist = [list];\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = list[i];\n\t\t\tif (list === items && !(item instanceof Path))\n\t\t\t\tlist = Base.slice(list);\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tlist[i] = new Path({ segments: item, insert: false });\n\t\t\t} else if (item instanceof CompoundPath) {\n\t\t\t\tlist.splice.apply(list, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\treturn insertChildren.base.call(this, index, list);\n\t},\n\n\treduce: function reduce(options) {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce(options);\n\t\t\tif (path.isEmpty())\n\t\t\t\tpath.remove();\n\t\t}\n\t\tif (!children.length) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.copyAttributes(this);\n\t\t\tpath.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClosed: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tif (!children[i]._closed)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].setClosed(closed);\n\t\t}\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t},\n\n\tgetLength: function() {\n\t\tvar children = this._children,\n\t\t\tlength = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tlength += children[i].getLength();\n\t\treturn length;\n\t},\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.appended(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join('');\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\treturn _hitTestChildren.base.call(this, point,\n\t\t\t\toptions.class === Path || options.type === 'path' ? options\n\t\t\t\t\t: Base.set({}, options, { fill: false }),\n\t\t\t\tviewMatrix);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (!children.length)\n\t\t\treturn;\n\n\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\tctx.beginPath();\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectionItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectionItems[child._id]) {\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.appended(mx));\n\t\t\t}\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && !children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\treturn Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',\n\t\t\t'arcBy'],\n\t\tfunction(key) {\n\t\t\tthis[key] = function() {\n\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t};\n\t\t}, {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\n\t\t\tclosePath: function(tolerance) {\n\t\t\t\tgetCurrentPath(this, true).closePath(tolerance);\n\t\t\t}\n\t\t}\n\t);\n}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {\n\tthis[key] = function(param) {\n\t\tvar children = this._children,\n\t\t\tres;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tres = children[i][key](param) || res;\n\t\t}\n\t\treturn res;\n\t};\n}, {}));\n\nPathItem.inject(new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\toperators = {\n\t\t\tunite:     { '1': true, '2': true },\n\t\t\tintersect: { '2': true },\n\t\t\tsubtract:  { '1': true },\n\t\t\texclude:   { '1': true, '-1': true }\n\t\t};\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path.clone(false).reduce({ simplify: true })\n\t\t\t\t.transform(null, true, true);\n\t\treturn resolve\n\t\t\t\t? res.resolveCrossings().reorient(\n\t\t\t\t\tres.getFillRule() === 'nonzero', true)\n\t\t\t\t: res;\n\t}\n\n\tfunction createResult(paths, simplify, path1, path2, options) {\n\t\tvar result = new CompoundPath(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tresult = result.reduce({ simplify: simplify });\n\t\tif (!(options && options.insert == false)) {\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex() ? path2 : path1);\n\t\t}\n\t\tresult.copyAttributes(path1, true);\n\t\treturn result;\n\t}\n\n\tfunction traceBoolean(path1, path2, operation, options) {\n\t\tif (options && (options.trace == false || options.stroke) &&\n\t\t\t\t/^(subtract|intersect)$/.test(operation))\n\t\t\treturn splitBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true),\n\t\t\toperator = operators[operation];\n\t\toperator[operation] = true;\n\t\tif (_path2 && (operator.subtract || operator.exclude)\n\t\t\t\t^ (_path2.isClockwise() ^ _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar crossings = divideLocations(\n\t\t\t\tCurveLocation.expand(_path1.getCrossings(_path2))),\n\t\t\tpaths1 = _path1._children || [_path1],\n\t\t\tpaths2 = _path2 && (_path2._children || [_path2]),\n\t\t\tsegments = [],\n\t\t\tcurves = [],\n\t\t\tpaths;\n\n\t\tfunction collect(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\tcurves.push.apply(curves, path.getCurves());\n\t\t\t\tpath._overlapsOnly = true;\n\t\t\t}\n\t\t}\n\n\t\tif (crossings.length) {\n\t\t\tcollect(paths1);\n\t\t\tif (paths2)\n\t\t\t\tcollect(paths2);\n\t\t\tfor (var i = 0, l = crossings.length; i < l; i++) {\n\t\t\t\tpropagateWinding(crossings[i]._segment, _path1, _path2, curves,\n\t\t\t\t\t\toperator);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i],\n\t\t\t\t\tinter = segment._intersection;\n\t\t\t\tif (!segment._winding) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2, curves, operator);\n\t\t\t\t}\n\t\t\t\tif (!(inter && inter._overlap))\n\t\t\t\t\tsegment._path._overlapsOnly = false;\n\t\t\t}\n\t\t\tpaths = tracePaths(segments, operator);\n\t\t} else {\n\t\t\tpaths = reorientPaths(\n\t\t\t\t\tpaths2 ? paths1.concat(paths2) : paths1.slice(),\n\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\treturn !!operator[w];\n\t\t\t\t\t});\n\t\t}\n\n\t\treturn createResult(paths, true, path1, path2, options);\n\t}\n\n\tfunction splitBoolean(path1, path2, operation) {\n\t\tvar _path1 = preparePath(path1),\n\t\t\t_path2 = preparePath(path2),\n\t\t\tcrossings = _path1.getCrossings(_path2),\n\t\t\tsubtract = operation === 'subtract',\n\t\t\tdivide = operation === 'divide',\n\t\t\tadded = {},\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (!added[path._id] && (divide ||\n\t\t\t\t\t_path2.contains(path.getPointAt(path.getLength() / 2))\n\t\t\t\t\t\t^ subtract)) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn added[path._id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = crossings.length - 1; i >= 0; i--) {\n\t\t\tvar path = crossings[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn createResult(paths, false, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._previous;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._previous)\n\t\t\t\tto = to._previous;\n\t\t\tfrom._next = to;\n\t\t\tto._previous = from;\n\t\t}\n\t}\n\n\tfunction clearCurveHandles(curves) {\n\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\tcurves[i].clearHandles();\n\t}\n\n\tfunction reorientPaths(paths, isInside, clockwise) {\n\t\tvar length = paths && paths.length;\n\t\tif (length) {\n\t\t\tvar lookup = Base.each(paths, function (path, i) {\n\t\t\t\t\tthis[path._id] = {\n\t\t\t\t\t\tcontainer: null,\n\t\t\t\t\t\twinding: path.isClockwise() ? 1 : -1,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t};\n\t\t\t\t}, {}),\n\t\t\t\tsorted = paths.slice().sort(function (a, b) {\n\t\t\t\t\treturn abs(b.getArea()) - abs(a.getArea());\n\t\t\t\t}),\n\t\t\t\tfirst = sorted[0];\n\t\t\tif (clockwise == null)\n\t\t\t\tclockwise = first.isClockwise();\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar path1 = sorted[i],\n\t\t\t\t\tentry1 = lookup[path1._id],\n\t\t\t\t\tpoint = path1.getInteriorPoint(),\n\t\t\t\t\tcontainerWinding = 0;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tvar path2 = sorted[j];\n\t\t\t\t\tif (path2.contains(point)) {\n\t\t\t\t\t\tvar entry2 = lookup[path2._id];\n\t\t\t\t\t\tcontainerWinding = entry2.winding;\n\t\t\t\t\t\tentry1.winding += containerWinding;\n\t\t\t\t\t\tentry1.container = entry2.exclude ? entry2.container\n\t\t\t\t\t\t\t\t: path2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isInside(entry1.winding) === isInside(containerWinding)) {\n\t\t\t\t\tentry1.exclude = true;\n\t\t\t\t\tpaths[entry1.index] = null;\n\t\t\t\t} else {\n\t\t\t\t\tvar container = entry1.container;\n\t\t\t\t\tpath1.setClockwise(container ? !container.isClockwise()\n\t\t\t\t\t\t\t: clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\tfunction divideLocations(locations, include, clearLater) {\n\t\tvar results = include && [],\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tclearHandles = false,\n\t\t\tclearCurves = clearLater || [],\n\t\t\tclearLookup = clearLater && {},\n\t\t\trenormalizeLocs,\n\t\t\tprevCurve,\n\t\t\tprevTime;\n\n\t\tfunction getId(curve) {\n\t\t\treturn curve._path._id + '.' + curve._segment1._index;\n\t\t}\n\n\t\tfor (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {\n\t\t\tvar curve = clearLater[i];\n\t\t\tif (curve._path)\n\t\t\t\tclearLookup[getId(curve)] = true;\n\t\t}\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\ttime = loc._time,\n\t\t\t\torigTime = time,\n\t\t\t\texclude = include && !include(loc),\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tsegment;\n\t\t\tif (curve) {\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tclearHandles = !curve.hasHandles()\n\t\t\t\t\t\t\t|| clearLookup && clearLookup[getId(curve)];\n\t\t\t\t\trenormalizeLocs = [];\n\t\t\t\t\tprevTime = null;\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t} else if (prevTime >= tMin) {\n\t\t\t\t\ttime /= prevTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exclude) {\n\t\t\t\tif (renormalizeLocs)\n\t\t\t\t\trenormalizeLocs.push(loc);\n\t\t\t\tcontinue;\n\t\t\t} else if (include) {\n\t\t\t\tresults.unshift(loc);\n\t\t\t}\n\t\t\tprevTime = origTime;\n\t\t\tif (time < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tvar newCurve = curve.divideAtTime(time, true);\n\t\t\t\tif (clearHandles)\n\t\t\t\t\tclearCurves.push(curve, newCurve);\n\t\t\t\tsegment = newCurve._segment1;\n\t\t\t\tfor (var j = renormalizeLocs.length - 1; j >= 0; j--) {\n\t\t\t\t\tvar l = renormalizeLocs[j];\n\t\t\t\t\tl._time = (l._time - time) / (1 - time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t}\n\t\tif (!clearLater)\n\t\t\tclearCurveHandles(clearCurves);\n\t\treturn results || locations;\n\t}\n\n\tfunction getWinding(point, curves, dir, closed, dontFlip) {\n\t\tvar ia = dir ? 1 : 0,\n\t\t\tio = ia ^ 1,\n\t\t\tpv = [point.x, point.y],\n\t\t\tpa = pv[ia],\n\t\t\tpo = pv[io],\n\t\t\twindingEpsilon = 1e-9,\n\t\t\tqualityEpsilon = 1e-6,\n\t\t\tpaL = pa - windingEpsilon,\n\t\t\tpaR = pa + windingEpsilon,\n\t\t\twindingL = 0,\n\t\t\twindingR = 0,\n\t\t\tpathWindingL = 0,\n\t\t\tpathWindingR = 0,\n\t\t\tonPath = false,\n\t\t\tonAnyPath = false,\n\t\t\tquality = 1,\n\t\t\troots = [],\n\t\t\tvPrev,\n\t\t\tvClose;\n\n\t\tfunction addWinding(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po < min(o0, o3) || po > max(o0, o3)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar a0 = v[ia + 0],\n\t\t\t\ta1 = v[ia + 2],\n\t\t\t\ta2 = v[ia + 4],\n\t\t\t\ta3 = v[ia + 6];\n\t\t\tif (o0 === o3) {\n\t\t\t\tif (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t =   po === o0 ? 0\n\t\t\t\t\t: po === o3 ? 1\n\t\t\t\t\t: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Curve.solveCubic(v, io, po, roots, 0, 1) > 0\n\t\t\t\t\t\t? roots[0]\n\t\t\t\t\t\t: 1,\n\t\t\t\ta =   t === 0 ? a0\n\t\t\t\t\t: t === 1 ? a3\n\t\t\t\t\t: Curve.getPoint(v, t)[dir ? 'y' : 'x'],\n\t\t\t\twinding = o0 > o3 ? 1 : -1,\n\t\t\t\twindingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,\n\t\t\t\ta3Prev = vPrev[ia + 6];\n\t\t\tif (po !== o0) {\n\t\t\t\tif (a < paL) {\n\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t} else if (a > paR) {\n\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t} else {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\tif (a > pa - qualityEpsilon && a < pa + qualityEpsilon)\n\t\t\t\t\tquality /= 2;\n\t\t\t} else {\n\t\t\t\tif (winding !== windingPrev) {\n\t\t\t\t\tif (a0 < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t} else if (a0 > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t}\n\t\t\t\t} else if (a0 != a3Prev) {\n\t\t\t\t\tif (a3Prev < paR && a > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t} else if (a3Prev > paL && a < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquality = 0;\n\t\t\t}\n\t\t\tvPrev = v;\n\t\t\treturn !dontFlip && a > paL && a < paR\n\t\t\t\t\t&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0\n\t\t\t\t\t&& getWinding(point, curves, !dir, closed, true);\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to1 = v[io + 2],\n\t\t\t\to2 = v[io + 4],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n\t\t\t\tvar a0 = v[ia + 0],\n\t\t\t\t\ta1 = v[ia + 2],\n\t\t\t\t\ta2 = v[ia + 4],\n\t\t\t\t\ta3 = v[ia + 6],\n\t\t\t\t\tmonoCurves = paL > max(a0, a1, a2, a3) ||\n\t\t\t\t\t\t\t\t paR < min(a0, a1, a2, a3)\n\t\t\t\t\t\t\t? [v] : Curve.getMonoCurves(v, dir),\n\t\t\t\t\tres;\n\t\t\t\tfor (var i = 0, l = monoCurves.length; i < l; i++) {\n\t\t\t\t\tif (res = addWinding(monoCurves[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i],\n\t\t\t\tpath = curve._path,\n\t\t\t\tv = curve.getValues(),\n\t\t\t\tres;\n\t\t\tif (!i || curves[i - 1]._path !== path) {\n\t\t\t\tvPrev = null;\n\t\t\t\tif (!path._closed) {\n\t\t\t\t\tvClose = Curve.getValues(\n\t\t\t\t\t\t\tpath.getLastCurve().getSegment2(),\n\t\t\t\t\t\t\tcurve.getSegment1(),\n\t\t\t\t\t\t\tnull, !closed);\n\t\t\t\t\tif (vClose[io] !== vClose[io + 6]) {\n\t\t\t\t\t\tvPrev = vClose;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!vPrev) {\n\t\t\t\t\tvPrev = v;\n\t\t\t\t\tvar prev = path.getLastCurve();\n\t\t\t\t\twhile (prev && prev !== curve) {\n\t\t\t\t\t\tvar v2 = prev.getValues();\n\t\t\t\t\t\tif (v2[io] !== v2[io + 6]) {\n\t\t\t\t\t\t\tvPrev = v2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = prev.getPrevious();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res = handleCurve(v))\n\t\t\t\treturn res;\n\n\t\t\tif (i + 1 === l || curves[i + 1]._path !== path) {\n\t\t\t\tif (vClose && (res = handleCurve(vClose)))\n\t\t\t\t\treturn res;\n\t\t\t\tif (onPath && !pathWindingL && !pathWindingR) {\n\t\t\t\t\tpathWindingL = pathWindingR = path.isClockwise(closed) ^ dir\n\t\t\t\t\t\t\t? 1 : -1;\n\t\t\t\t}\n\t\t\t\twindingL += pathWindingL;\n\t\t\t\twindingR += pathWindingR;\n\t\t\t\tpathWindingL = pathWindingR = 0;\n\t\t\t\tif (onPath) {\n\t\t\t\t\tonAnyPath = true;\n\t\t\t\t\tonPath = false;\n\t\t\t\t}\n\t\t\t\tvClose = null;\n\t\t\t}\n\t\t}\n\t\twindingL = abs(windingL);\n\t\twindingR = abs(windingR);\n\t\treturn {\n\t\t\twinding: max(windingL, windingR),\n\t\t\twindingL: windingL,\n\t\t\twindingR: windingR,\n\t\t\tquality: quality,\n\t\t\tonPath: onAnyPath\n\t\t};\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, curves, operator) {\n\t\tvar chain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twinding;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve(),\n\t\t\t\tlength = curve.getLength();\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\ttotalLength += length;\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tvar offsets = [0.5, 0.25, 0.75],\n\t\t\twinding = { winding: 0, quality: -1 },\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tfor (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {\n\t\t\tvar length = totalLength * offsets[i];\n\t\t\tfor (var j = 0, l = chain.length; j < l; j++) {\n\t\t\t\tvar entry = chain[j],\n\t\t\t\t\tcurveLength = entry.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tvar curve = entry.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\toperand = parent instanceof CompoundPath ? parent : path,\n\t\t\t\t\t\tt = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),\n\t\t\t\t\t\tpt = curve.getPointAtTime(t),\n\t\t\t\t\t\tdir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n\t\t\t\t\tvar wind = !(operator.subtract && path2 && (\n\t\t\t\t\t\t\toperand === path1 &&\n\t\t\t\t\t\t\t\tpath2._getWinding(pt, dir, true).winding ||\n\t\t\t\t\t\t\toperand === path2 &&\n\t\t\t\t\t\t\t\t!path1._getWinding(pt, dir, true).winding))\n\t\t\t\t\t\t\t? getWinding(pt, curves, dir, true)\n\t\t\t\t\t\t\t: { winding: 0, quality: 1 };\n\t\t\t\t\tif (wind.quality > winding.quality)\n\t\t\t\t\t\twinding = wind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tfor (var j = chain.length - 1; j >= 0; j--) {\n\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t}\n\n\tfunction tracePaths(segments, operator) {\n\t\tvar paths = [],\n\t\t\tstarts;\n\n\t\tfunction isValid(seg) {\n\t\t\tvar winding;\n\t\t\treturn !!(seg && !seg._visited && (!operator\n\t\t\t\t\t|| operator[(winding = seg._winding || {}).winding]\n\t\t\t\t\t\t&& !(operator.unite && winding.winding === 2\n\t\t\t\t\t\t\t&& winding.windingL && winding.windingR)));\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\tif (seg) {\n\t\t\t\tfor (var i = 0, l = starts.length; i < l; i++) {\n\t\t\t\t\tif (seg === starts[i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction visitPath(path) {\n\t\t\tvar segments = path._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._visited = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCrossingSegments(segment, collectStarts) {\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tstart = inter,\n\t\t\t\tcrossings = [];\n\t\t\tif (collectStarts)\n\t\t\t\tstarts = [segment];\n\n\t\t\tfunction collect(inter, end) {\n\t\t\t\twhile (inter && inter !== end) {\n\t\t\t\t\tvar other = inter._segment,\n\t\t\t\t\t\tpath = other._path,\n\t\t\t\t\t\tnext = other.getNext() || path && path.getFirstSegment(),\n\t\t\t\t\t\tnextInter = next && next._intersection;\n\t\t\t\t\tif (other !== segment && (isStart(other) || isStart(next)\n\t\t\t\t\t\t|| next && (isValid(other) && (isValid(next)\n\t\t\t\t\t\t\t|| nextInter && isValid(nextInter._segment))))) {\n\t\t\t\t\t\tcrossings.push(other);\n\t\t\t\t\t}\n\t\t\t\t\tif (collectStarts)\n\t\t\t\t\t\tstarts.push(other);\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inter) {\n\t\t\t\tcollect(inter);\n\t\t\t\twhile (inter && inter._prev)\n\t\t\t\t\tinter = inter._prev;\n\t\t\t\tcollect(inter, start);\n\t\t\t}\n\t\t\treturn crossings;\n\t\t}\n\n\t\tsegments.sort(function(seg1, seg2) {\n\t\t\tvar inter1 = seg1._intersection,\n\t\t\t\tinter2 = seg2._intersection,\n\t\t\t\tover1 = !!(inter1 && inter1._overlap),\n\t\t\t\tover2 = !!(inter2 && inter2._overlap),\n\t\t\t\tpath1 = seg1._path,\n\t\t\t\tpath2 = seg2._path;\n\t\t\treturn over1 ^ over2\n\t\t\t\t\t? over1 ? 1 : -1\n\t\t\t\t\t: !inter1 ^ !inter2\n\t\t\t\t\t\t? inter1 ? 1 : -1\n\t\t\t\t\t\t: path1 !== path2\n\t\t\t\t\t\t\t? path1._id - path2._id\n\t\t\t\t\t\t\t: seg1._index - seg2._index;\n\t\t});\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tvalid = isValid(seg),\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false,\n\t\t\t\tclosed = true,\n\t\t\t\tbranches = [],\n\t\t\t\tbranch,\n\t\t\t\tvisited,\n\t\t\t\thandleIn;\n\t\t\tif (valid && seg._path._overlapsOnly) {\n\t\t\t\tvar path1 = seg._path,\n\t\t\t\t\tpath2 = seg._intersection._segment._path;\n\t\t\t\tif (path1.compare(path2)) {\n\t\t\t\t\tif (path1.getArea())\n\t\t\t\t\t\tpaths.push(path1.clone(false));\n\t\t\t\t\tvisitPath(path1);\n\t\t\t\t\tvisitPath(path2);\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (valid) {\n\t\t\t\tvar first = !path,\n\t\t\t\t\tcrossings = getCrossingSegments(seg, first),\n\t\t\t\t\tother = crossings.shift(),\n\t\t\t\t\tfinished = !first && (isStart(seg) || isStart(other)),\n\t\t\t\t\tcross = !finished && other;\n\t\t\t\tif (first) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tif (seg.isFirst() || seg.isLast())\n\t\t\t\t\t\tclosed = seg._path._closed;\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cross && branch) {\n\t\t\t\t\tbranches.push(branch);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (!branch) {\n\t\t\t\t\tif (cross)\n\t\t\t\t\t\tcrossings.push(seg);\n\t\t\t\t\tbranch = {\n\t\t\t\t\t\tstart: path._segments.length,\n\t\t\t\t\t\tcrossings: crossings,\n\t\t\t\t\t\tvisited: visited = [],\n\t\t\t\t\t\thandleIn: handleIn\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (cross)\n\t\t\t\t\tseg = other;\n\t\t\t\tif (!isValid(seg)) {\n\t\t\t\t\tpath.removeSegments(branch.start);\n\t\t\t\t\tfor (var j = 0, k = visited.length; j < k; j++) {\n\t\t\t\t\t\tvisited[j]._visited = false;\n\t\t\t\t\t}\n\t\t\t\t\tvisited.length = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tseg = branch && branch.crossings.shift();\n\t\t\t\t\t\tif (!seg) {\n\t\t\t\t\t\t\tbranch = branches.pop();\n\t\t\t\t\t\t\tif (branch) {\n\t\t\t\t\t\t\t\tvisited = branch.visited;\n\t\t\t\t\t\t\t\thandleIn = branch.handleIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (branch && !isValid(seg));\n\t\t\t\t\tif (!seg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar next = seg.getNext();\n\t\t\t\tpath.add(new Segment(seg._point, handleIn,\n\t\t\t\t\t\tnext && seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tvisited.push(seg);\n\t\t\t\tseg = next || seg._path.getFirstSegment();\n\t\t\t\thandleIn = next && next._handleIn;\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(handleIn);\n\t\t\t\t\tpath.setClosed(closed);\n\t\t\t\t}\n\t\t\t\tif (path.getArea() !== 0) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, dir, closed) {\n\t\t\treturn getWinding(point, this.getCurves(), dir, closed);\n\t\t},\n\n\t\tunite: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'unite', options);\n\t\t},\n\n\t\tintersect: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'intersect', options);\n\t\t},\n\n\t\tsubtract: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'subtract', options);\n\t\t},\n\n\t\texclude: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'exclude', options);\n\t\t},\n\n\t\tdivide: function(path, options) {\n\t\t\treturn options && (options.trace == false || options.stroke)\n\t\t\t\t\t? splitBoolean(this, path, 'divide')\n\t\t\t\t\t: createResult([\n\t\t\t\t\t\tthis.subtract(path, options),\n\t\t\t\t\t\tthis.intersect(path, options)\n\t\t\t\t\t], true, this, path, options);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = children || [this];\n\n\t\t\tfunction hasOverlap(seg) {\n\t\t\t\tvar inter = seg && seg._intersection;\n\t\t\t\treturn inter && inter._overlap;\n\t\t\t}\n\n\t\t\tvar hasOverlaps = false,\n\t\t\t\thasCrossings = false,\n\t\t\t\tintersections = this.getIntersections(null, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap() && (hasOverlaps = true) ||\n\t\t\t\t\t\t\tinter.isCrossing() && (hasCrossings = true);\n\t\t\t\t}),\n\t\t\t\tclearCurves = hasOverlaps && hasCrossings && [];\n\t\t\tintersections = CurveLocation.expand(intersections);\n\t\t\tif (hasOverlaps) {\n\t\t\t\tvar overlaps = divideLocations(intersections, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap();\n\t\t\t\t}, clearCurves);\n\t\t\t\tfor (var i = overlaps.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar seg = overlaps[i]._segment,\n\t\t\t\t\t\tprev = seg.getPrevious(),\n\t\t\t\t\t\tnext = seg.getNext();\n\t\t\t\t\tif (hasOverlap(prev) && hasOverlap(next)) {\n\t\t\t\t\t\tseg.remove();\n\t\t\t\t\t\tprev._handleOut._set(0, 0);\n\t\t\t\t\t\tnext._handleIn._set(0, 0);\n\t\t\t\t\t\tif (prev !== seg && !prev.getCurve().hasLength()) {\n\t\t\t\t\t\t\tnext._handleIn.set(prev._handleIn);\n\t\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCrossings) {\n\t\t\t\tdivideLocations(intersections, hasOverlaps && function(inter) {\n\t\t\t\t\tvar curve1 = inter.getCurve(),\n\t\t\t\t\t\tseg1 = inter.getSegment(),\n\t\t\t\t\t\tother = inter._intersection,\n\t\t\t\t\t\tcurve2 = other._curve,\n\t\t\t\t\t\tseg2 = other._segment;\n\t\t\t\t\tif (curve1 && curve2 && curve1._path && curve2._path)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (seg1)\n\t\t\t\t\t\tseg1._intersection = null;\n\t\t\t\t\tif (seg2)\n\t\t\t\t\t\tseg2._intersection = null;\n\t\t\t\t}, clearCurves);\n\t\t\t\tif (clearCurves)\n\t\t\t\t\tclearCurveHandles(clearCurves);\n\t\t\t\tpaths = tracePaths(Base.each(paths, function(path) {\n\t\t\t\t\tthis.push.apply(this, path._segments);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\tvar length = paths.length,\n\t\t\t\titem;\n\t\t\tif (length > 1 && children) {\n\t\t\t\tif (paths !== children)\n\t\t\t\t\tthis.setChildren(paths);\n\t\t\t\titem = this;\n\t\t\t} else if (length === 1 && !children) {\n\t\t\t\tif (paths[0] !== this)\n\t\t\t\t\tthis.setSegments(paths[0].removeSegments());\n\t\t\t\titem = this;\n\t\t\t}\n\t\t\tif (!item) {\n\t\t\t\titem = new CompoundPath(Item.NO_INSERT);\n\t\t\t\titem.addChildren(paths);\n\t\t\t\titem = item.reduce();\n\t\t\t\titem.copyAttributes(this);\n\t\t\t\tthis.replaceWith(item);\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\n\t\treorient: function(nonZero, clockwise) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && children.length) {\n\t\t\t\tthis.setChildren(reorientPaths(this.removeChildren(),\n\t\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\t\treturn !!(nonZero ? w : w & 1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclockwise));\n\t\t\t} else if (clockwise !== undefined) {\n\t\t\t\tthis.setClockwise(clockwise);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\ty = point.y,\n\t\t\t\t\tintercepts = [],\n\t\t\t\t\troots = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar v = curves[i].getValues(),\n\t\t\t\t\t\to0 = v[1],\n\t\t\t\t\t\to1 = v[3],\n\t\t\t\t\t\to2 = v[5],\n\t\t\t\t\t\to3 = v[7];\n\t\t\t\t\tif (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n\t\t\t\t\t\tvar monoCurves = Curve.getMonoCurves(v);\n\t\t\t\t\t\tfor (var j = 0, m = monoCurves.length; j < m; j++) {\n\t\t\t\t\t\t\tvar mv = monoCurves[j],\n\t\t\t\t\t\t\t\tmo0 = mv[1],\n\t\t\t\t\t\t\t\tmo3 = mv[7];\n\t\t\t\t\t\t\tif ((mo0 !== mo3) &&\n\t\t\t\t\t\t\t\t(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){\n\t\t\t\t\t\t\t\tvar x = y === mo0 ? mv[0]\n\t\t\t\t\t\t\t\t\t: y === mo3 ? mv[6]\n\t\t\t\t\t\t\t\t\t: Curve.solveCubic(mv, 1, y, roots, 0, 1)\n\t\t\t\t\t\t\t\t\t\t=== 1\n\t\t\t\t\t\t\t\t\t\t? Curve.getPoint(mv, roots[0]).x\n\t\t\t\t\t\t\t\t\t\t: (mv[0] + mv[6]) / 2;\n\t\t\t\t\t\t\t\tintercepts.push(x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (intercepts.length > 1) {\n\t\t\t\t\tintercepts.sort(function(a, b) { return a - b; });\n\t\t\t\t\tpoint.x = (intercepts[0] + intercepts[1]) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point;\n\t\t}\n\t};\n});\n\nvar PathFlattener = Base.extend({\n\t_class: 'PathFlattener',\n\n\tinitialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminSpan = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, t1, t2) {\n\t\t\tif ((t2 - t1) > minSpan\n\t\t\t\t\t&& !(ignoreStraight && Curve.isStraight(curve))\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, flatness || 0.25)) {\n\t\t\t\tvar halves = Curve.subdivide(curve, 0.5),\n\t\t\t\t\ttMid = (t1 + t2) / 2;\n\t\t\t\tcomputeParts(halves[0], index, t1, tMid);\n\t\t\t\tcomputeParts(halves[1], index, tMid, t2);\n\t\t\t} else {\n\t\t\t\tvar dx = curve[6] - curve[0],\n\t\t\t\t\tdy = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tif (dist > 0) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tcurve: curve,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttime: t2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\t_get: function(offset) {\n\t\tvar parts = this.parts,\n\t\t\tlength = parts.length,\n\t\t\tstart,\n\t\t\ti, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (!j || parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\tvar part = parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = parts[i - 1],\n\t\t\t\t\tprevTime = prev && prev.index === part.index ? prev.time : 0,\n\t\t\t\t\tprevOffset = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tindex: part.index,\n\t\t\t\t\ttime: prevTime + (part.time - prevTime)\n\t\t\t\t\t\t* (offset - prevOffset) / (part.offset - prevOffset)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tindex: parts[length - 1].index,\n\t\t\ttime: 1\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tvar start = this._get(from),\n\t\t\tend = this._get(to);\n\t\tfor (var i = start.index, l = end.index; i <= l; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti === start.index ? start.time : 0,\n\t\t\t\t\ti === end.index ? end.time : 1);\n\t\t\tif (i === start.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar param = this._get(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.time);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tclosed = path._closed;\n\t\tfor (var i = 0, prev, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point;\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(prev = point.clone());\n\t\t\t}\n\t\t}\n\t\tif (closed) {\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\t\tthis.closed = closed;\n\t},\n\n\tfit: function(error) {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = null;\n\t\tif (length > 0) {\n\t\t\tsegments = [new Segment(points[0])];\n\t\t\tif (length > 1) {\n\t\t\t\tthis.fitCubic(segments, error, 0, length - 1,\n\t\t\t\t\t\tpoints[1].subtract(points[0]),\n\t\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]));\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tsegments.shift();\n\t\t\t\t\tsegments.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(segments, error, first, last, tan1, tan2) {\n\t\tvar points = this.points;\n\t\tif (last - first === 1) {\n\t\t\tvar pt1 = points[first],\n\t\t\t\tpt2 = points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(error, error * error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < error && parametersInOrder) {\n\t\t\t\tthis.addCurve(segments, curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar tanCenter = points[split - 1].subtract(points[split + 1]);\n\t\tthis.fitCubic(segments, error, first, split, tan1, tanCenter);\n\t\tthis.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(segments, curve) {\n\t\tvar prev = segments[segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tsegments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tabs = Math.abs,\n\t\t\tpoints = this.points,\n\t\t\tpt1 = points[first],\n\t\t\tpt2 = points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1,\n\t\t\talpha2;\n\t\tif (abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\talpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0\n\t\t\t\t\t\t\t: abs(c1) > epsilon ? X[1] / c1\n\t\t\t\t\t\t\t: 0;\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1,\n\t\t\t\tpt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)),\n\t\t\t\tpt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\treturn Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsOptions: { stroke: false, handle: false },\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setContent(source._content);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(265);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\tvar lines = this._lines,\n\t\t\tstyle = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar rect = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(rect, rect) : rect;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tcolorCache = {},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tcomponents = [0, 0, 0];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\tcomponents = match[1].split(',');\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar value = +components[i];\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t}\n\t\t} else if (window) {\n\t\t\tvar cached = colorCache[string];\n\t\t\tif (!cached) {\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\tdata[2] / 255\n\t\t\t\t];\n\t\t\t}\n\t\t\tcomponents = cached.slice();\n\t\t} else {\n\t\t\tcomponents = [0, 0, 0];\n\t\t}\n\t\treturn components;\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t? function(value) {\n\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t};\n\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar args = arguments,\n\t\t\t\treading = this.__read,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (reading)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = Base.slice(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (reading) {\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = Base.slice(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && !i && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (reading && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (reading)\n\t\t\t\tthis.__read = read;\n\t\t\treturn this;\n\t\t},\n\n\t\tset: '#initialize',\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this.getAlpha() === col.getAlpha()\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx, matrix) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\thighlight = components[3],\n\t\t\t\tinverse = matrix && matrix.inverted(),\n\t\t\t\tcanvasGradient;\n\t\t\tif (inverse) {\n\t\t\t\torigin = inverse._transformPoint(origin);\n\t\t\t\tdestination = inverse._transformPoint(destination);\n\t\t\t\tif (highlight)\n\t\t\t\t\thighlight = inverse._transformPoint(highlight);\n\t\t\t}\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin);\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tcanvasGradient.addColorStop(\n\t\t\t\t\t\toffset == null ? i / (l - 1) : offset,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && Base.isPlainObject(stops)) {\n\t\t\tthis.set(stops);\n\t\t\tstops = radial = null;\n\t\t}\n\t\tif (this._stops == null) {\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t}\n\t\tif (this._radial == null) {\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t\t}\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++) {\n\t\t\tthis._owners[i]._changed();\n\t\t}\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (!this._owners.length)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tstops[i] = this._stops[i].clone();\n\t\t}\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t}\n\t\tvar _stops = this._stops;\n\t\tif (_stops) {\n\t\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t\t_stops[i]._owner = undefined;\n\t\t}\n\t\t_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t_stops[i]._owner = this;\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class) {\n\t\t\tvar stops1 = this._stops,\n\t\t\t\tstops2 = gradient._stops,\n\t\t\t\tlength = stops1.length;\n\t\t\tif (length === stops2.length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (!stops1[i].equals(stops2[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tvar color = arg0,\n\t\t\toffset = arg1;\n\t\tif (typeof arg0 === 'object' && arg1 === undefined) {\n\t\t\tif (Array.isArray(arg0) && typeof arg0[0] !== 'number') {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\toffset = arg0[1];\n\t\t\t} else if ('color' in arg0 || 'offset' in arg0\n\t\t\t\t\t|| 'rampPoint' in arg0) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\toffset = arg0.offset || arg0.rampPoint || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setColor(color);\n\t\tthis.setOffset(offset);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._offset);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar color = this._color,\n\t\t\toffset = this._offset;\n\t\treturn Base.serialize(offset == null ? [color] : [color, offset],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(65);\n\t},\n\n\tgetOffset: function() {\n\t\treturn this._offset;\n\t},\n\n\tsetOffset: function(offset) {\n\t\tthis._offset = offset;\n\t\tthis._changed();\n\t},\n\n\tgetRampPoint: '#getOffset',\n\tsetRampPoint: '#setOffset',\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function() {\n\t\tvar color = Color.read(arguments, 0, { clone: true });\n\t\tif (color)\n\t\t\tcolor._owner = this;\n\t\tthis._color = color;\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._offset == stop._offset\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar itemDefaults = {\n\t\tfillColor: null,\n\t\tfillRule: 'nonzero',\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\tshadowColor: null,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: null\n\t},\n\tgroupDefaults = Base.set({}, itemDefaults, {\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tleading: null,\n\t\tjustification: 'left'\n\t}),\n\ttextDefaults = Base.set({}, groupDefaults, {\n\t\tfillColor: new Color()\n\t}),\n\tflags = {\n\t\tstrokeWidth: 97,\n\t\tstrokeCap: 97,\n\t\tstrokeJoin: 97,\n\t\tstrokeScaling: 105,\n\t\tmiterLimit: 97,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t},\n\titem = {\n\t\tbeans: true\n\t},\n\tfields = {\n\t\t_class: 'Style',\n\t\tbeans: true,\n\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project\n\t\t\t\t\t|| paper.project;\n\t\t\tthis._defaults = !_owner || _owner instanceof Group ? groupDefaults\n\t\t\t\t\t: _owner instanceof TextItem ? textDefaults\n\t\t\t\t\t: itemDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t}\n\t};\n\n\tBase.each(groupDefaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children;\n\t\t\tif (children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t} else if (key in this._defaults) {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old && old._owner !== undefined)\n\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tvalue;\n\t\t\tif (key in this._defaults && (!children || !children.length\n\t\t\t\t\t|| _dontMerge || owner instanceof CompoundPath)) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tBase.each({\n\t\tFont: 'FontFamily',\n\t\tWindingRule: 'FillRule'\n\t}, function(value, key) {\n\t\tvar get = 'get' + key,\n\t\t\tset = 'set' + key;\n\t\tfields[get] = item[get] = '#get' + value;\n\t\tfields[set] = item[set] = '#set' + value;\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\tfunction compare(style1, style2, secondary) {\n\t\t\tvar values1 = style1._values,\n\t\t\t\tvalues2 = style2._values,\n\t\t\t\tdefaults2 = style2._defaults;\n\t\t\tfor (var key in values1) {\n\t\t\t\tvar value1 = values1[key],\n\t\t\t\t\tvalue2 = values2[key];\n\t\t\t\tif (!(secondary && key in values2) && !Base.equals(value1,\n\t\t\t\t\t\tvalue2 === undefined ? defaults2[key] : value2))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& compare(this, style)\n\t\t\t\t&& compare(style, this, true)\n\t\t\t\t|| false;\n\t},\n\n\thasFill: function() {\n\t\tvar color = this.getFillColor();\n\t\treturn !!color && color.alpha > 0;\n\t},\n\n\thasStroke: function() {\n\t\tvar color = this.getStrokeColor();\n\t\treturn !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\tvar color = this.getShadowColor();\n\t\treturn !!color && color.alpha > 0 && (this.getShadowBlur() > 0\n\t\t\t\t|| !this.getShadowOffset().isZero());\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tisInserted: function(el) {\n\t\t\treturn document.body.contains(el);\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn el && handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\ttimer;\n\n\tfunction handleCallbacks() {\n\t\tvar functions = callbacks;\n\t\tcallbacks = [];\n\t\tfor (var i = 0, l = functions.length; i < l; i++)\n\t\t\tfunctions[i]();\n\t\trequested = nativeRequest && callbacks.length;\n\t\tif (requested)\n\t\t\tnativeRequest(handleCallbacks);\n\t}\n\n\treturn function(callback) {\n\t\tcallbacks.push(callback);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t}\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t}\n\n\t\tvar size;\n\t\tif (window && element) {\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserDrag: none,\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsize = getCanvasSize();\n\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = new Size(element);\n\t\t\telement = null;\n\t\t}\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window && window.devicePixelRatio || 1;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize = size;\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t\tthis._itemEvents = { native: {}, virtual: {} };\n\t\tthis._autoUpdate = !paper.agent.node;\n\t\tthis._needsUpdate = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tvar project = this._project;\n\t\tif (project._view === this)\n\t\t\tproject._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(\n\t\tItem._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),\n\t\tfunction(name) {\n\t\t\tthis[name] = {};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\tgetAutoUpdate: function() {\n\t\treturn this._autoUpdate;\n\t},\n\n\tsetAutoUpdate: function(autoUpdate) {\n\t\tthis._autoUpdate = autoUpdate;\n\t\tif (autoUpdate)\n\t\t\tthis.requestUpdate();\n\t},\n\n\tupdate: function() {\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\trequestUpdate: function() {\n\t\tif (!this._requested) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (that._animate) {\n\t\t\t\t\tthat.requestUpdate();\n\t\t\t\t\tvar element = that._element;\n\t\t\t\t\tif ((!DomElement.getPrefixed(document, 'hidden')\n\t\t\t\t\t\t\t|| PaperScope.getAttribute(element, 'keepalive')\n\t\t\t\t\t\t\t\t=== 'true') && DomElement.isInView(element)) {\n\t\t\t\t\t\tthat._handleFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (that._autoUpdate)\n\t\t\t\t\tthat.update();\n\t\t\t});\n\t\t\tthis._requested = true;\n\t\t}\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tthis.requestUpdate();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._last ? now - this._last : 0;\n\t\tthis._last = now;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tthis._project._changed(2049);\n\t\tthis._bounds = this._decomposed = undefined;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize.set(size);\n\t\tthis._changed();\n\t\tthis.emit('resize', { size: size, delta: delta });\n\t\tif (this._autoUpdate) {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_setElementSize: function(width, height) {\n\t\tvar element = this._element;\n\t\tif (element) {\n\t\t\tif (element.width !== width)\n\t\t\t\telement.width = width;\n\t\t\tif (element.height !== height)\n\t\t\t\telement.height = height;\n\t\t}\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tisInserted: function() {\n\t\treturn DomElement.isInserted(this._element);\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixels;\n\t\tif (element) {\n\t\t\tvar parent = element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tpixels = parseFloat(pixels);\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\treturn 0;\n\t}\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getCenter(true)));\n\t};\n}, {\n\t_decompose: function() {\n\t\treturn this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.translate(this.getCenter().subtract(center));\n\t},\n\n\tgetZoom: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling ? (scaling.x + scaling.y) / 2 : 0;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis.transform(new Matrix().scale(zoom / this.getZoom(),\n\t\t\tthis.getCenter()));\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed && decomposed.rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tthis.rotate(rotation - current);\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling\n\t\t\t\t? new LinkedPoint(scaling.x, scaling.y, this, 'setScaling')\n\t\t\t\t: undefined;\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling) {\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._matrix.append(matrix);\n\t},\n\n\tscrollBy: function() {\n\t\tthis.translate(Point.read(arguments).negate());\n\t}\n}), {\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tgetEventPoint: function(event) {\n\t\treturn this.viewToProject(DomEvent.getOffset(event, this._element));\n\t},\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (document && typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\tvar ctor = window ? CanvasView : View;\n\t\t\treturn new ctor(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tif (!window)\n\t\treturn;\n\tvar prevFocus,\n\t\ttempFocus,\n\t\tdragging = false,\n\t\tmouseDown = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[\n\t\t\t\ttarget.getAttribute('id')];\n\t}\n\n\tfunction updateFocus() {\n\t\tvar view = View._focused;\n\t\tif (!view || !view.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tif ((view = View._views[i]).isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, event, point) {\n\t\tview._handleMouseEvent('mousemove', event, point);\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {},\n\t\tdocEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML')) {\n\t\t\t\t\tvar offset = DomEvent.getOffset(event, view._element),\n\t\t\t\t\t\tx = offset.x,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\tax = abs(x),\n\t\t\t\t\t\tmax = 1 << 25,\n\t\t\t\t\t\tdiff = ax - max;\n\t\t\t\t\toffset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n\t\t\t\t\thandleMouseMove(view, event, view.viewToProject(offset));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tscroll: updateFocus\n\t\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event);\n\t\tif (!dragging) {\n\t\t\tdragging = true;\n\t\t\tview._handleMouseEvent('mousedown', event);\n\t\t}\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!mouseDown) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target) {\n\t\t\t\t\tif (view)\n\t\t\t\t\t\thandleMouseMove(view, event);\n\t\t\t\t\tif (!prevFocus)\n\t\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t}\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tif (prevFocus && !prevFocus.isInserted())\n\t\t\t\t\tprevFocus = null;\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tprevFocus = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view)\n\t\t\thandleMouseMove(view, event);\n\t};\n\n\tdocEvents[mousedown] = function() {\n\t\tmouseDown = true;\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (view && dragging)\n\t\t\tview._handleMouseEvent('mouseup', event);\n\t\tmouseDown = dragging = false;\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar called = false,\n\t\tprevented = false,\n\t\tfallbacks = {\n\t\t\tdoubleclick: 'click',\n\t\t\tmousedrag: 'mousemove'\n\t\t},\n\t\twasInView = false,\n\t\toverView,\n\t\tdownPoint,\n\t\tlastPoint,\n\t\tdownItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tclickItem,\n\t\tclickTime,\n\t\tdblClick;\n\n\tfunction emitMouseEvent(obj, target, type, event, point, prevPoint,\n\t\t\tstopItem) {\n\t\tvar stopped = false,\n\t\t\tmouseEvent;\n\n\t\tfunction emit(obj, type) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point,\n\t\t\t\t\t\t\ttarget || obj,\n\t\t\t\t\t\t\tprevPoint ? point.subtract(prevPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent)) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif (mouseEvent.prevented)\n\t\t\t\t\t\tprevented = true;\n\t\t\t\t\tif (mouseEvent.stopped)\n\t\t\t\t\t\treturn stopped = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar fallback = fallbacks[type];\n\t\t\t\tif (fallback)\n\t\t\t\t\treturn emit(obj, fallback);\n\t\t\t}\n\t\t}\n\n\t\twhile (obj && obj !== stopItem) {\n\t\t\tif (emit(obj, type))\n\t\t\t\tbreak;\n\t\t\tobj = obj._parent;\n\t\t}\n\t\treturn stopped;\n\t}\n\n\tfunction emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n\t\tview._project.removeOn(type);\n\t\tprevented = called = false;\n\t\treturn (dragItem && emitMouseEvent(dragItem, null, type, event,\n\t\t\t\t\tpoint, prevPoint)\n\t\t\t|| hitItem && hitItem !== dragItem\n\t\t\t\t&& !hitItem.isDescendant(dragItem)\n\t\t\t\t&& emitMouseEvent(hitItem, null, type, event, point, prevPoint,\n\t\t\t\t\tdragItem)\n\t\t\t|| emitMouseEvent(view, dragItem || hitItem || view, type, event,\n\t\t\t\t\tpoint, prevPoint));\n\t}\n\n\tvar itemEventsMap = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleMouseEvent: function(type, event, point) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\thitItems = itemEvents.native[type],\n\t\t\t\tnativeMove = type === 'mousemove',\n\t\t\t\ttool = this._scope.tool,\n\t\t\t\tview = this;\n\n\t\t\tfunction responds(type) {\n\t\t\t\treturn itemEvents.virtual[type] || view.responds(type)\n\t\t\t\t\t\t|| tool && tool.responds(type);\n\t\t\t}\n\n\t\t\tif (nativeMove && dragging && responds('mousedrag'))\n\t\t\t\ttype = 'mousedrag';\n\t\t\tif (!point)\n\t\t\t\tpoint = this.getEventPoint(event);\n\n\t\t\tvar inView = this.getBounds().contains(point),\n\t\t\t\thit = hitItems && inView && view._project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\thitItem = hit && hit.item || null,\n\t\t\t\thandle = false,\n\t\t\t\tmouse = {};\n\t\t\tmouse[type.substr(5)] = true;\n\n\t\t\tif (hitItems && hitItem !== overItem) {\n\t\t\t\tif (overItem) {\n\t\t\t\t\temitMouseEvent(overItem, null, 'mouseleave', event, point);\n\t\t\t\t}\n\t\t\t\tif (hitItem) {\n\t\t\t\t\temitMouseEvent(hitItem, null, 'mouseenter', event, point);\n\t\t\t\t}\n\t\t\t\toverItem = hitItem;\n\t\t\t}\n\t\t\tif (wasInView ^ inView) {\n\t\t\t\temitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',\n\t\t\t\t\t\tevent, point);\n\t\t\t\toverView = inView ? this : null;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tif ((inView || mouse.drag) && !point.equals(lastPoint)) {\n\t\t\t\temitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',\n\t\t\t\t\t\tevent, point, lastPoint);\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\twasInView = inView;\n\t\t\tif (mouse.down && inView || mouse.up && downPoint) {\n\t\t\t\temitMouseEvents(this, hitItem, type, event, point, downPoint);\n\t\t\t\tif (mouse.down) {\n\t\t\t\t\tdblClick = hitItem === clickItem\n\t\t\t\t\t\t&& (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = clickItem = hitItem;\n\t\t\t\t\tif (!prevented && hitItem) {\n\t\t\t\t\t\tvar item = hitItem;\n\t\t\t\t\t\twhile (item && !item.responds('mousedrag'))\n\t\t\t\t\t\t\titem = item._parent;\n\t\t\t\t\t\tif (item)\n\t\t\t\t\t\t\tdragItem = hitItem;\n\t\t\t\t\t}\n\t\t\t\t\tdownPoint = point;\n\t\t\t\t} else if (mouse.up) {\n\t\t\t\t\tif (!prevented && hitItem === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\temitMouseEvents(this, hitItem, dblClick ? 'doubleclick'\n\t\t\t\t\t\t\t\t: 'click', event, point, downPoint);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t}\n\t\t\t\twasInView = false;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tlastPoint = point;\n\t\t\tif (handle && tool) {\n\t\t\t\tcalled = tool._handleMouseEvent(type, event, point, mouse)\n\t\t\t\t\t|| called;\n\t\t\t}\n\n\t\t\tif (called && !mouse.move || mouse.down && responds('mouseup'))\n\t\t\t\tevent.preventDefault();\n\t\t},\n\n\t\t_handleKeyEvent: function(type, event, key, character) {\n\t\t\tvar scope = this._scope,\n\t\t\t\ttool = scope.tool,\n\t\t\t\tkeyEvent;\n\n\t\t\tfunction emit(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tpaper = scope;\n\t\t\t\t\tobj.emit(type, keyEvent = keyEvent\n\t\t\t\t\t\t\t|| new KeyEvent(type, event, key, character));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isVisible()) {\n\t\t\t\temit(this);\n\t\t\t\tif (tool && tool.responds(type))\n\t\t\t\t\temit(tool);\n\t\t\t}\n\t\t},\n\n\t\t_countItemEvent: function(type, sign) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\tnative = itemEvents.native,\n\t\t\t\tvirtual = itemEvents.virtual;\n\t\t\tfor (var key in itemEventsMap) {\n\t\t\t\tnative[key] = (native[key] || 0)\n\t\t\t\t\t\t+ (itemEventsMap[key][type] || 0) * sign;\n\t\t\t}\n\t\t\tvirtual[type] = (virtual[type] || 0) + sign;\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof window.HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ Base.slice(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tvar ctx = this._context = canvas.getContext('2d');\n\t\tctx.save();\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(ctx,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t\tthis._needsUpdate = true;\n\t},\n\n\tremove: function remove() {\n\t\tthis._context.restore();\n\t\treturn remove.base.call(this);\n\t},\n\n\t_setElementSize: function _setElementSize(width, height) {\n\t\tvar pixelRatio = this._pixelRatio;\n\t\t_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n\t\tif (pixelRatio !== 1) {\n\t\t\tvar element = this._element,\n\t\t\t\tctx = this._context;\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\tctx.save();\n\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetPixelSize: function getPixelSize(size) {\n\t\tvar agent = paper.agent,\n\t\t\tpixels;\n\t\tif (agent && agent.firefox) {\n\t\t\tpixels = getPixelSize.base.call(this, size);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function() {\n\t\tif (!this._needsUpdate)\n\t\t\treturn false;\n\t\tvar project = this._project,\n\t\t\tctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tif (project)\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tthis._needsUpdate = false;\n\t\treturn true;\n\t}\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t\tthis.type = event && event.type;\n\t},\n\n\tprevented: false,\n\tstopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.prevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.stopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetTimeStamp: function() {\n\t\treturn this.event.timeStamp;\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(type, event, key, character) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\tvar keyLookup = {\n\t\t\t'\\t': 'tab',\n\t\t\t' ': 'space',\n\t\t\t'\\b': 'backspace',\n\t\t\t'\\x7f': 'delete',\n\t\t\t'Spacebar': 'space',\n\t\t\t'Del': 'delete',\n\t\t\t'Win': 'meta',\n\t\t\t'Esc': 'escape'\n\t\t},\n\n\t\tcharLookup = {\n\t\t\t'tab': '\\t',\n\t\t\t'space': ' ',\n\t\t\t'enter': '\\r'\n\t\t},\n\n\t\tkeyMap = {},\n\t\tcharMap = {},\n\t\tmetaFixMap,\n\t\tdownKey,\n\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\talt: false,\n\t\t\tmeta: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}).inject({\n\t\t\toption: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.alt;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcommand: {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar agent = paper && paper.agent;\n\t\t\t\t\treturn agent && agent.mac ? this.meta : this.control;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tfunction getKey(event) {\n\t\tvar key = event.key || event.keyIdentifier;\n\t\tkey = /^U\\+/.test(key)\n\t\t\t\t? String.fromCharCode(parseInt(key.substr(2), 16))\n\t\t\t\t: /^Arrow[A-Z]/.test(key) ? key.substr(5)\n\t\t\t\t: key === 'Unidentified' ? String.fromCharCode(event.keyCode)\n\t\t\t\t: key;\n\t\treturn keyLookup[key] ||\n\t\t\t\t(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n\t}\n\n\tfunction handleKey(down, key, character, event) {\n\t\tvar type = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharMap[key] = character;\n\t\t} else {\n\t\t\tdelete charMap[key];\n\t\t}\n\t\tif (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar agent = paper && paper.agent;\n\t\t\tif (name === 'meta' && agent && agent.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tmetaFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var k in metaFixMap) {\n\t\t\t\t\t\tif (k in charMap)\n\t\t\t\t\t\t\thandleKey(false, k, metaFixMap[k], event);\n\t\t\t\t\t}\n\t\t\t\t\tmetaFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && metaFixMap) {\n\t\t\tmetaFixMap[key] = character;\n\t\t}\n\t\tif (view) {\n\t\t\tview._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,\n\t\t\t\t\tcharacter);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar key = getKey(event),\n\t\t\t\tagent = paper && paper.agent;\n\t\t\tif (key.length > 1 || agent && (agent.chrome && (event.altKey\n\t\t\t\t\t\t|| agent.mac && event.metaKey\n\t\t\t\t\t\t|| !agent.mac && event.ctrlKey))) {\n\t\t\t\thandleKey(true, key,\n\t\t\t\t\t\tcharLookup[key] || (key.length > 1 ? '' : key), event);\n\t\t\t} else {\n\t\t\t\tdownKey = key;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downKey) {\n\t\t\t\tvar key = getKey(event),\n\t\t\t\t\tcode = event.charCode,\n\t\t\t\t\tcharacter = code >= 32 ? String.fromCharCode(code)\n\t\t\t\t\t\t: key.length > 1 ? '' : key;\n\t\t\t\tif (key !== downKey) {\n\t\t\t\t\tkey = character.toLowerCase();\n\t\t\t\t}\n\t\t\t\thandleKey(true, key, character, event);\n\t\t\t\tdownKey = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar key = getKey(event);\n\t\t\tif (key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn this.tool[/^mouse(down|up)$/.test(this.type)\n\t\t\t\t? '_downCount' : '_moveCount'];\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',\n\t\t\t'onKeyUp'],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._moveCount = -1;\n\t\tthis._downCount = -1;\n\t\tthis.set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_handleMouseEvent: function(type, event, point, mouse) {\n\t\tpaper = this._scope;\n\t\tif (mouse.drag && !this.responds(type))\n\t\t\ttype = 'mousemove';\n\t\tvar move = mouse.move || mouse.drag,\n\t\t\tresponds = this.responds(type),\n\t\t\tminDistance = this.minDistance,\n\t\t\tmaxDistance = this.maxDistance,\n\t\t\tcalled = false,\n\t\t\ttool = this;\n\t\tfunction update(minDistance, maxDistance) {\n\t\t\tvar pt = point,\n\t\t\t\ttoolPoint = move ? tool._point : (tool._downPoint || pt);\n\t\t\tif (move) {\n\t\t\t\tif (tool._moveCount && pt.equals(toolPoint)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (toolPoint && (minDistance != null || maxDistance != null)) {\n\t\t\t\t\tvar vector = pt.subtract(toolPoint),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < (minDistance || 0))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance) {\n\t\t\t\t\t\tpt = toolPoint.add(vector.normalize(\n\t\t\t\t\t\t\t\tMath.min(distance, maxDistance)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttool._moveCount++;\n\t\t\t}\n\t\t\ttool._point = pt;\n\t\t\ttool._lastPoint = toolPoint || pt;\n\t\t\tif (mouse.down) {\n\t\t\t\ttool._moveCount = -1;\n\t\t\t\ttool._downPoint = pt;\n\t\t\t\ttool._downCount++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction emit() {\n\t\t\tif (responds) {\n\t\t\t\tcalled = tool.emit(type, new ToolEvent(tool, type, event))\n\t\t\t\t\t\t|| called;\n\t\t\t}\n\t\t}\n\n\t\tif (mouse.down) {\n\t\t\tupdate();\n\t\t\temit();\n\t\t} else if (mouse.up) {\n\t\t\tupdate(null, maxDistance);\n\t\t\temit();\n\t\t} else if (responds) {\n\t\t\twhile (update(minDistance, maxDistance))\n\t\t\t\temit();\n\t\t}\n\t\treturn called;\n\t}\n\n});\n\nvar Http = {\n\trequest: function(options) {\n\t\tvar xhr = new self.XMLHttpRequest();\n\t\txhr.open((options.method || 'get').toUpperCase(), options.url,\n\t\t\t\tBase.pick(options.async, true));\n\t\tif (options.mimeType)\n\t\t\txhr.overrideMimeType(options.mimeType);\n\t\txhr.onload = function() {\n\t\t\tvar status = xhr.status;\n\t\t\tif (status === 0 || status === 200) {\n\t\t\t\tif (options.onLoad) {\n\t\t\t\t\toptions.onLoad.call(xhr, xhr.responseText);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txhr.onerror();\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tvar status = xhr.status,\n\t\t\t\tmessage = 'Could not load \"' + options.url + '\" (Status: '\n\t\t\t\t\t\t+ status + ')';\n\t\t\tif (options.onError) {\n\t\t\t\toptions.onError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height) {\n\t\tif (!window)\n\t\t\treturn null;\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tclear = false;\n\t\t}\n\t\tvar ctx = canvas.getContext('2d');\n\t\tif (!ctx) {\n\t\t\tthrow new Error('Canvas ' + canvas +\n\t\t\t\t\t' is unable to provide a 2D context.');\n\t\t}\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height) {\n\t\tvar canvas = this.getCanvas(width, height);\n\t\treturn canvas ? canvas.getContext('2d') : null;\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj && obj.canvas ? obj.canvas : obj;\n\t\tif (canvas && canvas.getContext) {\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1);\n\tif (ctx) {\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken\n\t\t\t\t\t\t\t? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t}\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SvgElement = new function() {\n\tvar svg = 'http://www.w3.org/2000/svg',\n\t\txmlns = 'http://www.w3.org/2000/xmlns',\n\t\txlink = 'http://www.w3.org/1999/xlink',\n\t\tattributeNamespace = {\n\t\t\thref: xlink,\n\t\t\txlink: xmlns,\n\t\t\txmlns: xmlns + '/',\n\t\t\t'xmlns:xlink': xmlns + '/'\n\t\t};\n\n\tfunction create(tag, attributes, formatter) {\n\t\treturn set(document.createElementNS(svg, tag), attributes, formatter);\n\t}\n\n\tfunction get(node, name) {\n\t\tvar namespace = attributeNamespace[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\treturn value === 'null' ? null : value;\n\t}\n\n\tfunction set(node, attributes, formatter) {\n\t\tfor (var name in attributes) {\n\t\t\tvar value = attributes[name],\n\t\t\t\tnamespace = attributeNamespace[name];\n\t\t\tif (typeof value === 'number' && formatter)\n\t\t\t\tvalue = formatter.number(value);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, name, value);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\treturn {\n\t\tsvg: svg,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\n\t\tcreate: create,\n\t\tget: get,\n\t\tset: set\n\t};\n};\n\nvar SvgStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tfillRule: ['fill-rule', 'string'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'style']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nnew function() {\n\tvar formatter;\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tmatrix = matrix._shiftless();\n\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\ttrans = null;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling,\n\t\t\t\t\tskew = decomposed.skewing;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (skew.x)\n\t\t\t\t\tparts.push('skewX(' + formatter.number(skew.x) + ')');\n\t\t\t\tif (skew.y)\n\t\t\t\t\tparts.push('skewY(' + formatter.number(skew.y) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = SvgElement.create('g', attrs, formatter);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = SvgElement.create('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tSvgElement.set(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages == false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn SvgElement.create('image', attrs, formatter);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\tlength = segments.length,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (matchShapes && length >= 2 && !item.hasHandles()) {\n\t\t\tif (length > 2) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t}\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar start = segments[0]._point,\n\t\t\t\t\tend = segments[1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: end.x,\n\t\t\t\t\ty2: end.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn SvgElement.create('path', attrs, formatter);\n\t}\n\n\tfunction exportSymbolItem(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tdefinition = item._definition,\n\t\t\tnode = getDefinition(definition, 'symbol'),\n\t\t\tdefinitionItem = definition._item,\n\t\t\tbounds = definitionItem.getBounds();\n\t\tif (!node) {\n\t\t\tnode = SvgElement.create('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tnode.appendChild(exportSVG(definitionItem, options));\n\t\t\tsetDefinition(definition, node, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + node.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = bounds.width;\n\t\tattrs.height = bounds.height;\n\t\tattrs.overflow = 'visible';\n\t\treturn SvgElement.create('use', attrs, formatter);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin(),\n\t\t\t\tdestination = color.getDestination(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = SvgElement.create((radial ? 'radial' : 'linear')\n\t\t\t\t\t+ 'Gradient', attrs, formatter);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha(),\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: offset == null ? i / (l - 1) : offset\n\t\t\t\t};\n\t\t\t\tif (stopColor)\n\t\t\t\t\tattrs['stop-color'] = stopColor.toCSS(true);\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(\n\t\t\t\t\t\tSvgElement.create('stop', attrs, formatter));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = SvgElement.create('text', getTransform(item._matrix, true),\n\t\t\t\tformatter);\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tSymbolItem: exportSymbolItem,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent(),\n\t\t\tstyle = [];\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SvgStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tif (type === 'style') {\n\t\t\t\t\tstyle.push(entry.attribute + ': ' + value);\n\t\t\t\t} else {\n\t\t\t\t\tattrs[entry.attribute] = value == null ? 'none'\n\t\t\t\t\t\t\t: type === 'color' ? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array' ? value.join(',')\n\t\t\t\t\t\t\t: type === 'lookup' ? entry.toSVG[value]\n\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (style.length)\n\t\t\tattrs.style = style.join(';');\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn SvgElement.set(node, attrs, formatter);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-'\n\t\t\t\t+ (item._id || item.__id || (item.__id = UID.get('svg')))];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + typeId;\n\t\tdefinitions.svgs[type + '-' + (item._id || item.__id)] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = SvgElement.create('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(SvgElement.create('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new self.XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar children = this._children,\n\t\t\t\tview = this.getView(),\n\t\t\t\tbounds = Base.pick(options.bounds, 'view'),\n\t\t\t\tmx = options.matrix || bounds === 'view' && view._matrix,\n\t\t\t\tmatrix = mx && Matrix.read([mx]),\n\t\t\t\trect = bounds === 'view'\n\t\t\t\t\t? new Rectangle([0, 0], view.getViewSize())\n\t\t\t\t\t: bounds === 'content'\n\t\t\t\t\t\t? Item._getBounds(children, matrix, { stroke: true })\n\t\t\t\t\t\t\t.rect\n\t\t\t\t\t\t: Rectangle.read([bounds], 0, { readNull: true }),\n\t\t\t\tattrs = {\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: SvgElement.svg,\n\t\t\t\t\t'xmlns:xlink': SvgElement.xlink,\n\t\t\t\t};\n\t\t\tif (rect) {\n\t\t\t\tattrs.width = rect.width;\n\t\t\t\tattrs.height = rect.height;\n\t\t\t\tif (rect.x || rect.y)\n\t\t\t\t\tattrs.viewBox = formatter.rectangle(rect);\n\t\t\t}\n\t\t\tvar node = SvgElement.create('svg', attrs, formatter),\n\t\t\t\tparent = node;\n\t\t\tif (matrix && !matrix.isIdentity()) {\n\t\t\t\tparent = node.appendChild(SvgElement.create('g',\n\t\t\t\t\t\tgetTransform(matrix), formatter));\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tparent.appendChild(exportSVG(children[i], options, true));\n\t\t\t}\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tvar definitions = {},\n\t\trootSize;\n\n\tfunction getValue(node, name, isString, allowNull, allowPercent) {\n\t\tvar value = SvgElement.get(node, name),\n\t\t\tres = value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString ? '' : 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t\treturn /%\\s*$/.test(value)\n\t\t\t? (res / 100) * (allowPercent ? 1\n\t\t\t\t: rootSize[/x|^width/.test(name) ? 'width' : 'height'])\n\t\t\t: res;\n\t}\n\n\tfunction getPoint(node, x, y, allowNull, allowPercent) {\n\t\tx = getValue(node, x || 'x', false, allowNull, allowPercent);\n\t\ty = getValue(node, y || 'y', false, allowNull, allowPercent);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull, allowPercent) {\n\t\tw = getValue(node, w || 'width', false, allowNull, allowPercent);\n\t\th = getValue(node, h || 'height', false, allowNull, allowPercent);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none' ? null\n\t\t\t\t: type === 'number' ? parseFloat(value)\n\t\t\t\t: type === 'array' ?\n\t\t\t\t\tvalue ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t: type === 'color' ? getDefinition(value) || value\n\t\t\t\t: type === 'lookup' ? lookup[value]\n\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\tisDefs = type === 'defs',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip && !isDefs) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportNode(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& !/^defs$/i.test(childNode.nodeName)\n\t\t\t\t\t&& (child = importNode(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof SymbolDefinition))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || isDefs) {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\treturn PathItem.create(node.getAttribute('d'));\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tradial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t\tif (gradient._radial ^ radial) {\n\t\t\t\tgradient = gradient.clone();\n\t\t\t\tgradient._radial = radial;\n\t\t\t}\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, radial);\n\t\t}\n\t\tvar origin, destination, highlight,\n\t\t\tscaleToBounds = getValue(node, 'gradientUnits', true) !==\n\t\t\t\t'userSpaceOnUse';\n\t\tif (radial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy', false, scaleToBounds);\n\t\t\tdestination = origin.add(\n\t\t\t\t\tgetValue(node, 'r', false, false, scaleToBounds), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1', false, scaleToBounds);\n\t\t\tdestination = getPoint(node, 'x2', 'y2', false, scaleToBounds);\n\t\t}\n\t\tvar color = applyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\tcolor._scaleToBounds = scaleToBounds;\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\treturn importNode(child, options, isRoot);\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node);\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\tgetPoint(node).add(size.divide(2)));\n\t\t\t\tthis.translate(center);\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new SymbolDefinition(\n\t\t\t\t\timportGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node);\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof SymbolDefinition\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(\n\t\t\t\t\tgetPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\treturn new Shape.Rectangle(new Rectangle(\n\t\t\t\t\t\tgetPoint(node),\n\t\t\t\t\t\tgetSize(node)\n\t\t\t\t\t), getSize(node, 'rx', 'ry'));\n\t\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(\n\t\t\t\t\tgetPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node).add(\n\t\t\t\t\tgetPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t}\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tif (item.transform) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.append(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',\n\t\t\tcolor = item[key] && item[key]();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SvgStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\tif (item[entry.set]) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color') {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tif (color._scaleToBounds) {\n\t\t\t\t\t\t\tvar bounds = item.getBounds();\n\t\t\t\t\t\t\tcolor.transform(new Matrix()\n\t\t\t\t\t\t\t\t.translate(bounds.getPoint())\n\t\t\t\t\t\t\t\t.scale(bounds.getSize()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tif (item.setOffset) {\n\t\t\t\tvar percent = value.match(/(.*)%$/);\n\t\t\t\titem.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n\t\t\t}\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, null, null, true),\n\t\t\t\tgroup,\n\t\t\t\tmatrix;\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? size.divide(rect.getSize()) : 1,\n\t\t\t\tmatrix = new Matrix().scale(scale)\n\t\t\t\t\t\t.translate(rect.getPoint().negate());\n\t\t\t\tgroup = item;\n\t\t\t} else if (item instanceof SymbolDefinition) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tgroup = item._item;\n\t\t\t}\n\t\t\tif (group)  {\n\t\t\t\tif (getAttribute(node, 'overflow', styles) !== 'visible') {\n\t\t\t\t\tvar clip = new Shape.Rectangle(rect);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t\tif (matrix)\n\t\t\t\t\tgroup.transform(matrix);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value ? undefined\n\t\t\t\t: value === 'none' ? null\n\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tif (node.style) {\n\t\t\tvar parent = node.parentNode,\n\t\t\t\tstyles = {\n\t\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\t\tparent: !isRoot && !/^defs$/i.test(parent.tagName)\n\t\t\t\t\t\t\t&& DomElement.getStyles(parent) || {}\n\t\t\t\t};\n\t\t\tBase.each(attributes, function(apply, name) {\n\t\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\t\titem = value !== undefined\n\t\t\t\t\t\t&& apply(item, value, name, node, styles) || item;\n\t\t\t});\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/),\n\t\t\tname = match && match[1],\n\t\t\tres = name && definitions[window\n\t\t\t\t\t? name.replace(window.location.href.split('#')[0] + '#', '')\n\t\t\t\t\t: name];\n\t\tif (res && res._scaleToBounds) {\n\t\t\tres = res.clone();\n\t\t\tres._scaleToBounds = true;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction importNode(node, options, isRoot) {\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\tisElement = type !== '#document',\n\t\t\tbody = document.body,\n\t\t\tcontainer,\n\t\t\tparent,\n\t\t\tnext;\n\t\tif (isRoot && isElement) {\n\t\t\trootSize = paper.getView().getSize();\n\t\t\trootSize = getSize(node, null, null, true) || rootSize;\n\t\t\tcontainer = SvgElement.create('svg', {\n\t\t\t\tstyle: 'stroke-width: 1px; stroke-miterlimit: 10'\n\t\t\t});\n\t\t\tparent = node.parentNode;\n\t\t\tnext = node.nextSibling;\n\t\t\tcontainer.appendChild(node);\n\t\t\tbody.appendChild(container);\n\t\t}\n\t\tvar settings = paper.settings,\n\t\t\tapplyMatrix = settings.applyMatrix,\n\t\t\tinsertItems = settings.insertItems;\n\t\tsettings.applyMatrix = false;\n\t\tsettings.insertItems = false;\n\t\tvar importer = importers[type],\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.insertItems = insertItems;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (isElement && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport,\n\t\t\t\tdata = isElement && node.getAttribute('data-paper-data');\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (container) {\n\t\t\tbody.removeChild(container);\n\t\t\tif (parent) {\n\t\t\t\tif (next) {\n\t\t\t\t\tparent.insertBefore(node, next);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importSVG(source, options, owner) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\toptions = typeof options === 'function' ? { onLoad: options }\n\t\t\t\t: options || {};\n\t\tvar scope = paper,\n\t\t\titem = null;\n\n\t\tfunction onLoad(svg) {\n\t\t\ttry {\n\t\t\t\tvar node = typeof svg === 'object' ? svg : new self.DOMParser()\n\t\t\t\t\t\t.parseFromString(svg, 'image/svg+xml');\n\t\t\t\tif (!node.nodeName) {\n\t\t\t\t\tnode = null;\n\t\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\t\t}\n\t\t\t\tpaper = scope;\n\t\t\t\titem = importNode(node, options, true);\n\t\t\t\tif (!options || options.insert !== false) {\n\t\t\t\t\towner._insertItem(undefined, item);\n\t\t\t\t}\n\t\t\t\tvar onLoad = options.onLoad;\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad(item, svg);\n\t\t\t} catch (e) {\n\t\t\t\tonError(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction onError(message, status) {\n\t\t\tvar onError = options.onError;\n\t\t\tif (onError) {\n\t\t\t\tonError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\tvar node = document.getElementById(source);\n\t\t\tif (node) {\n\t\t\t\tonLoad(node);\n\t\t\t} else {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: source,\n\t\t\t\t\tasync: true,\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function() {\n\t\t\t\tonLoad(reader.result);\n\t\t\t};\n\t\t\treader.onerror = function() {\n\t\t\t\tonError(reader.error);\n\t\t\t};\n\t\t\treturn reader.readAsText(source);\n\t\t} else {\n\t\t\tonLoad(source);\n\t\t}\n\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = function() {\n\tvar global = this,\n\t\tacorn = global.acorn;\n\tif (!acorn && \"function\" !== 'undefined') {\n\t\ttry { acorn = __webpack_require__(4); } catch(e) {}\n\t}\n\tif (!acorn) {\n\t\tvar exports, module;\n\t\tacorn = exports = module = {};\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports);\n  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.acorn || (root.acorn = {}));\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.0\";\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\treturn parseTopLevel(options.program);\n  };\n\n  var defaultOptions = exports.defaultOptions = {\n\tecmaVersion: 5,\n\tstrictSemicolons: false,\n\tallowTrailingCommas: true,\n\tforbidReserved: false,\n\tallowReturnOutsideFunction: false,\n\tlocations: false,\n\tonComment: null,\n\tranges: false,\n\tprogram: null,\n\tsourceFile: null,\n\tdirectSourceFile: null\n  };\n\n  function setOptions(opts) {\n\toptions = opts || {};\n\tfor (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n\t  options[opt] = defaultOptions[opt];\n\tsourceFile = options.sourceFile || null;\n  }\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n\tfor (var line = 1, cur = 0;;) {\n\t  lineBreak.lastIndex = cur;\n\t  var match = lineBreak.exec(input);\n\t  if (match && match.index < offset) {\n\t\t++line;\n\t\tcur = match.index + match[0].length;\n\t  } else break;\n\t}\n\treturn {line: line, column: offset - cur};\n  };\n\n  exports.tokenize = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\n\tvar t = {};\n\tfunction getToken(forceRegexp) {\n\t  lastEnd = tokEnd;\n\t  readToken(forceRegexp);\n\t  t.start = tokStart; t.end = tokEnd;\n\t  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n\t  t.type = tokType; t.value = tokVal;\n\t  return t;\n\t}\n\tgetToken.jumpTo = function(pos, reAllowed) {\n\t  tokPos = pos;\n\t  if (options.locations) {\n\t\ttokCurLine = 1;\n\t\ttokLineStart = lineBreak.lastIndex = 0;\n\t\tvar match;\n\t\twhile ((match = lineBreak.exec(input)) && match.index < pos) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = match.index + match[0].length;\n\t\t}\n\t  }\n\t  tokRegexpAllowed = reAllowed;\n\t  skipSpace();\n\t};\n\treturn getToken;\n  };\n\n  var tokPos;\n\n  var tokStart, tokEnd;\n\n  var tokStartLoc, tokEndLoc;\n\n  var tokType, tokVal;\n\n  var tokRegexpAllowed;\n\n  var tokCurLine, tokLineStart;\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  var inFunction, labels, strict;\n\n  function raise(pos, message) {\n\tvar loc = getLineInfo(input, pos);\n\tmessage += \" (\" + loc.line + \":\" + loc.column + \")\";\n\tvar err = new SyntaxError(message);\n\terr.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n\tthrow err;\n  }\n\n  var empty = [];\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n\t\t\t\t\t  \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n\t\t\t\t\t  \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n\t\t\t\t\t  \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n\t\t\t\t\t  \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n\t\t\t\t\t  \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n\t\t\t\t\t  \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n\t\t\t\t\t  \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n\t\t\t\t\t  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n\t\t\t\t\t  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n\t\t\t\t\t  num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  function makePredicate(words) {\n\twords = words.split(\" \");\n\tvar f = \"\", cats = [];\n\tout: for (var i = 0; i < words.length; ++i) {\n\t  for (var j = 0; j < cats.length; ++j)\n\t\tif (cats[j][0].length == words[i].length) {\n\t\t  cats[j].push(words[i]);\n\t\t  continue out;\n\t\t}\n\t  cats.push([words[i]]);\n\t}\n\tfunction compareTo(arr) {\n\t  if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n\t  f += \"switch(str){\";\n\t  for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n\t  f += \"return true}return false;\";\n\t}\n\n\tif (cats.length > 3) {\n\t  cats.sort(function(a, b) {return b.length - a.length;});\n\t  f += \"switch(str.length){\";\n\t  for (var i = 0; i < cats.length; ++i) {\n\t\tvar cat = cats[i];\n\t\tf += \"case \" + cat[0].length + \":\";\n\t\tcompareTo(cat);\n\t  }\n\t  f += \"}\";\n\n\t} else {\n\t  compareTo(words);\n\t}\n\treturn new Function(\"str\", f);\n  }\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n\tif (code < 65) return code === 36;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n\tif (code < 48) return code === 36;\n\tif (code < 58) return true;\n\tif (code < 65) return false;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  function line_loc_t() {\n\tthis.line = tokCurLine;\n\tthis.column = tokPos - tokLineStart;\n  }\n\n  function initTokenState() {\n\ttokCurLine = 1;\n\ttokPos = tokLineStart = 0;\n\ttokRegexpAllowed = true;\n\tskipSpace();\n  }\n\n  function finishToken(type, val) {\n\ttokEnd = tokPos;\n\tif (options.locations) tokEndLoc = new line_loc_t;\n\ttokType = type;\n\tskipSpace();\n\ttokVal = val;\n\ttokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n\tif (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n\ttokPos = end + 2;\n\tif (options.locations) {\n\t  lineBreak.lastIndex = start;\n\t  var match;\n\t  while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n\t\t++tokCurLine;\n\t\ttokLineStart = match.index + match[0].length;\n\t  }\n\t}\n\tif (options.onComment)\n\t  options.onComment(true, input.slice(start + 2, end), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n\tvar start = tokPos;\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar ch = input.charCodeAt(tokPos+=2);\n\twhile (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n\t  ++tokPos;\n\t  ch = input.charCodeAt(tokPos);\n\t}\n\tif (options.onComment)\n\t  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipSpace() {\n\twhile (tokPos < inputLen) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === 32) {\n\t\t++tokPos;\n\t  } else if (ch === 13) {\n\t\t++tokPos;\n\t\tvar next = input.charCodeAt(tokPos);\n\t\tif (next === 10) {\n\t\t  ++tokPos;\n\t\t}\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch === 10 || ch === 8232 || ch === 8233) {\n\t\t++tokPos;\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch > 8 && ch < 14) {\n\t\t++tokPos;\n\t  } else if (ch === 47) {\n\t\tvar next = input.charCodeAt(tokPos + 1);\n\t\tif (next === 42) {\n\t\t  skipBlockComment();\n\t\t} else if (next === 47) {\n\t\t  skipLineComment();\n\t\t} else break;\n\t  } else if (ch === 160) {\n\t\t++tokPos;\n\t  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t\t++tokPos;\n\t  } else {\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  function readToken_dot() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next >= 48 && next <= 57) return readNumber(true);\n\t++tokPos;\n\treturn finishToken(_dot);\n  }\n\n  function readToken_slash() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (tokRegexpAllowed) {++tokPos; return readRegexp();}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) {\n\t  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n\t\t  newline.test(input.slice(lastEnd, tokPos))) {\n\t\ttokPos += 3;\n\t\tskipLineComment();\n\t\tskipSpace();\n\t\treturn readToken();\n\t  }\n\t  return finishOp(_incDec, 2);\n\t}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tvar size = 1;\n\tif (next === code) {\n\t  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n\t  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n\t  return finishOp(_bitShift, size);\n\t}\n\tif (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n\t\tinput.charCodeAt(tokPos + 3) == 45) {\n\t  tokPos += 4;\n\t  skipLineComment();\n\t  skipSpace();\n\t  return readToken();\n\t}\n\tif (next === 61)\n\t  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n\treturn finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n\treturn finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n\tswitch(code) {\n\tcase 46:\n\t  return readToken_dot();\n\n\tcase 40: ++tokPos; return finishToken(_parenL);\n\tcase 41: ++tokPos; return finishToken(_parenR);\n\tcase 59: ++tokPos; return finishToken(_semi);\n\tcase 44: ++tokPos; return finishToken(_comma);\n\tcase 91: ++tokPos; return finishToken(_bracketL);\n\tcase 93: ++tokPos; return finishToken(_bracketR);\n\tcase 123: ++tokPos; return finishToken(_braceL);\n\tcase 125: ++tokPos; return finishToken(_braceR);\n\tcase 58: ++tokPos; return finishToken(_colon);\n\tcase 63: ++tokPos; return finishToken(_question);\n\n\tcase 48:\n\t  var next = input.charCodeAt(tokPos + 1);\n\t  if (next === 120 || next === 88) return readHexNumber();\n\tcase 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:\n\t  return readNumber(false);\n\n\tcase 34: case 39:\n\t  return readString(code);\n\n\tcase 47:\n\t  return readToken_slash(code);\n\n\tcase 37: case 42:\n\t  return readToken_mult_modulo();\n\n\tcase 124: case 38:\n\t  return readToken_pipe_amp(code);\n\n\tcase 94:\n\t  return readToken_caret();\n\n\tcase 43: case 45:\n\t  return readToken_plus_min(code);\n\n\tcase 60: case 62:\n\t  return readToken_lt_gt(code);\n\n\tcase 61: case 33:\n\t  return readToken_eq_excl(code);\n\n\tcase 126:\n\t  return finishOp(_prefix, 1);\n\t}\n\n\treturn false;\n  }\n\n  function readToken(forceRegexp) {\n\tif (!forceRegexp) tokStart = tokPos;\n\telse tokPos = tokStart + 1;\n\tif (options.locations) tokStartLoc = new line_loc_t;\n\tif (forceRegexp) return readRegexp();\n\tif (tokPos >= inputLen) return finishToken(_eof);\n\n\tvar code = input.charCodeAt(tokPos);\n\tif (isIdentifierStart(code) || code === 92 ) return readWord();\n\n\tvar tok = getTokenFromCode(code);\n\n\tif (tok === false) {\n\t  var ch = String.fromCharCode(code);\n\t  if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n\t  raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n\t}\n\treturn tok;\n  }\n\n  function finishOp(type, size) {\n\tvar str = input.slice(tokPos, tokPos + size);\n\ttokPos += size;\n\tfinishToken(type, str);\n  }\n\n  function readRegexp() {\n\tvar content = \"\", escaped, inClass, start = tokPos;\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n\t  var ch = input.charAt(tokPos);\n\t  if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n\t  if (!escaped) {\n\t\tif (ch === \"[\") inClass = true;\n\t\telse if (ch === \"]\" && inClass) inClass = false;\n\t\telse if (ch === \"/\" && !inClass) break;\n\t\tescaped = ch === \"\\\\\";\n\t  } else escaped = false;\n\t  ++tokPos;\n\t}\n\tvar content = input.slice(start, tokPos);\n\t++tokPos;\n\tvar mods = readWord1();\n\tif (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n\ttry {\n\t  var value = new RegExp(content, mods);\n\t} catch (e) {\n\t  if (e instanceof SyntaxError) raise(start, e.message);\n\t  raise(e);\n\t}\n\treturn finishToken(_regexp, value);\n  }\n\n  function readInt(radix, len) {\n\tvar start = tokPos, total = 0;\n\tfor (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t  var code = input.charCodeAt(tokPos), val;\n\t  if (code >= 97) val = code - 97 + 10;\n\t  else if (code >= 65) val = code - 65 + 10;\n\t  else if (code >= 48 && code <= 57) val = code - 48;\n\t  else val = Infinity;\n\t  if (val >= radix) break;\n\t  ++tokPos;\n\t  total = total * radix + val;\n\t}\n\tif (tokPos === start || len != null && tokPos - start !== len) return null;\n\n\treturn total;\n  }\n\n  function readHexNumber() {\n\ttokPos += 2;\n\tvar val = readInt(16);\n\tif (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\treturn finishToken(_num, val);\n  }\n\n  function readNumber(startsWithDot) {\n\tvar start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n\tif (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n\tif (input.charCodeAt(tokPos) === 46) {\n\t  ++tokPos;\n\t  readInt(10);\n\t  isFloat = true;\n\t}\n\tvar next = input.charCodeAt(tokPos);\n\tif (next === 69 || next === 101) {\n\t  next = input.charCodeAt(++tokPos);\n\t  if (next === 43 || next === 45) ++tokPos;\n\t  if (readInt(10) === null) raise(start, \"Invalid number\");\n\t  isFloat = true;\n\t}\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n\tvar str = input.slice(start, tokPos), val;\n\tif (isFloat) val = parseFloat(str);\n\telse if (!octal || str.length === 1) val = parseInt(str, 10);\n\telse if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n\telse val = parseInt(str, 8);\n\treturn finishToken(_num, val);\n  }\n\n  function readString(quote) {\n\ttokPos++;\n\tvar out = \"\";\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === quote) {\n\t\t++tokPos;\n\t\treturn finishToken(_string, out);\n\t  }\n\t  if (ch === 92) {\n\t\tch = input.charCodeAt(++tokPos);\n\t\tvar octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n\t\tif (octal) octal = octal[0];\n\t\twhile (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n\t\tif (octal === \"0\") octal = null;\n\t\t++tokPos;\n\t\tif (octal) {\n\t\t  if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n\t\t  out += String.fromCharCode(parseInt(octal, 8));\n\t\t  tokPos += octal.length - 1;\n\t\t} else {\n\t\t  switch (ch) {\n\t\t  case 110: out += \"\\n\"; break;\n\t\t  case 114: out += \"\\r\"; break;\n\t\t  case 120: out += String.fromCharCode(readHexChar(2)); break;\n\t\t  case 117: out += String.fromCharCode(readHexChar(4)); break;\n\t\t  case 85: out += String.fromCharCode(readHexChar(8)); break;\n\t\t  case 116: out += \"\\t\"; break;\n\t\t  case 98: out += \"\\b\"; break;\n\t\t  case 118: out += \"\\u000b\"; break;\n\t\t  case 102: out += \"\\f\"; break;\n\t\t  case 48: out += \"\\0\"; break;\n\t\t  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;\n\t\t  case 10:\n\t\t\tif (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n\t\t\tbreak;\n\t\t  default: out += String.fromCharCode(ch); break;\n\t\t  }\n\t\t}\n\t  } else {\n\t\tif (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n\t\tout += String.fromCharCode(ch);\n\t\t++tokPos;\n\t  }\n\t}\n  }\n\n  function readHexChar(len) {\n\tvar n = readInt(16, len);\n\tif (n === null) raise(tokStart, \"Bad character escape sequence\");\n\treturn n;\n  }\n\n  var containsEsc;\n\n  function readWord1() {\n\tcontainsEsc = false;\n\tvar word, first = true, start = tokPos;\n\tfor (;;) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (isIdentifierChar(ch)) {\n\t\tif (containsEsc) word += input.charAt(tokPos);\n\t\t++tokPos;\n\t  } else if (ch === 92) {\n\t\tif (!containsEsc) word = input.slice(start, tokPos);\n\t\tcontainsEsc = true;\n\t\tif (input.charCodeAt(++tokPos) != 117)\n\t\t  raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n\t\t++tokPos;\n\t\tvar esc = readHexChar(4);\n\t\tvar escStr = String.fromCharCode(esc);\n\t\tif (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n\t\tif (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n\t\t  raise(tokPos - 4, \"Invalid Unicode escape\");\n\t\tword += escStr;\n\t  } else {\n\t\tbreak;\n\t  }\n\t  first = false;\n\t}\n\treturn containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  function readWord() {\n\tvar word = readWord1();\n\tvar type = _name;\n\tif (!containsEsc && isKeyword(word))\n\t  type = keywordTypes[word];\n\treturn finishToken(type, word);\n  }\n\n  function next() {\n\tlastStart = tokStart;\n\tlastEnd = tokEnd;\n\tlastEndLoc = tokEndLoc;\n\treadToken();\n  }\n\n  function setStrict(strct) {\n\tstrict = strct;\n\ttokPos = tokStart;\n\tif (options.locations) {\n\t  while (tokPos < tokLineStart) {\n\t\ttokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n\t\t--tokCurLine;\n\t  }\n\t}\n\tskipSpace();\n\treadToken();\n  }\n\n  function node_t() {\n\tthis.type = null;\n\tthis.start = tokStart;\n\tthis.end = null;\n  }\n\n  function node_loc_t() {\n\tthis.start = tokStartLoc;\n\tthis.end = null;\n\tif (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n\tvar node = new node_t();\n\tif (options.locations)\n\t  node.loc = new node_loc_t();\n\tif (options.directSourceFile)\n\t  node.sourceFile = options.directSourceFile;\n\tif (options.ranges)\n\t  node.range = [tokStart, 0];\n\treturn node;\n  }\n\n  function startNodeFrom(other) {\n\tvar node = new node_t();\n\tnode.start = other.start;\n\tif (options.locations) {\n\t  node.loc = new node_loc_t();\n\t  node.loc.start = other.loc.start;\n\t}\n\tif (options.ranges)\n\t  node.range = [other.range[0], 0];\n\n\treturn node;\n  }\n\n  function finishNode(node, type) {\n\tnode.type = type;\n\tnode.end = lastEnd;\n\tif (options.locations)\n\t  node.loc.end = lastEndLoc;\n\tif (options.ranges)\n\t  node.range[1] = lastEnd;\n\treturn node;\n  }\n\n  function isUseStrict(stmt) {\n\treturn options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n\t  stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  function eat(type) {\n\tif (tokType === type) {\n\t  next();\n\t  return true;\n\t}\n  }\n\n  function canInsertSemicolon() {\n\treturn !options.strictSemicolons &&\n\t  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  function semicolon() {\n\tif (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  function expect(type) {\n\tif (tokType === type) next();\n\telse unexpected();\n  }\n\n  function unexpected() {\n\traise(tokStart, \"Unexpected token\");\n  }\n\n  function checkLVal(expr) {\n\tif (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n\t  raise(expr.start, \"Assigning to rvalue\");\n\tif (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n\t  raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  function parseTopLevel(program) {\n\tlastStart = lastEnd = tokPos;\n\tif (options.locations) lastEndLoc = new line_loc_t;\n\tinFunction = strict = null;\n\tlabels = [];\n\treadToken();\n\n\tvar node = program || startNode(), first = true;\n\tif (!program) node.body = [];\n\twhile (tokType !== _eof) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && isUseStrict(stmt)) setStrict(true);\n\t  first = false;\n\t}\n\treturn finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  function parseStatement() {\n\tif (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n\t  readToken(true);\n\n\tvar starttype = tokType, node = startNode();\n\n\tswitch (starttype) {\n\tcase _break: case _continue:\n\t  next();\n\t  var isBreak = starttype === _break;\n\t  if (eat(_semi) || canInsertSemicolon()) node.label = null;\n\t  else if (tokType !== _name) unexpected();\n\t  else {\n\t\tnode.label = parseIdent();\n\t\tsemicolon();\n\t  }\n\n\t  for (var i = 0; i < labels.length; ++i) {\n\t\tvar lab = labels[i];\n\t\tif (node.label == null || lab.name === node.label.name) {\n\t\t  if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n\t\t  if (node.label && isBreak) break;\n\t\t}\n\t  }\n\t  if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n\t  return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n\tcase _debugger:\n\t  next();\n\t  semicolon();\n\t  return finishNode(node, \"DebuggerStatement\");\n\n\tcase _do:\n\t  next();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  expect(_while);\n\t  node.test = parseParenExpression();\n\t  semicolon();\n\t  return finishNode(node, \"DoWhileStatement\");\n\n\tcase _for:\n\t  next();\n\t  labels.push(loopLabel);\n\t  expect(_parenL);\n\t  if (tokType === _semi) return parseFor(node, null);\n\t  if (tokType === _var) {\n\t\tvar init = startNode();\n\t\tnext();\n\t\tparseVar(init, true);\n\t\tfinishNode(init, \"VariableDeclaration\");\n\t\tif (init.declarations.length === 1 && eat(_in))\n\t\t  return parseForIn(node, init);\n\t\treturn parseFor(node, init);\n\t  }\n\t  var init = parseExpression(false, true);\n\t  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n\t  return parseFor(node, init);\n\n\tcase _function:\n\t  next();\n\t  return parseFunction(node, true);\n\n\tcase _if:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  node.consequent = parseStatement();\n\t  node.alternate = eat(_else) ? parseStatement() : null;\n\t  return finishNode(node, \"IfStatement\");\n\n\tcase _return:\n\t  if (!inFunction && !options.allowReturnOutsideFunction)\n\t\traise(tokStart, \"'return' outside of function\");\n\t  next();\n\n\t  if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n\t  else { node.argument = parseExpression(); semicolon(); }\n\t  return finishNode(node, \"ReturnStatement\");\n\n\tcase _switch:\n\t  next();\n\t  node.discriminant = parseParenExpression();\n\t  node.cases = [];\n\t  expect(_braceL);\n\t  labels.push(switchLabel);\n\n\t  for (var cur, sawDefault; tokType != _braceR;) {\n\t\tif (tokType === _case || tokType === _default) {\n\t\t  var isCase = tokType === _case;\n\t\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t\t  node.cases.push(cur = startNode());\n\t\t  cur.consequent = [];\n\t\t  next();\n\t\t  if (isCase) cur.test = parseExpression();\n\t\t  else {\n\t\t\tif (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n\t\t\tcur.test = null;\n\t\t  }\n\t\t  expect(_colon);\n\t\t} else {\n\t\t  if (!cur) unexpected();\n\t\t  cur.consequent.push(parseStatement());\n\t\t}\n\t  }\n\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t  next();\n\t  labels.pop();\n\t  return finishNode(node, \"SwitchStatement\");\n\n\tcase _throw:\n\t  next();\n\t  if (newline.test(input.slice(lastEnd, tokStart)))\n\t\traise(lastEnd, \"Illegal newline after throw\");\n\t  node.argument = parseExpression();\n\t  semicolon();\n\t  return finishNode(node, \"ThrowStatement\");\n\n\tcase _try:\n\t  next();\n\t  node.block = parseBlock();\n\t  node.handler = null;\n\t  if (tokType === _catch) {\n\t\tvar clause = startNode();\n\t\tnext();\n\t\texpect(_parenL);\n\t\tclause.param = parseIdent();\n\t\tif (strict && isStrictBadIdWord(clause.param.name))\n\t\t  raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n\t\texpect(_parenR);\n\t\tclause.guard = null;\n\t\tclause.body = parseBlock();\n\t\tnode.handler = finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.guardedHandlers = empty;\n\t  node.finalizer = eat(_finally) ? parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t\traise(node.start, \"Missing catch or finally clause\");\n\t  return finishNode(node, \"TryStatement\");\n\n\tcase _var:\n\t  next();\n\t  parseVar(node);\n\t  semicolon();\n\t  return finishNode(node, \"VariableDeclaration\");\n\n\tcase _while:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  return finishNode(node, \"WhileStatement\");\n\n\tcase _with:\n\t  if (strict) raise(tokStart, \"'with' in strict mode\");\n\t  next();\n\t  node.object = parseParenExpression();\n\t  node.body = parseStatement();\n\t  return finishNode(node, \"WithStatement\");\n\n\tcase _braceL:\n\t  return parseBlock();\n\n\tcase _semi:\n\t  next();\n\t  return finishNode(node, \"EmptyStatement\");\n\n\tdefault:\n\t  var maybeName = tokVal, expr = parseExpression();\n\t  if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n\t\tfor (var i = 0; i < labels.length; ++i)\n\t\t  if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t\tvar kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n\t\tlabels.push({name: maybeName, kind: kind});\n\t\tnode.body = parseStatement();\n\t\tlabels.pop();\n\t\tnode.label = expr;\n\t\treturn finishNode(node, \"LabeledStatement\");\n\t  } else {\n\t\tnode.expression = expr;\n\t\tsemicolon();\n\t\treturn finishNode(node, \"ExpressionStatement\");\n\t  }\n\t}\n  }\n\n  function parseParenExpression() {\n\texpect(_parenL);\n\tvar val = parseExpression();\n\texpect(_parenR);\n\treturn val;\n  }\n\n  function parseBlock(allowStrict) {\n\tvar node = startNode(), first = true, strict = false, oldStrict;\n\tnode.body = [];\n\texpect(_braceL);\n\twhile (!eat(_braceR)) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && allowStrict && isUseStrict(stmt)) {\n\t\toldStrict = strict;\n\t\tsetStrict(strict = true);\n\t  }\n\t  first = false;\n\t}\n\tif (strict && !oldStrict) setStrict(false);\n\treturn finishNode(node, \"BlockStatement\");\n  }\n\n  function parseFor(node, init) {\n\tnode.init = init;\n\texpect(_semi);\n\tnode.test = tokType === _semi ? null : parseExpression();\n\texpect(_semi);\n\tnode.update = tokType === _parenR ? null : parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForStatement\");\n  }\n\n  function parseForIn(node, init) {\n\tnode.left = init;\n\tnode.right = parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForInStatement\");\n  }\n\n  function parseVar(node, noIn) {\n\tnode.declarations = [];\n\tnode.kind = \"var\";\n\tfor (;;) {\n\t  var decl = startNode();\n\t  decl.id = parseIdent();\n\t  if (strict && isStrictBadIdWord(decl.id.name))\n\t\traise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n\t  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n\t  node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n\t  if (!eat(_comma)) break;\n\t}\n\treturn node;\n  }\n\n  function parseExpression(noComma, noIn) {\n\tvar expr = parseMaybeAssign(noIn);\n\tif (!noComma && tokType === _comma) {\n\t  var node = startNodeFrom(expr);\n\t  node.expressions = [expr];\n\t  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n\t  return finishNode(node, \"SequenceExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseMaybeAssign(noIn) {\n\tvar left = parseMaybeConditional(noIn);\n\tif (tokType.isAssign) {\n\t  var node = startNodeFrom(left);\n\t  node.operator = tokVal;\n\t  node.left = left;\n\t  next();\n\t  node.right = parseMaybeAssign(noIn);\n\t  checkLVal(left);\n\t  return finishNode(node, \"AssignmentExpression\");\n\t}\n\treturn left;\n  }\n\n  function parseMaybeConditional(noIn) {\n\tvar expr = parseExprOps(noIn);\n\tif (eat(_question)) {\n\t  var node = startNodeFrom(expr);\n\t  node.test = expr;\n\t  node.consequent = parseExpression(true);\n\t  expect(_colon);\n\t  node.alternate = parseExpression(true, noIn);\n\t  return finishNode(node, \"ConditionalExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprOps(noIn) {\n\treturn parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  function parseExprOp(left, minPrec, noIn) {\n\tvar prec = tokType.binop;\n\tif (prec != null && (!noIn || tokType !== _in)) {\n\t  if (prec > minPrec) {\n\t\tvar node = startNodeFrom(left);\n\t\tnode.left = left;\n\t\tnode.operator = tokVal;\n\t\tvar op = tokType;\n\t\tnext();\n\t\tnode.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n\t\tvar exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n\t\treturn parseExprOp(exprNode, minPrec, noIn);\n\t  }\n\t}\n\treturn left;\n  }\n\n  function parseMaybeUnary() {\n\tif (tokType.prefix) {\n\t  var node = startNode(), update = tokType.isUpdate;\n\t  node.operator = tokVal;\n\t  node.prefix = true;\n\t  tokRegexpAllowed = true;\n\t  next();\n\t  node.argument = parseMaybeUnary();\n\t  if (update) checkLVal(node.argument);\n\t  else if (strict && node.operator === \"delete\" &&\n\t\t\t   node.argument.type === \"Identifier\")\n\t\traise(node.start, \"Deleting local variable in strict mode\");\n\t  return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t}\n\tvar expr = parseExprSubscripts();\n\twhile (tokType.postfix && !canInsertSemicolon()) {\n\t  var node = startNodeFrom(expr);\n\t  node.operator = tokVal;\n\t  node.prefix = false;\n\t  node.argument = expr;\n\t  checkLVal(expr);\n\t  next();\n\t  expr = finishNode(node, \"UpdateExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprSubscripts() {\n\treturn parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n\tif (eat(_dot)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseIdent(true);\n\t  node.computed = false;\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (eat(_bracketL)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseExpression();\n\t  node.computed = true;\n\t  expect(_bracketR);\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (!noCalls && eat(_parenL)) {\n\t  var node = startNodeFrom(base);\n\t  node.callee = base;\n\t  node.arguments = parseExprList(_parenR, false);\n\t  return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n\t} else return base;\n  }\n\n  function parseExprAtom() {\n\tswitch (tokType) {\n\tcase _this:\n\t  var node = startNode();\n\t  next();\n\t  return finishNode(node, \"ThisExpression\");\n\tcase _name:\n\t  return parseIdent();\n\tcase _num: case _string: case _regexp:\n\t  var node = startNode();\n\t  node.value = tokVal;\n\t  node.raw = input.slice(tokStart, tokEnd);\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _null: case _true: case _false:\n\t  var node = startNode();\n\t  node.value = tokType.atomValue;\n\t  node.raw = tokType.keyword;\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _parenL:\n\t  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n\t  next();\n\t  var val = parseExpression();\n\t  val.start = tokStart1;\n\t  val.end = tokEnd;\n\t  if (options.locations) {\n\t\tval.loc.start = tokStartLoc1;\n\t\tval.loc.end = tokEndLoc;\n\t  }\n\t  if (options.ranges)\n\t\tval.range = [tokStart1, tokEnd];\n\t  expect(_parenR);\n\t  return val;\n\n\tcase _bracketL:\n\t  var node = startNode();\n\t  next();\n\t  node.elements = parseExprList(_bracketR, true, true);\n\t  return finishNode(node, \"ArrayExpression\");\n\n\tcase _braceL:\n\t  return parseObj();\n\n\tcase _function:\n\t  var node = startNode();\n\t  next();\n\t  return parseFunction(node, false);\n\n\tcase _new:\n\t  return parseNew();\n\n\tdefault:\n\t  unexpected();\n\t}\n  }\n\n  function parseNew() {\n\tvar node = startNode();\n\tnext();\n\tnode.callee = parseSubscripts(parseExprAtom(), true);\n\tif (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n\telse node.arguments = empty;\n\treturn finishNode(node, \"NewExpression\");\n  }\n\n  function parseObj() {\n\tvar node = startNode(), first = true, sawGetSet = false;\n\tnode.properties = [];\n\tnext();\n\twhile (!eat(_braceR)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (options.allowTrailingCommas && eat(_braceR)) break;\n\t  } else first = false;\n\n\t  var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n\t  if (eat(_colon)) {\n\t\tprop.value = parseExpression(true);\n\t\tkind = prop.kind = \"init\";\n\t  } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n\t\t\t\t (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n\t\tisGetSet = sawGetSet = true;\n\t\tkind = prop.kind = prop.key.name;\n\t\tprop.key = parsePropertyName();\n\t\tif (tokType !== _parenL) unexpected();\n\t\tprop.value = parseFunction(startNode(), false);\n\t  } else unexpected();\n\n\t  if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n\t\tfor (var i = 0; i < node.properties.length; ++i) {\n\t\t  var other = node.properties[i];\n\t\t  if (other.key.name === prop.key.name) {\n\t\t\tvar conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n\t\t\t  kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n\t\t\tif (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n\t\t\tif (conflict) raise(prop.key.start, \"Redefinition of property\");\n\t\t  }\n\t\t}\n\t  }\n\t  node.properties.push(prop);\n\t}\n\treturn finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n\tif (tokType === _num || tokType === _string) return parseExprAtom();\n\treturn parseIdent(true);\n  }\n\n  function parseFunction(node, isStatement) {\n\tif (tokType === _name) node.id = parseIdent();\n\telse if (isStatement) unexpected();\n\telse node.id = null;\n\tnode.params = [];\n\tvar first = true;\n\texpect(_parenL);\n\twhile (!eat(_parenR)) {\n\t  if (!first) expect(_comma); else first = false;\n\t  node.params.push(parseIdent());\n\t}\n\n\tvar oldInFunc = inFunction, oldLabels = labels;\n\tinFunction = true; labels = [];\n\tnode.body = parseBlock(true);\n\tinFunction = oldInFunc; labels = oldLabels;\n\n\tif (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n\t  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n\t\tvar id = i < 0 ? node.id : node.params[i];\n\t\tif (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n\t\t  raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n\t\tif (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n\t\t  raise(id.start, \"Argument name clash in strict mode\");\n\t  }\n\t}\n\n\treturn finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n\tvar elts = [], first = true;\n\twhile (!eat(close)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n\t  } else first = false;\n\n\t  if (allowEmpty && tokType === _comma) elts.push(null);\n\t  else elts.push(parseExpression(true));\n\t}\n\treturn elts;\n  }\n\n  function parseIdent(liberal) {\n\tvar node = startNode();\n\tif (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n\tif (tokType === _name) {\n\t  if (!liberal &&\n\t\t  (options.forbidReserved &&\n\t\t   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||\n\t\t   strict && isStrictReservedWord(tokVal)) &&\n\t\t  input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n\t\traise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n\t  node.name = tokVal;\n\t} else if (liberal && tokType.keyword) {\n\t  node.name = tokType.keyword;\n\t} else {\n\t  unexpected();\n\t}\n\ttokRegexpAllowed = false;\n\tnext();\n\treturn finishNode(node, \"Identifier\");\n  }\n\n});\n\n\t\tif (!acorn.version)\n\t\t\tacorn = null;\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn (global.acorn || acorn).parse(code, options);\n\t}\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': '__equals',\n\t\t'!=': '__equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': '__self'\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{\n\t\t\t__self: function() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction compile(code, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction walkAST(node, parent) {\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tfor (var key in node) {\n\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar value = node[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\twalkAST(value, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\t\texp = left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')';\n\t\t\t\t\t\t\treplaceCode(node, /^\\(.*\\)$/.test(getCode(node))\n\t\t\t\t\t\t\t\t\t? '(' + exp + ')' : exp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction encodeVLQ(value) {\n\t\t\tvar res = '',\n\t\t\t\tbase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\tvalue = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n\t\t\twhile (value || !res) {\n\t\t\t\tvar next = value & (32 - 1);\n\t\t\t\tvalue >>= 5;\n\t\t\t\tif (value)\n\t\t\t\t\tnext |= 32;\n\t\t\t\tres += base64[next];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar url = options.url || '',\n\t\t\tagent = paper.agent,\n\t\t\tversion = agent.versionNumber,\n\t\t\toffsetCode = false,\n\t\t\tsourceMaps = options.sourceMaps,\n\t\t\tsource = options.source || code,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg,\n\t\t\toffset = options.offset || 0,\n\t\t\tmap;\n\t\tif (sourceMaps && (agent.chrome && version >= 30\n\t\t\t\t|| agent.webkit && version >= 537.76\n\t\t\t\t|| agent.firefox && version >= 23\n\t\t\t\t|| agent.node)) {\n\t\t\tif (agent.node) {\n\t\t\t\toffset -= 2;\n\t\t\t} else if (window && url && !window.location.href.indexOf(url)) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\toffsetCode = offset > 0 && !(\n\t\t\t\t\tagent.chrome && version >= 36 ||\n\t\t\t\t\tagent.safari && version >= 600 ||\n\t\t\t\t\tagent.firefox && version >= 40 ||\n\t\t\t\t\tagent.node);\n\t\t\tvar mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1\n\t\t\t\t\t+ (offsetCode ? offset : 0);\n\t\t\tmap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url],\n\t\t\t\tsourcesContent: [source]\n\t\t\t};\n\t\t}\n\t\twalkAST(parse(code, { ranges: true, preserveParens: true }));\n\t\tif (map) {\n\t\t\tif (offsetCode) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code;\n\t\t\t}\n\t\t\tif (/^(inline|both)$/.test(sourceMaps)) {\n\t\t\t\tcode += \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ self.btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(map))));\n\t\t\t}\n\t\t\tcode += \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn {\n\t\t\turl: url,\n\t\t\tsource: source,\n\t\t\tcode: code,\n\t\t\tmap: map\n\t\t};\n\t}\n\n\tfunction execute(code, scope, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/\n\t\t\t\t\t.test(code) && !/\\bnew\\s+Tool\\b/.test(code)\n\t\t\t\t\t\t? new Tool() : null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc,\n\t\t\tcompiled = typeof code === 'object' ? code : compile(code, options);\n\t\tcode = compiled.code;\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\thandlers = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t}\n\t\t}, []).join(', ');\n\t\tif (handlers)\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\tvar agent = paper.agent;\n\t\tif (document && (agent.chrome\n\t\t\t\t|| agent.firefox && agent.versionNumber < 40)) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (agent.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = paper._execute;\n\t\t\tdelete paper._execute;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar res = func.apply(scope, args) || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = res[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (res.onResize)\n\t\t\t\tview.setOnResize(res.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (res.onFrame)\n\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\tview.requestUpdate();\n\t\t}\n\t\treturn compiled;\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: src,\n\t\t\t\t\tasync: async,\n\t\t\t\t\tmimeType: 'text/plain',\n\t\t\t\t\tonLoad: function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document && document.getElementsByTagName('script'),\n\t\t\t\tloadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (window) {\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse\n\t};\n\n}.call(this);\n\npaper = new (PaperScope.inject(Base.exports, {\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key,\n\tDomEvent: DomEvent,\n\tDomElement: DomElement,\n\tdocument: document,\n\twindow: window,\n\tSymbol: SymbolDefinition,\n\tPlacedSymbol: SymbolItem\n}))();\n\nif (paper.agent.node) {\n\t__webpack_require__(24)(paper);\n}\n\nif (true) {\n\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else if (typeof module === 'object' && module) {\n\tmodule.exports = paper;\n}\n\nreturn paper;\n}.call(this, typeof self === 'object' ? self : null);\n\n\n/***/ }),\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n/* 26 */,\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n\n/***/ })\n],[27]);\n\n\n// WEBPACK FOOTER //\n// js/app.patterns.js","import { domReady } from './utilities/helpers';\nimport { confetti, background } from './modules/patterns';\n\nconst app = {\n\n  init() {\n    confetti('#pattern-cover');\n    background('#pattern-reference', 'cyan');\n    background('#pattern-availability', 'yellow');\n    background('#pattern-resume', 'purple');\n  }\n\n};\n\ndomReady(app.init);\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.patterns.js","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36\n  if (code < 58) return true\n  if (code < 65) return false\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label\n  this.keyword = conf.keyword\n  this.beforeExpr = !!conf.beforeExpr\n  this.startsExpr = !!conf.startsExpr\n  this.isLoop = !!conf.isLoop\n  this.isAssign = !!conf.isAssign\n  this.prefix = !!conf.prefix\n  this.postfix = !!conf.postfix\n  this.binop = conf.binop || null\n  this.updateContext = null\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n// Map keyword names to token types.\n\nvar keywordTypes = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name\n  return keywordTypes[name] = new TokenType(name, options)\n}\n\nvar tt = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\nvar lineBreakG = new RegExp(lineBreak.source, \"g\")\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); })\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line\n  this.column = col\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start\n  this.end = end\n  if (p.sourceFile !== null) this.source = p.sourceFile\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    var match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {}\n\n  for (var opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (options.ecmaVersion >= 2015)\n    options.ecmaVersion -= 2009\n\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken\n    options.onToken = function (token) { return tokens.push(token); }\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n// Registered plugins\nvar plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options)\n  this.sourceFile = options.sourceFile\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n  var reserved = \"\"\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      if (reserved = reservedWords[v]) break\n    if (options.sourceType == \"module\") reserved += \" await\"\n  }\n  this.reservedWords = keywordRegexp(reserved)\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n  this.reservedWordsStrict = keywordRegexp(reservedStrict)\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n  this.input = String(input)\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false\n\n  // Load plugins\n  this.loadPlugins(options.plugins)\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n  } else {\n    this.pos = this.lineStart = 0\n    this.curLine = 1\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = tt.eof\n  // For tokens that include more information than their type, the value\n  this.value = null\n  // Its start and end offset\n  this.start = this.end = this.pos\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition()\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null\n  this.lastTokStart = this.lastTokEnd = this.pos\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext()\n  this.exprAllowed = true\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\"\n  this.strict = this.inModule || this.strictDirective(this.pos)\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0\n  // Labels in scope.\n  this.labels = []\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    this.skipLineComment(2)\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = []\n  this.enterFunctionScope()\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode()\n  this.nextToken()\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^']|\\.)*)'|\"((?:[^\"]|\\.)*)\"|;)/\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start\n    start += skipWhiteSpace.exec(this$1.input)[0].length\n    var match = literal.exec(this$1.input.slice(start))\n    if (!match) return false\n    if ((match[1] || match[2]) == \"use strict\") return true\n    start += match[0].length\n  }\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    if (!notNext)\n      this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1\n};\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) return\n  if (refDestructuringErrors.trailingComma > -1)\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\")\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind\n  if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1\n  if (!andThrow) return pos >= 0\n  if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\")\n  if (this.awaitPos)\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\")\n}\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    return this.isSimpleAssignTarget(expr.expression)\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n}\n\nvar pp$1 = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    var stmt = this$1.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\npp$1.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) ++pos\n    var ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp$1.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.enterLexicalScope()\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  var isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init$1, true, kind)\n    this.finishNode(init$1, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      return this.parseForIn(node, init$1)\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors\n  var init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp$1.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp$1.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n  this.enterLexicalScope()\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur\n  for (var sawDefault = false; this.type != tt.braceR;) {\n    if (this$1.type === tt._case || this$1.type === tt._default) {\n      var isCase = this$1.type === tt._case\n      if (cur) this$1.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this$1.startNode())\n      cur.consequent = []\n      this$1.next()\n      if (isCase) {\n        cur.test = this$1.parseExpression()\n      } else {\n        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this$1.expect(tt.colon)\n    } else {\n      if (!cur) this$1.unexpected()\n      cur.consequent.push(this$1.parseStatement(true))\n    }\n  }\n  this.exitLexicalScope()\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp$1.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = []\n\npp$1.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    var clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.enterLexicalScope()\n    this.checkLVal(clause.param, \"let\")\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock(false)\n    this.exitLexicalScope()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp$1.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp$1.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.labels.length; ++i)\n    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n    var label = this$1.labels[i$1]\n    if (label.statementStart == node.start) {\n      label.statementStart = this$1.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  if (createNewLexicalScope) {\n    this.enterLexicalScope()\n  }\n  while (!this.eat(tt.braceR)) {\n    var stmt = this$1.parseStatement(true)\n    node.body.push(stmt)\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope()\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  this.exitLexicalScope()\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  this.exitLexicalScope()\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    var decl = this$1.startNode()\n    this$1.parseVarId(decl, kind)\n    if (this$1.eat(tt.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n    if (!this$1.eat(tt.comma)) break\n  }\n  return node\n}\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind)\n  this.checkLVal(decl.id, kind, false)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != tt.name ? null : this.parseIdent()\n    if (node.id) {\n      this.checkLVal(node.id, \"var\")\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n  this.enterFunctionScope()\n\n  if (!isStatement)\n    node.id = this.type == tt.name ? this.parseIdent() : null\n\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next()\n\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  var classBody = this.startNode()\n  var hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this$1.eat(tt.semi)) continue\n    var method = this$1.startNode()\n    var isGenerator = this$1.eat(tt.star)\n    var isAsync = false\n    var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n    this$1.parsePropertyName(method)\n    method.static = isMaybeStatic && this$1.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this$1.unexpected()\n      isGenerator = this$1.eat(tt.star)\n      this$1.parsePropertyName(method)\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    var isGetSet = false\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this$1.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start\n        if (method.kind === \"get\")\n          this$1.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null\n}\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    var isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync)\n    } else if (this.type === tt._class) {\n      var cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, \"nullableID\")\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n          this$1.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (has(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (var i = 0; i < pat.properties.length; ++i)\n      this$1.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1]\n      if (elt) this$1.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) return\n  for (var i = 0; i < decls.length; i++)\n    this$1.checkPatternExport(exports, decls[i].id)\n}\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node = this$1.startNode()\n    node.local = this$1.parseIdent(true)\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n    this$1.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, \"let\")\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    var node$1 = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node$1.local = this.parseIdent()\n    this.checkLVal(node$1.local, \"let\")\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node$2 = this$1.startNode()\n    node$2.imported = this$1.parseIdent(true)\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent()\n    } else {\n      node$2.local = node$2.imported\n      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n    }\n    this$1.checkLVal(node$2.local, \"let\")\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n\nvar pp$2 = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (var i = 0; i < node.properties.length; i++) {\n        var prop = node.properties[i]\n        if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this$1.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length\n  if (end) {\n    var last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      var arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i]\n    if (elt) this$1.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp$2.parseRest = function(allowNonIdent) {\n  var node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    var node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this$1.expect(tt.comma)\n    if (allowEmpty && this$1.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === tt.ellipsis) {\n      var rest = this$1.parseRest(allowNonIdent)\n      this$1.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n      this$1.expect(close)\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n      this$1.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp$2.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"))\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name)\n      } else {\n        this.declareLexicalName(expr.name)\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) this.raiseRecoverable(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0; i < expr.properties.length; i++)\n      this$1.checkLVal(expr.properties[i].value, bindingType, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n      var elem = expr.elements[i$1]\n      if (elem) this$1.checkLVal(elem, bindingType, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  var key = prop.key;\n  var name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  var other = propHash[name]\n  if (other) {\n    var redefinition\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set\n    } else {\n      redefinition = other.init || other[kind]\n    }\n    if (redefinition)\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    oldTrailingComma = refDestructuringErrors.trailingComma\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  var startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    var node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      var op = this.value\n      this.next()\n      var startPos = this.start, startLoc = this.startLoc\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.operator = this$1.value\n      node$1.prefix = false\n      node$1.argument = expr\n      this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$1, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprAtom(refDestructuringErrors)\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  var result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (var computed;;) {\n    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this$1.expect(tt.bracketR)\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this$1.eat(tt.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos\n      this$1.yieldPos = 0\n      this$1.awaitPos = 0\n      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false)\n        this$1.checkYieldAwaitInDefaultParams()\n        this$1.yieldPos = oldYieldPos\n        this$1.awaitPos = oldAwaitPos\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true)\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.callee = base\n      node$1.arguments = exprList\n      base = this$1.finishNode(node$1, \"CallExpression\")\n    } else if (this$1.type === tt.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc)\n      node$2.tag = base\n      node$2.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    var startPos = this.start, startLoc = this.startLoc\n    var id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    var value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp$3.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  var val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc\n    var exprList = [], first = true, lastIsComma = false\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        spreadStart = this$1.start\n        exprList.push(this$1.parseParenItem(this$1.parseRest()))\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this$1.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this$1.start\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp$3.parseParenItem = function(item) {\n  return item\n}\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = []\n\npp$3.parseNew = function() {\n  var node = this.startNode()\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty$1\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp$3.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.expect(tt.dollarBraceL)\n    node.expressions.push(this$1.parseExpression())\n    this$1.expect(tt.braceR)\n    node.quasis.push(curElt = this$1.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start\n        startLoc = this$1.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this$1.eat(tt.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL &&\n        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this$1.checkPropClash(prop, propHash)\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    var paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n  this.enterFunctionScope()\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.enterFunctionScope()\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== tt.braceL\n  var oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n    this.checkParams(node, false)\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params))\n    node.body = this.parseBlock(false)\n    node.expression = false\n    this.labels = oldLabels\n  }\n  this.exitFunctionScope()\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\")\n  }\n  this.strict = oldStrict\n}\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {}\n  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], \"var\", allowDuplicates ? null : nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n    } else first = false\n\n    var elt\n    if (allowEmpty && this$1.type === tt.comma)\n      elt = null\n    else if (this$1.type === tt.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this$1.start\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal) {\n  var node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\nvar pp$4 = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  var err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp$4.raiseRecoverable = pp$4.raise\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n}\n\nvar pp$5 = Parser.prototype\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0; i < sources.length; i++) {\n    var source = sources[i]\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  }\n  return target\n}\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}})\n}\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop()\n}\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1]\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}}\n\n  this.scopeStack.push(childScope)\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical)\n}\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop()\n  var parentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar)\n}\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n}\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n}\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true\n}\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true\n}\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\"\n  this.start = pos\n  this.end = 0\n  if (parser.options.locations)\n    this.loc = new SourceLocation(parser, loc)\n  if (parser.options.directSourceFile)\n    this.sourceFile = parser.options.directSourceFile\n  if (parser.options.ranges)\n    this.range = [pos, 0]\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n}\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type\n  node.end = pos\n  if (this.options.locations)\n    node.loc.end = loc\n  if (this.options.ranges)\n    node.range[1] = pos\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n}\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n}\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token\n  this.isExpr = !!isExpr\n  this.preserveSpace = !!preserveSpace\n  this.override = override\n  this.generator = !!generator\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n}\n\nvar pp$7 = Parser.prototype\n\npp$7.initialContext = function() {\n  return [types.b_stat]\n}\n\npp$7.braceIsBlock = function(prevType) {\n  if (prevType === tt.colon) {\n    var parent = this.curContext()\n    if (parent === types.b_stat || parent === types.b_expr)\n      return !parent.isExpr\n  }\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR || prevType == tt.arrow)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 0; i--)\n    if (this$1.context[i].generator) return true\n  return false\n}\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  var out = this.context.pop(), cur\n  if (out === types.b_stat && (cur = this.curContext()) && cur.token === \"function\") {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n\ntt.star.updateContext = function(prevType) {\n  if (prevType == tt._function) {\n    if (this.curContext() === types.f_expr)\n      this.context[this.context.length - 1] = types.f_expr_gen\n    else\n      this.context.push(types.f_gen)\n  }\n  this.exprAllowed = true\n}\n\ntt.name.updateContext = function(prevType) {\n  var allowed = false\n  if (this.options.ecmaVersion >= 6) {\n    if (this.value == \"of\" && !this.exprAllowed ||\n        this.value == \"yield\" && this.inGeneratorContext())\n      allowed = true\n  }\n  this.exprAllowed = allowed\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type\n  this.value = p.value\n  this.start = p.start\n  this.end = p.end\n  if (p.options.locations)\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n  if (p.options.ranges)\n    this.range = [p.start, p.end]\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    this.options.onToken(new Token(this))\n\n  this.lastTokEnd = this.end\n  this.lastTokStart = this.start\n  this.lastTokEndLoc = this.endLoc\n  this.lastTokStartLoc = this.startLoc\n  this.nextToken()\n}\n\npp$8.getToken = function() {\n  this.next()\n  return new Token(this)\n}\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken()\n        return {\n          done: token.type === tt.eof,\n          value: token\n        }\n      }\n    }\n  }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext()\n  if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n  this.start = this.pos\n  if (this.options.locations) this.startLoc = this.curPosition()\n  if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n  if (curContext.override) return curContext.override(this)\n  else this.readToken(this.fullCharCodeAtPos())\n}\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    return this.readWord()\n\n  return this.getTokenFromCode(code)\n}\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n  var next = this.input.charCodeAt(this.pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition()\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n  this.pos = end + 2\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start\n    var match\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine\n      this$1.lineStart = match.index + match[0].length\n    }\n  }\n  if (this.options.onComment)\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos\n  var startLoc = this.options.onComment && this.curPosition()\n  var ch = this.input.charCodeAt(this.pos += startSkip)\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this$1.pos\n    ch = this$1.input.charCodeAt(this$1.pos)\n  }\n  if (this.options.onComment)\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment()\n        break\n      case 47:\n        this$1.skipLineComment(2)\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos\n      } else {\n        break loop\n      }\n    }\n  }\n}\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos\n  if (this.options.locations) this.endLoc = this.curPosition()\n  var prevType = this.type\n  this.type = type\n  this.value = val\n\n  this.updateContext(prevType)\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next >= 48 && next <= 57) return this.readNumber(true)\n  var next2 = this.input.charCodeAt(this.pos + 2)\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3\n    return this.finishToken(tt.ellipsis)\n  } else {\n    ++this.pos\n    return this.finishToken(tt.dot)\n  }\n}\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.slash, 1)\n}\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  var tokentype = code === 42 ? tt.star : tt.modulo\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size\n    tokentype = tt.starstar\n    next = this.input.charCodeAt(this.pos + 2)\n  }\n\n  if (next === 61) return this.finishOp(tt.assign, size + 1)\n  return this.finishOp(tokentype, size)\n}\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n}\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.bitwiseXOR, 1)\n}\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    return this.finishOp(tt.incDec, 2)\n  }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.plusMin, 1)\n}\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tt.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected()\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4)\n    this.skipSpace()\n    return this.nextToken()\n  }\n  if (next === 61) size = 2\n  return this.finishOp(tt.relational, size)\n}\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2\n    return this.finishToken(tt.arrow)\n  }\n  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n}\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(tt.parenL)\n  case 41: ++this.pos; return this.finishToken(tt.parenR)\n  case 59: ++this.pos; return this.finishToken(tt.semi)\n  case 44: ++this.pos; return this.finishToken(tt.comma)\n  case 91: ++this.pos; return this.finishToken(tt.bracketL)\n  case 93: ++this.pos; return this.finishToken(tt.bracketR)\n  case 123: ++this.pos; return this.finishToken(tt.braceL)\n  case 125: ++this.pos; return this.finishToken(tt.braceR)\n  case 58: ++this.pos; return this.finishToken(tt.colon)\n  case 63: ++this.pos; return this.finishToken(tt.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) break\n    ++this.pos\n    return this.finishToken(tt.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(tt.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n}\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size)\n  this.pos += size\n  return this.finishToken(type, str)\n}\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n    var ch = this$1.input.charAt(this$1.pos)\n    if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n    if (!escaped) {\n      if (ch === \"[\") inClass = true\n      else if (ch === \"]\" && inClass) inClass = false\n      else if (ch === \"/\" && !inClass) break\n      escaped = ch === \"\\\\\"\n    } else escaped = false\n    ++this$1.pos\n  }\n  var content = this.input.slice(start, this.pos)\n  ++this.pos\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1()\n  var tmp = content, tmpFlags = \"\"\n  if (mods) {\n    var validFlags = /^[gim]*$/\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\"\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code)\n          if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n          return \"x\"\n        })\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n        tmpFlags = tmpFlags.replace(\"u\", \"\")\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this)\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods)\n  }\n  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n}\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val\n    if (code >= 97) val = code - 97 + 10 // a\n    else if (code >= 65) val = code - 65 + 10 // A\n    else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n    else val = Infinity\n    if (val >= radix) break\n    ++this$1.pos\n    total = total * radix + val\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null\n\n  return total\n}\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2 // 0x\n  var val = this.readInt(radix)\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n  return this.finishToken(tt.num, val)\n}\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n  if (octal && this.pos == start + 1) octal = false\n  var next = this.input.charCodeAt(this.pos)\n  if (next === 46 && !octal) { // '.'\n    ++this.pos\n    this.readInt(10)\n    isFloat = true\n    next = this.input.charCodeAt(this.pos)\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos)\n    if (next === 43 || next === 45) ++this.pos // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    isFloat = true\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n  var str = this.input.slice(start, this.pos), val\n  if (isFloat) val = parseFloat(str)\n  else if (!octal || str.length === 1) val = parseInt(str, 10)\n  else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n  else val = parseInt(str, 8)\n  return this.finishToken(tt.num, val)\n}\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected()\n    var codePos = ++this.pos\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos)\n    ++this.pos\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n  } else {\n    code = this.readHexChar(4)\n  }\n  return code\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === quote) break\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(false)\n      chunkStart = this$1.pos\n    } else {\n      if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n      ++this$1.pos\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++)\n  return this.finishToken(tt.string, out)\n}\n\n// Reads template string tokens.\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && this$1.type === tt.template) {\n        if (ch === 36) {\n          this$1.pos += 2\n          return this$1.finishToken(tt.dollarBraceL)\n        } else {\n          ++this$1.pos\n          return this$1.finishToken(tt.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      return this$1.finishToken(tt.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(true)\n      chunkStart = this$1.pos\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      ++this$1.pos\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n      case 10:\n        out += \"\\n\"\n        break\n      default:\n        out += String.fromCharCode(ch)\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      chunkStart = this$1.pos\n    } else {\n      ++this$1.pos\n    }\n  }\n}\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos)\n  ++this.pos\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n      var octal = parseInt(octalStr, 8)\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1)\n        octal = parseInt(octalStr, 8)\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.raise(this.pos - 2, \"Octal literal in strict mode\")\n      }\n      this.pos += octalStr.length - 1\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n}\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos\n  var n = this.readInt(16, len)\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n  return n\n}\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false\n  var word = \"\", first = true, chunkStart = this.pos\n  var astral = this.options.ecmaVersion >= 6\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos()\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true\n      word += this$1.input.slice(chunkStart, this$1.pos)\n      var escStart = this$1.pos\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n      ++this$1.pos\n      var esc = this$1.readCodePoint()\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        this$1.raise(escStart, \"Invalid Unicode escape\")\n      word += codePointToString(esc)\n      chunkStart = this$1.pos\n    } else {\n      break\n    }\n    first = false\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n}\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1()\n  var type = tt.name\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word)\n    type = keywordTypes[word]\n  }\n  return this.finishToken(type, word)\n}\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.0.3\"\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos)\n  p.nextToken()\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\n// eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser, plugins) {\n  exports.parse_dammit = parse // eslint-disable-line camelcase\n  exports.LooseParser = Parser\n  exports.pluginsLoose = plugins\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = tt;\nexports.keywordTypes = keywordTypes;\nexports.TokContext = TokContext;\nexports.tokContexts = types;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\nexports.nonASCIIwhitespace = nonASCIIwhitespace;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/acorn/dist/acorn.js\n// module id = 4\n// module chunks = 1","import paper from 'paper';\nimport { randNumber } from '../../utilities/helpers';\nimport settings from '../../utilities/settings';\n\nwindow.papers = {};\n\nfunction confetti(selector = '') {\n  const pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers[`${pattern.id}`] = new paper.PaperScope();\n  const paperObj = window.papers[`${pattern.id}`];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', () => {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function randColor() {\n      const selectedColor = settings.colors[randNumber(0, settings.colors.length)];\n      return selectedColor.value;\n    }\n\n    function randPosition() {\n      return [\n        randNumber(1, paperObj.view.bounds.width),\n        randNumber(1, paperObj.view.bounds.height)\n      ];\n    }\n\n    function randPositionX() {\n      return Math.round(paperObj.Point.random().x * paperObj.view.size.width);\n    }\n\n    const density = 0.02;\n    const items = Math.round((area() / 100) * density);\n    const shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: randColor()\n    });\n\n    for (let i = 0; i < items; i++) {\n      const copy = shape.clone();\n\n      copy.size = [30, 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.fillColor = randColor();\n      copy.blendMode = 'multiply';\n      copy.rotate(randNumber(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale((i / items) * randNumber(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n    paperObj.view.update();\n    const children = paperObj.project.activeLayer.children;\n\n    paperObj.view.onFrame = function () {\n      for (let i = 0; i < items; i++) {\n        const item = children[i];\n        const rotationDirection = (i % 2) ? +1 : -1;\n\n        item.rotate(rotationDirection);\n        item.position.y += (item.bounds.width / 30) + 1;\n\n        if (item.bounds.top > paperObj.view.size.height) {\n          item.position.y = -item.bounds.width;\n          item.position.x = randPositionX();\n        }\n      }\n    };\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nfunction background(selector = '', color = 'white') {\n  const pattern = document.querySelector(selector);\n\n  if (!pattern) {\n    return;\n  }\n\n  window.papers[`${pattern.id}`] = new paper.PaperScope();\n  const paperObj = window.papers[`${pattern.id}`];\n\n  paperObj.install(window);\n\n  window.addEventListener('load', () => {\n    paperObj.setup(pattern);\n    paperObj.activate();\n\n    function area() {\n      return paperObj.view.bounds.width * paperObj.view.bounds.height;\n    }\n\n    function selectColor(name) {\n      const selected = settings.colors.find(item => item.name === name);\n      return (selected) ? selected.value : name;\n    }\n\n    function randPosition() {\n      return [\n        randNumber(1, paperObj.view.bounds.width),\n        randNumber(1, paperObj.view.bounds.height)\n      ];\n    }\n\n    const density = 0.02;\n    const items = Math.round((area() / 100) * density);\n    const shape = new paperObj.Path.Rectangle({\n      point: randPosition(),\n      size: [30, 4],\n      fillColor: selectColor(color)\n    });\n\n    for (let i = 0; i < items; i++) {\n      const copy = shape.clone();\n\n      copy.size = [30, 4];\n      copy.position = new paperObj.Point(randPosition());\n      copy.rotate(randNumber(0, 360));\n\n      if (Math.round(i % 5) === 0) {\n        copy.scale((i / items) * randNumber(1, 5));\n      } else {\n        copy.scale(i / items);\n      }\n    }\n\n    paperObj.view.update();\n    paperObj.view.draw();\n  });\n}\n\nexport { confetti, background };\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/patterns/index.js","const settings = {\n  speed: 500,\n  easing: 'easeInOutExpo',\n  colors: [\n    { name: 'red', value: '#DF6C74' },\n    { name: 'green', value: '#99C46D' },\n    { name: 'yellow', value: '#ecce79' },\n    { name: 'blue', value: '#63ADF5' },\n    { name: 'cyan', value: '#59B6C4' },\n    { name: 'orange', value: '#D09B5C' },\n    { name: 'purple', value: '#C575E4' },\n    { name: 'slate', value: '#5F697F' }\n  ]\n};\n\nexport default settings;\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/utilities/settings.js","/*!\n * Paper.js v0.11.4 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Wed Jun 7 16:56:44 2017 +0200\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2016 Juerg Lehni\n * http://scratchdisk.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * http://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = function(self, undefined) {\n\nself = self || require('./node/self.js');\nvar window = self.window,\n\tdocument = self.document;\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\tarray = [],\n\t\tslice = array.slice,\n\t\tcreate = Object.create,\n\t\tdescribe = Object.getOwnPropertyDescriptor,\n\t\tdefine = Object.defineProperty,\n\n\t\tforEach = array.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this) {\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tset = Object.assign || function(dst) {\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tfor (var key in src) {\n\t\t\t\t\tif (src.hasOwnProperty(key))\n\t\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\n\t\teach = function(obj, iter, bind) {\n\t\t\tif (obj) {\n\t\t\t\tvar desc = describe(obj, 'length');\n\t\t\t\t(desc && typeof desc.value === 'number' ? forEach : forIn)\n\t\t\t\t\t.call(obj, iter, bind = bind || obj);\n\t\t\t}\n\t\t\treturn bind;\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res)) {\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t}\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable != null ? enumerable : !bean;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tvar src = arguments[i];\n\t\t\tif (src)\n\t\t\t\tset(this, src);\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn inject(Base, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, null, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, obj, l = arguments.length;\n\t\t\t\t\ti < l && !(ctor && proto); i++) {\n\t\t\t\tobj = arguments[i];\n\t\t\t\tctor = ctor || obj.initialize;\n\t\t\t\tproto = proto || obj.prototype;\n\t\t\t}\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = proto || create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}).inject({\n\t\tenumerable: false,\n\n\t\tinitialize: Base,\n\n\t\tset: Base,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src) {\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\tset: set,\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t},\n\n\t\t\tslice: function(list, begin, end) {\n\t\t\t\treturn slice.call(list, begin, end);\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (typeof module !== 'undefined')\n\tmodule.exports = Base;\n\nBase.inject({\n\tenumerable: false,\n\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\timportJSON: function(json) {\n\t\treturn Base.importJSON(json, this);\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\tset: function(props, exclude) {\n\t\tif (props)\n\t\t\tBase.filter(this, props, exclude, this._prioritize);\n\t\treturn this;\n\t}\n}, {\n\nbeans: false,\nstatics: {\n\texports: {},\n\n\textend: function extend() {\n\t\tvar res = extend.base.apply(this, arguments),\n\t\t\tname = res.prototype._class;\n\t\tif (name && !Base.exports[name])\n\t\t\tBase.exports[name] = res;\n\t\treturn res;\n\t},\n\n\tequals: function(obj1, obj2) {\n\t\tif (obj1 === obj2)\n\t\t\treturn true;\n\t\tif (obj1 && obj1.equals)\n\t\t\treturn obj1.equals(obj2);\n\t\tif (obj2 && obj2.equals)\n\t\t\treturn obj2.equals(obj1);\n\t\tif (obj1 && obj2\n\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\tvar length = obj1.length;\n\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\tlength = keys.length;\n\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tread: function(list, start, options, amount) {\n\t\tif (this === Base) {\n\t\t\tvar value = this.peek(list, start);\n\t\t\tlist.__index++;\n\t\t\treturn value;\n\t\t}\n\t\tvar proto = this.prototype,\n\t\t\treadIndex = proto._readIndex,\n\t\t\tbegin = start || readIndex && list.__index || 0,\n\t\t\tlength = list.length,\n\t\t\tobj = list[begin];\n\t\tamount = amount || length - begin;\n\t\tif (obj instanceof this\n\t\t\t|| options && options.readNull && obj == null && amount <= 1) {\n\t\t\tif (readIndex)\n\t\t\t\tlist.__index = begin + 1;\n\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t}\n\t\tobj = Base.create(proto);\n\t\tif (readIndex)\n\t\t\tobj.__read = true;\n\t\tobj = obj.initialize.apply(obj, begin > 0 || begin + amount < length\n\t\t\t\t? Base.slice(list, begin, begin + amount)\n\t\t\t\t: list) || obj;\n\t\tif (readIndex) {\n\t\t\tlist.__index = begin + obj.__read;\n\t\t\tvar filtered = obj.__filtered;\n\t\t\tif (filtered) {\n\t\t\t\tlist.__filtered = filtered;\n\t\t\t\tobj.__filtered = undefined;\n\t\t\t}\n\t\t\tobj.__read = undefined;\n\t\t}\n\t\treturn obj;\n\t},\n\n\tpeek: function(list, start) {\n\t\treturn list[list.__index = start || list.__index || 0];\n\t},\n\n\tremain: function(list) {\n\t\treturn list.length - (list.__index || 0);\n\t},\n\n\treadList: function(list, start, options, amount) {\n\t\tvar res = [],\n\t\t\tentry,\n\t\t\tbegin = start || 0,\n\t\t\tend = amount ? begin + amount : list.length;\n\t\tfor (var i = begin; i < end; i++) {\n\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t}\n\t\treturn res;\n\t},\n\n\treadNamed: function(list, name, start, options, amount) {\n\t\tvar value = this.getNamed(list, name),\n\t\t\thasObject = value !== undefined;\n\t\tif (hasObject) {\n\t\t\tvar filtered = list.__filtered;\n\t\t\tif (!filtered) {\n\t\t\t\tfiltered = list.__filtered = Base.create(list[0]);\n\t\t\t\tfiltered.__unfiltered = list[0];\n\t\t\t}\n\t\t\tfiltered[name] = undefined;\n\t\t}\n\t\tvar l = hasObject ? [value] : list,\n\t\t\tres = this.read(l, start, options, amount);\n\t\treturn res;\n\t},\n\n\tgetNamed: function(list, name) {\n\t\tvar arg = list[0];\n\t\tif (list._hasObject === undefined)\n\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\tif (list._hasObject)\n\t\t\treturn name ? arg[name] : list.__filtered || arg;\n\t},\n\n\thasNamed: function(list, name) {\n\t\treturn !!this.getNamed(list, name);\n\t},\n\n\tfilter: function(dest, source, exclude, prioritize) {\n\t\tvar processed;\n\n\t\tfunction handleKey(key) {\n\t\t\tif (!(exclude && key in exclude) &&\n\t\t\t\t!(processed && key in processed)) {\n\t\t\t\tvar value = source[key];\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\tdest[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tif (prioritize) {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0, key, l = prioritize.length; i < l; i++) {\n\t\t\t\tif ((key = prioritize[i]) in source) {\n\t\t\t\t\thandleKey(key);\n\t\t\t\t\tkeys[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed = keys;\n\t\t}\n\n\t\tObject.keys(source.__unfiltered || source).forEach(handleKey);\n\t\treturn dest;\n\t},\n\n\tisPlainValue: function(obj, asString) {\n\t\treturn Base.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t|| asString && typeof obj === 'string';\n\t},\n\n\tserialize: function(obj, options, compact, dictionary) {\n\t\toptions = options || {};\n\n\t\tvar isRoot = !dictionary,\n\t\t\tres;\n\t\tif (isRoot) {\n\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\tdictionary = {\n\t\t\t\tlength: 0,\n\t\t\t\tdefinitions: {},\n\t\t\t\treferences: {},\n\t\t\t\tadd: function(item, create) {\n\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t}\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (obj && obj._serialize) {\n\t\t\tres = obj._serialize(options, dictionary);\n\t\t\tvar name = obj._class;\n\t\t\tif (name && !obj._compactSerialize && (isRoot || !compact)\n\t\t\t\t\t&& res[0] !== name) {\n\t\t\t\tres.unshift(name);\n\t\t\t}\n\t\t} else if (Array.isArray(obj)) {\n\t\t\tres = [];\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\tres[i] = Base.serialize(obj[i], options, compact, dictionary);\n\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\tres = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\tdictionary);\n\t\t\t}\n\t\t} else if (typeof obj === 'number') {\n\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t} else {\n\t\t\tres = obj;\n\t\t}\n\t\treturn isRoot && dictionary.length > 0\n\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t: res;\n\t},\n\n\tdeserialize: function(json, create, _data, _setDictionary, _isRoot) {\n\t\tvar res = json,\n\t\t\tisFirst = !_data,\n\t\t\thasDictionary = isFirst && json && json.length\n\t\t\t\t&& json[0][0] === 'dictionary';\n\t\t_data = _data || {};\n\t\tif (Array.isArray(json)) {\n\t\t\tvar type = json[0],\n\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\tif (json.length == 1 && /^#/.test(type)) {\n\t\t\t\treturn _data.dictionary[type];\n\t\t\t}\n\t\t\ttype = Base.exports[type];\n\t\t\tres = [];\n\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++) {\n\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\tisDictionary, hasDictionary));\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tvar args = res;\n\t\t\t\tif (create) {\n\t\t\t\t\tres = create(type, args, isFirst || _isRoot);\n\t\t\t\t} else {\n\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Base.isPlainObject(json)) {\n\t\t\tres = {};\n\t\t\tif (_setDictionary)\n\t\t\t\t_data.dictionary = res;\n\t\t\tfor (var key in json)\n\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t}\n\t\treturn hasDictionary ? res[1] : res;\n\t},\n\n\texportJSON: function(obj, options) {\n\t\tvar json = Base.serialize(obj, options);\n\t\treturn options && options.asString == false\n\t\t\t\t? json\n\t\t\t\t: JSON.stringify(json);\n\t},\n\n\timportJSON: function(json, target) {\n\t\treturn Base.deserialize(\n\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\tfunction(ctor, args, isRoot) {\n\t\t\t\t\tvar useTarget = isRoot && target\n\t\t\t\t\t\t\t&& target.constructor === ctor,\n\t\t\t\t\t\tobj = useTarget ? target\n\t\t\t\t\t\t\t: Base.create(ctor.prototype);\n\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t&& (useTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t}\n\t\t\t\t\t(useTarget ? obj.set : ctor).apply(obj, args);\n\t\t\t\t\tif (useTarget)\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\treturn obj;\n\t\t\t\t});\n\t},\n\n\tsplice: function(list, items, index, remove) {\n\t\tvar amount = items && items.length,\n\t\t\tappend = index === undefined;\n\t\tindex = append ? list.length : index;\n\t\tif (index > list.length)\n\t\t\tindex = list.length;\n\t\tfor (var i = 0; i < amount; i++)\n\t\t\titems[i]._index = index + i;\n\t\tif (append) {\n\t\t\tlist.push.apply(list, items);\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar args = [index, remove];\n\t\t\tif (items)\n\t\t\t\targs.push.apply(args, items);\n\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\tremoved[i]._index = undefined;\n\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\tlist[i]._index = i;\n\t\t\treturn removed;\n\t\t}\n\t},\n\n\tcapitalize: function(str) {\n\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t},\n\n\tcamelize: function(str) {\n\t\treturn str.replace(/-(.)/g, function(match, chr) {\n\t\t\treturn chr.toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(str) {\n\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t}\n}});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, func);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = Base.slice(arguments, 1),\n\t\t\tsetTarget = event && event.target && !event.currentTarget;\n\t\thandlers = handlers.slice();\n\t\tif (setTarget)\n\t\t\tevent.currentTarget = this;\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) == false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t   }\n\t\t}\n\t\tif (setTarget)\n\t\t\tdelete event.currentTarget;\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar types = this._eventTypes,\n\t\t\thandlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tif (types) {\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar entry = types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\tinsertItems: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1) || {};\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\t\tif (!this.agent) {\n\t\t\tvar user = self.navigator.userAgent.toLowerCase(),\n\t\t\t\tos = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],\n\t\t\t\tplatform = os === 'darwin' ? 'mac' : os,\n\t\t\t\tagent = proto.agent = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tagent[platform] = true;\n\t\t\tuser.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g,\n\t\t\t\tfunction(match, n, v1, v2, rv) {\n\t\t\t\t\tif (!agent.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 :\n\t\t\t\t\t\t\t\t/^(node|trident)$/.test(n) ? rv : v1;\n\t\t\t\t\t\tagent.version = v;\n\t\t\t\t\t\tagent.versionNumber = parseFloat(v);\n\t\t\t\t\t\tn = n === 'trident' ? 'msie' : n;\n\t\t\t\t\t\tagent.name = n;\n\t\t\t\t\t\tagent[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (agent.chrome)\n\t\t\t\tdelete agent.webkit;\n\t\t\tif (agent.atom)\n\t\t\t\tdelete agent.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.11.4\",\n\n\tgetView: function() {\n\t\tvar project = this.project;\n\t\treturn project && project._view;\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, options) {\n\t\tpaper.PaperScript.execute(code, this, options);\n\t\tView.updateFocus();\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tcreateCanvas: function(width, height) {\n\t\treturn CanvasProvider.getCanvas(width, height);\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tvar projects = this.projects,\n\t\t\ttools = this.tools;\n\t\tfor (var i = projects.length - 1; i >= 0; i--)\n\t\t\tprojects[i].remove();\n\t\tfor (var i = tools.length - 1; i >= 0; i--)\n\t\t\ttools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._scope.getView();\n\t}\n});\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = Base.pick(precision, 5);\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn this.precision < 16\n\t\t\t\t? Math.round(val * this.multiplier) / this.multiplier : val;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tlog2 = Math.log2 || function(x) {\n\t\t\treturn Math.log(x) * Math.LOG2E;\n\t\t},\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clamp(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\tfunction getDiscriminant(a, b, c) {\n\t\tfunction split(v) {\n\t\t\tvar x = v * 134217729,\n\t\t\t\ty = v - x,\n\t\t\t\thi = y + x,\n\t\t\t\tlo = v - hi;\n\t\t\treturn [hi, lo];\n\t\t}\n\n\t\tvar D = b * b - a * c,\n\t\t\tE = b * b + a * c;\n\t\tif (abs(D) * 3 < E) {\n\t\t\tvar ad = split(a),\n\t\t\t\tbd = split(b),\n\t\t\t\tcd = split(c),\n\t\t\t\tp = b * b,\n\t\t\t\tdp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],\n\t\t\t\tq = a * c,\n\t\t\t\tdq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])\n\t\t\t\t\t\t+ ad[1] * cd[1];\n\t\t\tD = (p - q) + (dp - dq);\n\t\t}\n\t\treturn D;\n\t}\n\n\tfunction getNormalizationFactor() {\n\t\tvar norm = Math.max.apply(Math, arguments);\n\t\treturn norm && (norm < 1e-8 || norm > 1e8)\n\t\t\t\t? pow(2, -Math.round(log2(norm)))\n\t\t\t\t: 0;\n\t}\n\n\treturn {\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 1e-8,\n\t\tGEOMETRIC_EPSILON: 1e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-8,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tclamp: clamp,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance) {\n\t\t\t\t\tx = nx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clamp(x, a, b);\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar x1, x2 = Infinity;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(b) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / b;\n\t\t\t} else {\n\t\t\t\tb *= -0.5;\n\t\t\t\tvar D = getDiscriminant(a, b, c);\n\t\t\t\tif (D && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c));\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\ta *= f;\n\t\t\t\t\t\tb *= f;\n\t\t\t\t\t\tc *= f;\n\t\t\t\t\t\tD = getDiscriminant(a, b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0,\n\t\t\t\tboundless = min == null,\n\t\t\t\tminB = min - EPSILON,\n\t\t\t\tmaxB = max + EPSILON;\n\t\t\tif (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))\n\t\t\t\troots[count++] = boundless ? x1 : clamp(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))\n\t\t\t\troots[count++] = boundless ? x2 : clamp(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),\n\t\t\t\tx, b1, c2, qd, q;\n\t\t\tif (f) {\n\t\t\t\ta *= f;\n\t\t\t\tb *= f;\n\t\t\t\tc *= f;\n\t\t\t\td *= f;\n\t\t\t}\n\n\t\t\tfunction evaluate(x0) {\n\t\t\t\tx = x0;\n\t\t\t\tvar tmp = a * x;\n\t\t\t\tb1 = tmp + b;\n\t\t\t\tc2 = b1 * x + c;\n\t\t\t\tqd = (tmp + b1) * x + c2;\n\t\t\t\tq = c2 * x + d;\n\t\t\t}\n\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tevaluate(-(b / a) / 3);\n\t\t\t\tvar t = q / a,\n\t\t\t\t\tr = pow(abs(t), 1/3),\n\t\t\t\t\ts = t < 0 ? -1 : 1,\n\t\t\t\t\ttd = -qd / a,\n\t\t\t\t\trd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,\n\t\t\t\t\tx0 = x - s * rd;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tevaluate(x0);\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),\n\t\t\t\tboundless = min == null;\n\t\t\tif (isFinite(x) && (count === 0\n\t\t\t\t\t|| count > 0 && x !== roots[0] && x !== roots[1])\n\t\t\t\t\t&& (boundless || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = boundless ? x : clamp(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(name) {\n\t\tif (name) {\n\t\t\tvar pool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasY ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('angle' in obj) {\n\t\t\t\tthis._set(obj.length || 0, 0);\n\t\t\t\tthis.setAngle(obj.angle || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis._set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(arguments);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\ttolerance = Base.read(arguments);\n\t\treturn this.getDistance(point) <= tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.x) && isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tisInQuadrant: function(q) {\n\t\treturn this.x * (q > 1 && q < 4 ? -1 : 1) >= 0\n\t\t\t&& this.y * (q > 2 ? -1 : 1) >= 0;\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\treturn this._setter === 'setPosition' ? 4 : 0;\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasHeight ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.width) && isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar type = typeof arg0,\n\t\t\tread;\n\t\tif (type === 'number') {\n\t\t\tthis._set(arg0, arg1, arg2, arg3);\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0, 0, 0);\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis._set.apply(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis._set(arg0.x || 0, arg0.y || 0,\n\t\t\t\t\t\targ0.width || 0, arg0.height || 0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis._set(0, 0, 0, 0);\n\t\t\t\tBase.filter(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t}\n\t\t}\n\t\tif (read === undefined) {\n\t\t\tvar frm = Point.readNamed(arguments, 'from'),\n\t\t\t\tnext = Base.peek(arguments),\n\t\t\t\tx = frm.x,\n\t\t\t\ty = frm.y,\n\t\t\t\twidth,\n\t\t\t\theight;\n\t\t\tif (next && next.x !== undefined\n\t\t\t\t\t|| Base.hasNamed(arguments, 'to')) {\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\twidth = to.x - x;\n\t\t\t\theight = to.y - y;\n\t\t\t\tif (width < 0) {\n\t\t\t\t\tx = to.x;\n\t\t\t\t\twidth = -width;\n\t\t\t\t}\n\t\t\t\tif (height < 0) {\n\t\t\t\t\ty = to.y;\n\t\t\t\t\theight = -height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\twidth = size.width;\n\t\t\t\theight = size.height;\n\t\t\t}\n\t\t\tthis._set(x, y, width, height);\n\t\t\tread = arguments.__index;\n\t\t\tvar filtered = arguments.__filtered;\n\t\t\tif (filtered)\n\t\t\t\tthis.__filtered = filtered;\n\t\t}\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\t_fw: 1,\n\t_fh: 1,\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tsx = this._sx,\n\t\t\tsy = this._sy,\n\t\t\tw = size.width,\n\t\t\th = size.height;\n\t\tif (sx) {\n\t\t\tthis.x += (this.width - w) * sx;\n\t\t}\n\t\tif (sy) {\n\t\t\tthis.y += (this.height - h) * sy;\n\t\t}\n\t\tthis.width = w;\n\t\tthis.height = h;\n\t\tthis._fw = this._fh = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = left - this.x;\n\t\t\tthis.width -= this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = left;\n\t\tthis._sx = this._fw = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = top - this.y;\n\t\t\tthis.height -= this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = top;\n\t\tthis._sy = this._fh = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = right - this.x;\n\t\t\tthis.width = this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = right - this.width;\n\t\tthis._sx = 1;\n\t\tthis._fw = 0;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = bottom - this.y;\n\t\t\tthis.height = this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = bottom - this.height;\n\t\tthis._sy = 1;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width / 2;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tif (this._fw || this._sx === 0.5) {\n\t\t\tthis.x = x - this.width / 2;\n\t\t} else {\n\t\t\tif (this._sx) {\n\t\t\t\tthis.x += (x - this.x) * 2 * this._sx;\n\t\t\t}\n\t\t\tthis.width = (x - this.x) * 2;\n\t\t}\n\t\tthis._sx = 0.5;\n\t\tthis._fw = 0;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height / 2;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tif (this._fh || this._sy === 0.5) {\n\t\t\tthis.y = y - this.height / 2;\n\t\t} else {\n\t\t\tif (this._sy) {\n\t\t\t\tthis.y += (y - this.y) * 2 * this._sy;\n\t\t\t}\n\t\t\tthis.height = (y - this.y) * 2;\n\t\t}\n\t\tthis._sy = 0.5;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length === 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tepsilon = Base.read(arguments) || 0;\n\t\treturn rect.x + rect.width > this.x - epsilon\n\t\t\t\t&& rect.y + rect.height > this.y - epsilon\n\t\t\t\t&& rect.x < this.x + this.width + epsilon\n\t\t\t\t&& rect.y < this.y + this.height + epsilon;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join(''),\n\t\t\txFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis._set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tinternal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn !!(this._owner._selection & 2);\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner._changeSelection) {\n\t\t\t\t\towner._changeSelection(2, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg, _dontNotify) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count >= 6) {\n\t\t\tthis._set.apply(this, arguments);\n\t\t} else if (count === 1 || count === 2) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,\n\t\t\t\t\t\t_dontNotify);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis._set.apply(this,\n\t\t\t\t\t\t_dontNotify ? arg.concat([_dontNotify]) : arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (!count) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok) {\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t}\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(a, b, c, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._b = b;\n\t\tthis._c = c;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.getValues(), options, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(9);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._c),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._b), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._b = this._c = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t_setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._c;\n\t\tthis._ty += x * this._b + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar scale = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._b *= scale.x;\n\t\tthis._c *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * c;\n\t\tthis._b = cos * b + sin * d;\n\t\tthis._c = -sin * a + cos * c;\n\t\tthis._d = -sin * b + cos * d;\n\t\tthis._tx += tx * a + ty * c;\n\t\tthis._ty += tx * b + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar shear = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tb = this._b;\n\t\tthis._a += shear.y * this._c;\n\t\tthis._b += shear.y * this._d;\n\t\tthis._c += shear.x * a;\n\t\tthis._d += shear.x * b;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar skew = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tappend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * c1;\n\t\t\tthis._c = b2 * a1 + d2 * c1;\n\t\t\tthis._b = a2 * b1 + c2 * d1;\n\t\t\tthis._d = b2 * b1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * c1;\n\t\t\tthis._ty += tx2 * b1 + ty2 * d1;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tprepend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * b1;\n\t\t\tthis._c = a2 * c1 + b2 * d1;\n\t\t\tthis._b = c2 * a1 + d2 * b1;\n\t\t\tthis._d = c2 * c1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tappended: function(mx) {\n\t\treturn this.clone().append(mx);\n\t},\n\n\tprepended: function(mx) {\n\t\treturn this.clone().prepend(mx);\n\t},\n\n\tinvert: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tthis._a = d / det;\n\t\t\tthis._b = -b / det;\n\t\t\tthis._c = -c / det;\n\t\t\tthis._d = a / det;\n\t\t\tthis._tx = (c * ty - d * tx) / det;\n\t\t\tthis._ty = (b * tx - a * ty) / det;\n\t\t\tres = this;\n\t\t}\n\t\treturn res;\n\t},\n\n\tinverted: function() {\n\t\treturn this.clone().invert();\n\t},\n\n\tconcatenate: '#append',\n\tpreConcatenate: '#prepend',\n\tchain: '#appended',\n\n\t_shiftless: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n\t},\n\n\t_orNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\tisInvertible: function() {\n\t\tvar det = this._a * this._d - this._c * this._b;\n\t\treturn det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n\t},\n\n\tisSingular: function() {\n\t\treturn !this.isInvertible();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest._set(\n\t\t\t\tx * this._a + y * this._c + this._tx,\n\t\t\t\tx * this._b + y * this._d + this._ty,\n\t\t\t\t_dontNotify);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tfor (var i = 0, max = 2 * count; i < max; i += 2) {\n\t\t\tvar x = src[i],\n\t\t\t\ty = src[i + 1];\n\t\t\tdst[i] = x * this._a + y * this._c + this._tx;\n\t\t\tdst[i + 1] = x * this._b + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j]) {\n\t\t\t\tmin[j] = val;\n\t\t\t} else if (val > max[j]) {\n\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\tres = dest._set(\n\t\t\t\t\t(x * d - y * c) / det,\n\t\t\t\t\t(y * a - x * b) / det,\n\t\t\t\t\t_dontNotify);\n\t\t}\n\t\treturn res;\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\tdet = a * d - b * c,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tatan2 = Math.atan2,\n\t\t\tdegrees = 180 / Math.PI,\n\t\t\trotate,\n\t\t\tscale,\n\t\t\tskew;\n\t\tif (a !== 0 || b !== 0) {\n\t\t\tvar r = sqrt(a * a + b * b);\n\t\t\trotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n\t\t\tscale = [r, det / r];\n\t\t\tskew = [atan2(a * c + b * d, r * r), 0];\n\t\t} else if (c !== 0 || d !== 0) {\n\t\t\tvar s = sqrt(c * c + d * d);\n\t\t\trotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);\n\t\t\tscale = [det / s, s];\n\t\t\tskew = [0, atan2(a * c + b * d, s * s)];\n\t\t} else {\n\t\t\trotate = 0;\n\t\t\tskew = scale = [0, 0];\n\t\t}\n\t\treturn {\n\t\t\ttranslation: this.getTranslation(),\n\t\t\trotation: rotate * degrees,\n\t\t\tscaling: new Point(scale),\n\t\t\tskewing: new Point(skew[0] * degrees, skew[1] * degrees)\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._b, this._c, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn (this.decompose() || {}).scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn (this.decompose() || {}).rotation;\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tif (!this.isIdentity()) {\n\t\t\tctx.transform(this._a, this._b, this._c, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t}\n\t}\n}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {\n\tvar part = Base.capitalize(key),\n\t\tprop = '_' + key;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(this.getSignedDistance(point));\n\t},\n\n\tgetSignedDistance: function(point) {\n\t\treturn Line.getSignedDistance(this._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true);\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (!isInfinite && Numerical.isZero(ccw)) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t},\n\n\t\tgetDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\treturn Math.abs(\n\t\t\t\t\tLine.getSignedDistance(px, py, vx, vy, x, y, asVector));\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\t_compactSerialize: true,\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis._activeLayer = null;\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectionItems = {};\n\t\tthis._selectionCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this._children, options, true, dictionary);\n\t},\n\n\t_changed: function(flags, item) {\n\t\tif (flags & 1) {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview._needsUpdate = true;\n\t\t\t\tif (!view._requested && view._autoUpdate)\n\t\t\t\t\tview.requestUpdate();\n\t\t\t}\n\t\t}\n\t\tvar changes = this._changes;\n\t\tif (changes && item) {\n\t\t\tvar changesById = this._changesById,\n\t\t\t\tid = item._id,\n\t\t\t\tentry = changesById[id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tchanges.push(changesById[id] = { item: item, flags: flags });\n\t\t\t}\n\t\t}\n\t},\n\n\tclear: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--)\n\t\t\tchildren[i].remove();\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children.length;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.set(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetLayers: function() {\n\t\treturn this._children;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this, insert: true });\n\t},\n\n\tgetSymbolDefinitions: function() {\n\t\tvar definitions = [],\n\t\t\tids = {};\n\t\tthis.getItems({\n\t\t\tclass: SymbolItem,\n\t\t\tmatch: function(item) {\n\t\t\t\tvar definition = item._definition,\n\t\t\t\t\tid = definition._id;\n\t\t\t\tif (!ids[id]) {\n\t\t\t\t\tids[id] = true;\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn definitions;\n\t},\n\n\tgetSymbols: 'getSymbolDefinitions',\n\n\tgetSelectedItems: function() {\n\t\tvar selectionItems = this._selectionItems,\n\t\t\titems = [];\n\t\tfor (var id in selectionItems) {\n\t\t\tvar item = selectionItems[id],\n\t\t\t\tselection = item._selection;\n\t\t\tif ((selection & 1) && item.isInserted()) {\n\t\t\t\titems.push(item);\n\t\t\t} else if (!selection) {\n\t\t\t\tthis._updateSelection(item);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectionItems = this._selectionItems;\n\t\tif (item._selection) {\n\t\t\tif (selectionItems[id] !== item) {\n\t\t\t\tthis._selectionCount++;\n\t\t\t\tselectionItems[id] = item;\n\t\t\t}\n\t\t} else if (selectionItems[id] === item) {\n\t\t\tthis._selectionCount--;\n\t\t\tdelete selectionItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectionItems = this._selectionItems;\n\t\tfor (var i in selectionItems)\n\t\t\tselectionItems[i].setFullySelected(false);\n\t},\n\n\taddLayer: function(layer) {\n\t\treturn this.insertLayer(undefined, layer);\n\t},\n\n\tinsertLayer: function(index, layer) {\n\t\tif (layer instanceof Layer) {\n\t\t\tlayer._remove(false, true);\n\t\t\tBase.splice(this._children, [layer], index, 0);\n\t\t\tlayer._setProject(this, true);\n\t\t\tvar name = layer._name;\n\t\t\tif (name)\n\t\t\t\tlayer.setName(name);\n\t\t\tif (this._changes)\n\t\t\t\tlayer._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = layer;\n\t\t} else {\n\t\t\tlayer = null;\n\t\t}\n\t\treturn layer;\n\t},\n\n\t_insertItem: function(index, item, _created) {\n\t\titem = this.insertLayer(index, item)\n\t\t\t\t|| (this._activeLayer || this._insertItem(undefined,\n\t\t\t\t\t\tnew Layer(Item.NO_INSERT), true))\n\t\t\t\t\t\t.insertChild(index, item);\n\t\tif (_created && item.activate)\n\t\t\titem.activate();\n\t\treturn item;\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tremoveOn: function(type) {\n\t\tvar sets = this._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar children = this._children,\n\t\t\tparam = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].draw(ctx, param);\n\t\t}\n\t\tctx.restore();\n\n\t\tif (this._selectionCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectionItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items) {\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = Base.set({},\n\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_name: null,\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_canScaleStroke: false,\n\t_pivot: null,\n\t_visible: true,\n\t_blendMode: 'normal',\n\t_opacity: 1,\n\t_locked: false,\n\t_guide: false,\n\t_clipMask: false,\n\t_selection: 0,\n\t_selectBounds: true,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tlocked: false,\n\t\tguide: false,\n\t\tclipMask: false,\n\t\tselected: false,\n\t\tdata: {}\n\t},\n\t_prioritize: ['applyMatrix']\n},\nnew function() {\n\tvar handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];\n\treturn Base.each(handlers,\n\t\tfunction(name) {\n\t\t\tthis._events[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, 1);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, -1);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\t_events: {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tonLoad: {},\n\t\t\t\tonError: {}\n\t\t\t},\n\t\t\tstatics: {\n\t\t\t\t_itemHandlers: handlers\n\t\t\t}\n\t\t}\n\t);\n}, {\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project,\n\t\t\tsettings = paper.settings;\n\t\tthis._id = internal ? null : UID.get();\n\t\tthis._parent = this._index = null;\n\t\tthis._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (internal || hasProps && props.insert == false\n\t\t\t|| !settings.insertItems && !(hasProps && props.insert === true)) {\n\t\t\tthis._setProject(project);\n\t\t} else {\n\t\t\t(hasProps && props.parent || project)\n\t\t\t\t\t._insertItem(undefined, this, true);\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT) {\n\t\t\tthis.set(props, {\n\t\t\t\tinternal: true, insert: true, project: true, parent: true\n\t\t\t});\n\t\t}\n\t\treturn hasProps;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._symbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\tthis._globalMatrix = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 40)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project)\n\t\t\tproject._changed(flags, this);\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar owner = this._getOwner();\n\t\tif (name && owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tif (!(name in children))\n\t\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(128);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tkey = '_' + name,\n\t\t\tflags = {\n\t\t\t\tlocked: 128,\n\t\t\t\tvisible: 137\n\t\t\t};\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[key];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[key]) {\n\t\t\t\tthis[key] = value;\n\t\t\t\tthis._changed(flags[name] || 129);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tif (selection !== this._selection) {\n\t\t\tthis._selection = selection;\n\t\t\tvar project = this._project;\n\t\t\tif (project) {\n\t\t\t\tproject._updateSelection(this);\n\t\t\t\tthis._changed(129);\n\t\t\t}\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn !!(this._selection & 1);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisFullySelected: function() {\n\t\tvar children = this._children,\n\t\t\tselected = !!(this._selection & 1);\n\t\tif (children && selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(129);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(1024);\n\t\t}\n\t},\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar position = this._position,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\tif (!position) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tposition = this._position = pivot\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t}\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\tgetPivot: function() {\n\t\tvar pivot = this._pivot;\n\t\treturn pivot\n\t\t\t\t? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')\n\t\t\t\t: null;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t}\n}, Base.each({\n\t\tgetStrokeBounds: { stroke: true },\n\t\tgetHandleBounds: { handle: true },\n\t\tgetInternalBounds: { internal: true }\n\t},\n\tfunction(options, key) {\n\t\tthis[key] = function(matrix) {\n\t\t\treturn this.getBounds(matrix, options);\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\tgetBounds: function(matrix, options) {\n\t\tvar hasMatrix = options || matrix instanceof Matrix,\n\t\t\topts = Base.set({}, hasMatrix ? options : matrix,\n\t\t\t\t\tthis._boundsOptions);\n\t\tif (!opts.stroke || this.getStrokeScaling())\n\t\t\topts.cacheItem = this;\n\t\tvar rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n\t\treturn !arguments.length\n\t\t\t\t? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,\n\t\t\t\t\tthis, 'setBounds')\n\t\t\t\t: rect;\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\t_matrix = this._matrix,\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tif (!_matrix.isInvertible()) {\n\t\t\t\t_matrix.set(_matrix._backup\n\t\t\t\t\t\t|| new Matrix().translate(_matrix.getTranslation()));\n\t\t\t\tbounds = this.getBounds();\n\t\t\t}\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width !== 0 ? rect.width / bounds.width : 0,\n\t\t\t\t\tbounds.height !== 0 ? rect.height / bounds.height : 0);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar children = this._children;\n\t\tif (!children || !children.length)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, options.cacheItem);\n\t\treturn Item._getBounds(children, matrix, options);\n\t},\n\n\t_getBoundsCacheKey: function(options, internal) {\n\t\treturn [\n\t\t\toptions.stroke ? 1 : 0,\n\t\t\toptions.handle ? 1 : 0,\n\t\t\tinternal ? 1 : 0\n\t\t].join('');\n\t},\n\n\t_getCachedBounds: function(matrix, options, noInternal) {\n\t\tmatrix = matrix && matrix._orNullIfIdentity();\n\t\tvar internal = options.internal && !noInternal,\n\t\t\tcacheItem = options.cacheItem,\n\t\t\t_matrix = internal ? null : this._matrix._orNullIfIdentity(),\n\t\t\tcacheKey = cacheItem && (!matrix || matrix.equals(_matrix))\n\t\t\t\t&& this._getBoundsCacheKey(options, internal),\n\t\t\tbounds = this._bounds;\n\t\tItem._updateBoundsCache(this._parent || this._symbol, cacheItem);\n\t\tif (cacheKey && bounds && cacheKey in bounds) {\n\t\t\tvar cached = bounds[cacheKey];\n\t\t\treturn {\n\t\t\t\trect: cached.rect.clone(),\n\t\t\t\tnonscaling: cached.nonscaling\n\t\t\t};\n\t\t}\n\t\tvar res = this._getBounds(matrix || _matrix, options),\n\t\t\trect = res.rect || res,\n\t\t\tstyle = this._style,\n\t\t\tnonscaling = res.nonscaling || style.hasStroke()\n\t\t\t\t&& !style.getStrokeScaling();\n\t\tif (cacheKey) {\n\t\t\tif (!bounds) {\n\t\t\t\tthis._bounds = bounds = {};\n\t\t\t}\n\t\t\tvar cached = bounds[cacheKey] = {\n\t\t\t\trect: rect.clone(),\n\t\t\t\tnonscaling: nonscaling,\n\t\t\t\tinternal: internal\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trect: rect,\n\t\t\tnonscaling: nonscaling\n\t\t};\n\t},\n\n\t_getStrokeMatrix: function(matrix, options) {\n\t\tvar parent = this.getStrokeScaling() ? null\n\t\t\t\t: options && options.internal ? this\n\t\t\t\t\t: this._parent || this._symbol && this._symbol._item,\n\t\t\tmx = parent ? parent.getViewMatrix().invert() : matrix;\n\t\treturn mx && mx._shiftless();\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent && item) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getBounds: function(items, matrix, options) {\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2,\n\t\t\t\tnonscaling = false;\n\t\t\toptions = options || {};\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._visible && !item.isEmpty()) {\n\t\t\t\t\tvar bounds = item._getCachedBounds(\n\t\t\t\t\t\tmatrix && matrix.appended(item._matrix), options, true),\n\t\t\t\t\t\trect = bounds.rect;\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t\tif (bounds.nonscaling)\n\t\t\t\t\t\tnonscaling = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\trect: isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle(),\n\t\t\t\tnonscaling: nonscaling\n\t\t\t};\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._applyMatrix\n\t\t\t? null\n\t\t\t: this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed ? decomposed.rotation : 0;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\ts = decomposed && decomposed.scaling;\n\t\treturn new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling && !current.equals(scaling)) {\n\t\t\tvar rotation = this.getRotation(),\n\t\t\t\tdecomposed = this._decomposed,\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tcenter = this.getPosition(true);\n\t\t\tmatrix.translate(center);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(rotation);\n\t\t\tmatrix.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(-rotation);\n\t\t\tmatrix.translate(center.negate());\n\t\t\tthis.transform(matrix);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix,\n\t\t\tupdateVersion = this._project._updateVersion;\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\tmatrix = null;\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.prepend(parent.getGlobalMatrix(true));\n\t\t\tmatrix._updateVersion = updateVersion;\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetViewMatrix: function() {\n\t\treturn this.getGlobalMatrix().prepend(this.getView()._matrix);\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\t_getOwner: '#getParent',\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(options) {\n\t\tvar copy = new this.constructor(Item.NO_INSERT),\n\t\t\tchildren = this._children,\n\t\t\tinsert = Base.pick(options ? options.insert : undefined,\n\t\t\t\t\toptions === undefined || options === true),\n\t\t\tdeep = Base.pick(options ? options.deep : undefined, true);\n\t\tif (children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (!children || deep)\n\t\t\tcopy.copyContent(this);\n\t\tif (!children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (insert)\n\t\t\tcopy.insertAbove(this);\n\t\tvar name = this._name,\n\t\t\tparent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\tif (name !== orig)\n\t\t\t\tcopy.setName(name);\n\t\t}\n\t\treturn copy;\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar children = source._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tthis.addChild(children[i].clone(false), true);\n\t\t}\n\t},\n\n\tcopyAttributes: function(source, excludeMatrix) {\n\t\tthis.setStyle(source._style);\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (source.hasOwnProperty(key))\n\t\t\t\tthis[key] = source[key];\n\t\t}\n\t\tif (!excludeMatrix)\n\t\t\tthis._matrix.set(source._matrix, true);\n\t\tthis.setApplyMatrix(source._applyMatrix);\n\t\tthis.setPivot(source._pivot);\n\t\tthis.setSelection(source._selection);\n\t\tvar data = source._data,\n\t\t\tname = source._name;\n\t\tthis._data = data ? Base.clone(data) : null;\n\t\tif (name)\n\t\t\tthis.setName(name);\n\t},\n\n\trasterize: function(resolution, insert) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\tif (!size.isZero()) {\n\t\t\tvar canvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t\traster.setCanvas(canvas);\n\t\t}\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t.scale(1 / scale));\n\t\tif (insert === undefined || insert)\n\t\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\treturn !!this._contains(\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t},\n\n\t_contains: function(point) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tif (children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix, true).length > 0;\n\t}\n},\nnew function() {\n\tfunction hitTest() {\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(arguments),\n\t\t\t\tHitResult.getOptions(arguments));\n\t}\n\n\tfunction hitTestAll() {\n\t\tvar point = Point.read(arguments),\n\t\t\toptions = HitResult.getOptions(arguments),\n\t\t\tall = [];\n\t\tthis._hitTest(point, Base.set({ all: all }, options));\n\t\treturn all;\n\t}\n\n\tfunction hitTestChildren(point, options, viewMatrix, _exclude) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar res = child !== _exclude && child._hitTest(point, options,\n\t\t\t\t\t\tviewMatrix);\n\t\t\t\tif (res && !options.all)\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tProject.inject({\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTest: hitTestChildren\n\t});\n\n\treturn {\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTestChildren: hitTestChildren,\n\t};\n}, {\n\n\t_hitTest: function(point, options, parentViewMatrix) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar matrix = this._matrix,\n\t\t\tviewMatrix = parentViewMatrix\n\t\t\t\t\t? parentViewMatrix.appended(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().prepend(this.getView()._matrix),\n\t\t\ttolerance = Math.max(options.tolerance, 1e-12),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\tPath._getStrokePadding(tolerance,\n\t\t\t\t\t\tmatrix._shiftless().invert()));\n\t\tpoint = matrix._inverseTransform(point);\n\t\tif (!point || !this._children &&\n\t\t\t!this.getBounds({ internal: true, stroke: true, handle: true })\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this.isSelected()\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tmatch = options.match,\n\t\t\tthat = this,\n\t\t\tbounds,\n\t\t\tres;\n\n\t\tfunction filter(hit) {\n\t\t\tif (hit && match && !match(hit))\n\t\t\t\thit = null;\n\t\t\tif (hit && options.all)\n\t\t\t\toptions.all.push(hit);\n\t\t\treturn hit;\n\t\t}\n\n\t\tfunction checkPoint(type, part) {\n\t\t\tvar pt = part ? bounds['get' + part]() : that.getPosition();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1) {\n\t\t\t\treturn new HitResult(type, that, {\n\t\t\t\t\tname: part ? Base.hyphenate(part) : type,\n\t\t\t\t\tpoint: pt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar checkPosition = options.position,\n\t\t\tcheckCenter = options.center,\n\t\t\tcheckBounds = options.bounds;\n\t\tif (checkSelf && this._parent\n\t\t\t\t&& (checkPosition || checkCenter || checkBounds)) {\n\t\t\tif (checkCenter || checkBounds) {\n\t\t\t\tbounds = this.getInternalBounds();\n\t\t\t}\n\t\t\tres = checkPosition && checkPoint('position') ||\n\t\t\t\t\tcheckCenter && checkPoint('center', 'Center');\n\t\t\tif (!res && checkBounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++) {\n\t\t\t\t\tres = checkPoint('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = filter(res);\n\t\t}\n\n\t\tif (!res) {\n\t\t\tres = this._hitTestChildren(point, options, viewMatrix)\n\t\t\t\t|| checkSelf\n\t\t\t\t\t&& filter(this._hitTestSelf(point, options, viewMatrix,\n\t\t\t\t\t\tthis.getStrokeScaling() ? null\n\t\t\t\t\t\t\t: viewMatrix._shiftless().invert()))\n\t\t\t\t|| null;\n\t\t}\n\t\tif (res && res.point) {\n\t\t\tres.point = matrix.transform(res.point);\n\t\t}\n\t\treturn res;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else if (name === 'match') {\n\t\t\treturn compare(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (name === 'class') {\n\t\t\t\tif (typeof compare === 'function')\n\t\t\t\t\treturn this instanceof compare;\n\t\t\t\tvalue = this._class;\n\t\t\t}\n\t\t\tif (typeof compare === 'function') {\n\t\t\t\treturn !!compare(value);\n\t\t\t} else if (compare) {\n\t\t\t\tif (compare.test) {\n\t\t\t\t\treturn compare.test(value);\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\treturn matchObject(compare, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Base.equals(value, compare);\n\t\t}\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix, null, true)[0]\n\t\t\t\t|| null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(item, options, matrix, param, firstOnly) {\n\t\t\tif (!param) {\n\t\t\t\tvar obj = typeof options === 'object' && options,\n\t\t\t\t\toverlapping = obj && obj.overlapping,\n\t\t\t\t\tinside = obj && obj.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\trecursive: obj && obj.recursive !== false,\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (obj) {\n\t\t\t\t\toptions = Base.filter({}, options, {\n\t\t\t\t\t\trecursive: true, inside: true, overlapping: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = item._children,\n\t\t\t\titems = param.items,\n\t\t\t\trect = param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.appended(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(rect.contains(bounds)\n\t\t\t\t\t\t\t|| param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(options)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (param.recursive !== false) {\n\t\t\t\t\t_getItems(child, options, childMatrix, param, firstOnly);\n\t\t\t\t}\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this ? this.addChild(res) : res;\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tvar res = item ? this.insertChildren(index, [item]) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items) {\n\t\treturn this.insertChildren(this._children.length, items);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Base.slice(items);\n\t\t\tvar inserted = {};\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tid = item && item._id;\n\t\t\t\tif (!item || inserted[id]) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\titem._remove(false, true);\n\t\t\t\t\tinserted[id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tname = item._name;\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(project, true);\n\t\t\t\tif (name)\n\t\t\t\t\titem.setName(name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\titem._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertItem: '#insertChild',\n\n\t_insertAt: function(item, offset) {\n\t\tvar owner = item && item._getOwner(),\n\t\t\tres = item !== this && owner ? this : null;\n\t\tif (res) {\n\t\t\tres._remove(false, true);\n\t\t\towner._insertItem(item._index + offset, res);\n\t\t}\n\t\treturn res;\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn this._insertAt(item, 1);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn this._insertAt(item, 0);\n\t},\n\n\tsendToBack: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(0, this) : null;\n\t},\n\n\tbringToFront: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(undefined, this) : null;\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\taddTo: function(owner) {\n\t\treturn owner._insertItem(undefined, this);\n\t},\n\n\tcopyTo: function(owner) {\n\t\treturn this.clone(false).addTo(owner);\n\t},\n\n\treduce: function(options) {\n\t\tvar children = this._children;\n\t\tif (children && children.length === 1) {\n\t\t\tvar child = children[0].reduce(options);\n\t\t\tif (this._parent) {\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tthis.remove();\n\t\t\t} else {\n\t\t\t\tchild.remove();\n\t\t\t}\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar owner = this._getOwner();\n\t\tif (owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[0];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar owner = this._getOwner(),\n\t\t\tproject = this._project,\n\t\t\tindex = this._index;\n\t\tif (owner) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (index != null) {\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(owner._children, null, index, 1);\n\t\t\t}\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent)\n\t\t\t\towner._changed(11, this);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(start, end) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, start, end - start);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function() {\n\t\tvar children = this._children;\n\t\treturn !children || !children.length;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent === item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t_setApplyMatrix) {\n\t\tvar _matrix = this._matrix,\n\t\t\ttransform = matrix && !matrix.isIdentity(),\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t&& ((!_matrix.isIdentity() || transform)\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\tif (!transform && !applyMatrix)\n\t\t\treturn this;\n\t\tif (transform) {\n\t\t\tif (!matrix.isInvertible() && _matrix.isInvertible())\n\t\t\t\t_matrix._backup = _matrix.getValues();\n\t\t\t_matrix.prepend(matrix, true);\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\t\tif (applyMatrix && (applyMatrix = this._transformContent(_matrix,\n\t\t\t\t_applyRecursively, _setApplyMatrix))) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tif (transform || applyMatrix) {\n\t\t\tthis._changed(9);\n\t\t}\n\t\tvar decomp = transform && bounds && matrix.decompose();\n\t\tif (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar cache = bounds[key];\n\t\t\t\tif (cache.nonscaling) {\n\t\t\t\t\tdelete bounds[key];\n\t\t\t\t} else if (applyMatrix || !cache.internal) {\n\t\t\t\t\tvar rect = cache.rect;\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bounds = bounds;\n\t\t\tvar cached = bounds[this._getBoundsCacheKey(\n\t\t\t\t\tthis._boundsOptions || {})];\n\t\t\tif (cached) {\n\t\t\t\tthis._position = cached.rect.getCenter(true);\n\t\t\t}\n\t\t} else if (transform && position && this._pivot) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\tsetApplyMatrix);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t}\n}), {\n\n\t_setStyles: function(ctx, param, viewMatrix) {\n\t\tvar style = this._style,\n\t\t\tmatrix = this._matrix;\n\t\tif (style.hasFill()) {\n\t\t\tctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n\t\t}\n\t\tif (style.hasStroke()) {\n\t\t\tctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n\t\t\tctx.lineWidth = style.getStrokeWidth();\n\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\tif (strokeJoin)\n\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\tif (strokeCap)\n\t\t\t\tctx.lineCap = strokeCap;\n\t\t\tif (miterLimit)\n\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\tif (paper.support.nativeDash) {\n\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (style.hasShadow()) {\n\t\t\tvar pixelRatio = param.pixelRatio || 1,\n\t\t\t\tmx = viewMatrix._shiftless().prepend(\n\t\t\t\t\tnew Matrix().scale(pixelRatio, pixelRatio)),\n\t\t\t\tblur = mx.transform(new Point(style.getShadowBlur(), 0)),\n\t\t\t\toffset = mx.transform(this.getShadowOffset());\n\t\t\tctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n\t\t\tctx.shadowBlur = blur.getLength();\n\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\tctx.shadowOffsetY = offset.y;\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].appended(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tviewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)\n\t\t\t\t: globalMatrix;\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = this._opacity,\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(viewMatrix);\n\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\treturn;\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.appended(matrix)\n\t\t\t\t: this._canScaleStroke && !this.getStrokeScaling(true)\n\t\t\t\t\t&& viewMatrix,\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform) {\n\t\t\t(direct ? matrix : viewMatrix).applyToContext(ctx);\n\t\t}\n\t\tif (clip) {\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, viewMatrix, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish)\n\t\t\tctx.clip();\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n\t\tvar selection = this._selection,\n\t\t\titemSelected = selection & 1,\n\t\t\tboundsSelected = selection & 2\n\t\t\t\t\t|| itemSelected && this._selectBounds,\n\t\t\tpositionSelected = selection & 4;\n\t\tif (!this._drawSelected)\n\t\t\titemSelected = false;\n\t\tif ((itemSelected || boundsSelected || positionSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar layer,\n\t\t\t\tcolor = this.getSelectedColor(true) || (layer = this.getLayer())\n\t\t\t\t\t&& layer.getSelectedColor(true),\n\t\t\t\tmx = matrix.appended(this.getGlobalMatrix(true)),\n\t\t\t\thalf = size / 2;\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (itemSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectionItems);\n\t\t\tif (positionSelected) {\n\t\t\t\tvar point = this.getPosition(true),\n\t\t\t\t\tx = point.x,\n\t\t\t\t\ty = point.y;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.stroke();\n\t\t\t\tvar deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],\n\t\t\t\t\tstart = half,\n\t\t\t\t\tend = size + 1;\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar delta = deltas[i],\n\t\t\t\t\t\tdx = delta[0],\n\t\t\t\t\t\tdy = delta[1];\n\t\t\t\t\tctx.moveTo(x + dx * start, y + dy * start);\n\t\t\t\t\tctx.lineTo(x + dx * end, y + dy * end);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (boundsSelected) {\n\t\t\t\tvar coords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(key) {\n\tthis['removeOn' + Base.capitalize(key)] = function() {\n\t\tvar hash = {};\n\t\thash[key] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}));\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectBounds: false,\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 1026) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i]._clipMask) {\n\t\t\t\t\tclipItem = children[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_getBounds: function _getBounds(matrix, options) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn clipItem\n\t\t\t? clipItem._getCachedBounds(\n\t\t\t\tmatrix && matrix.appended(clipItem._matrix),\n\t\t\t\tBase.set({}, options, { stroke: false }))\n\t\t\t: _getBounds.base.call(this, matrix, options);\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn (!clipItem || clipItem.contains(point))\n\t\t\t\t&& _hitTestChildren.base.call(this, point, options, viewMatrix,\n\t\t\t\t\tclipItem);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem();\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tctx.beginPath();\n\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar item = children[i];\n\t\t\tif (item !== clipItem)\n\t\t\t\titem.draw(ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer() {\n\t\tGroup.apply(this, arguments);\n\t},\n\n\t_getOwner: function() {\n\t\treturn this._parent || this._index != null && this._project;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_hitTestSelf: function() {\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_canScaleStroke: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props, point) {\n\t\tthis._initialize(props, point);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setType(source._type);\n\t\tthis.setSize(source._size);\n\t\tthis.setRadius(source._radius);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tthis._radius.set(Size.min(this._radius, size.divide(2)));\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius._set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size._set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size._set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size._set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t});\n\t\tpath.copyAttributes(this);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\tif (insert === undefined || insert)\n\t\t\tpath.insertAbove(this);\n\t\treturn path;\n\t},\n\n\ttoShape: '#clone',\n\n\t_asPathItem: function() {\n\t\treturn this.toPath(false);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\tstyle = this._style,\n\t\t\tstrokeWidth = options.stroke && style.hasStroke()\n\t\t\t\t\t&& style.getStrokeWidth();\n\t\tif (matrix)\n\t\t\trect = matrix._transformBounds(rect);\n\t\treturn strokeWidth\n\t\t\t\t? rect.expand(Path._getStrokePadding(strokeWidth,\n\t\t\t\t\tthis._getStrokeMatrix(matrix, options)))\n\t\t\t\t: rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var q = 1; q <= 4; q++) {\n\t\t\t\tvar dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(\n\t\t\t\t\t\t\texpand ? corner.add(dir.multiply(expand)) : corner,\n\t\t\t\t\t\t\tcenter);\n\t\t\t\tif (rect.contains(point))\n\t\t\t\t\treturn { point: center, quadrant: q };\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isOnEllipseStroke(point, radius, padding, quadrant) {\n\t\tvar vector = point.divide(radius);\n\t\treturn (!quadrant || vector.isInQuadrant(quadrant)) &&\n\t\t\t\tvector.subtract(vector.normalize()).multiply(radius)\n\t\t\t\t\t.divide(padding).length <= 1;\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center.point).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,\n\t\t\t\tstrokeMatrix) {\n\t\t\tvar hit = false,\n\t\t\t\tstyle = this._style,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill();\n\t\t\tif (hitStroke || hitFill) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\t\tstrokePadding = options._tolerancePadding.add(\n\t\t\t\t\t\tPath._getStrokePadding(strokeRadius,\n\t\t\t\t\t\t\t!style.getStrokeScaling() && strokeMatrix));\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar padding = strokePadding.multiply(2),\n\t\t\t\t\t\tcenter = getCornerCenter(this, point, padding);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\thit = isOnEllipseStroke(point.subtract(center.point),\n\t\t\t\t\t\t\t\tradius, strokePadding, center.quadrant);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(padding),\n\t\t\t\t\t\t\tinner = rect.expand(padding.negate());\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thit = isOnEllipseStroke(point, radius, strokePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = new Shape(Base.getNamed(args), point);\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\treturn item;\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targuments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, arguments);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: false, handle: false },\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\t_prioritize: ['crossOrigin'],\n\n\tinitialize: function Raster(object, position) {\n\t\tif (!this._initialize(object,\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\tvar image = typeof object === 'string'\n\t\t\t\t\t? document.getElementById(object) : object;\n\t\t\tif (image) {\n\t\t\t\tthis.setImage(image);\n\t\t\t} else {\n\t\t\t\tthis.setSource(object);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar image = source._image,\n\t\t\tcanvas = source._canvas;\n\t\tif (image) {\n\t\t\tthis._setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(source._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tthis._setImage(copyCanvas);\n\t\t}\n\t\tthis._crossOrigin = source._crossOrigin;\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = this.getElement();\n\t\t\t\tthis._setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element)\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tgetLoaded: function() {\n\t\treturn this._loaded;\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tvar that = this;\n\n\t\tfunction emit(event) {\n\t\t\tvar view = that.getView(),\n\t\t\t\ttype = event && event.type || 'load';\n\t\t\tif (view && that.responds(type)) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.emit(type, new Event(event));\n\t\t\t}\n\t\t}\n\n\t\tthis._setImage(image);\n\t\tif (this._loaded) {\n\t\t\tsetTimeout(emit, 0);\n\t\t} else if (image) {\n\t\t\tDomEvent.add(image, {\n\t\t\t\tload: function(event) {\n\t\t\t\t\tthat._setImage(image);\n\t\t\t\t\temit(event);\n\t\t\t\t},\n\t\t\t\terror: emit\n\t\t\t});\n\t\t}\n\t},\n\n\t_setImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = !!(image && image.src && image.complete);\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(521);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(modify) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (modify) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(513);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar image = new self.Image(),\n\t\t\tcrossOrigin = this._crossOrigin;\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\timage.src = src;\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tvar image = this._image;\n\t\tif (image)\n\t\t\timage.crossOrigin = crossOrigin;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster._setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.prepend(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar image = this._image,\n\t\t\tsrc = image && image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (typeof object === 'object') {\n\t\t\tif ('width' in object) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if ('x' in object) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t}\n\t\tif (!bounds)\n\t\t\treturn null;\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcolor = Color.read(arguments),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx) {\n\t\tvar element = this.getElement();\n\t\tif (element) {\n\t\t\tctx.globalAlpha = this._opacity;\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar SymbolItem = Item.extend({\n\t_class: 'SymbolItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: true },\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function SymbolItem(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setDefinition(arg0 instanceof SymbolDefinition ?\n\t\t\t\t\targ0 : new SymbolDefinition(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._definition === item._definition;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setDefinition(source._definition);\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(definition) {\n\t\tthis._definition = definition;\n\t\tthis._changed(9);\n\t},\n\n\tgetSymbol: '#getDefinition',\n\tsetSymbol: '#setDefinition',\n\n\tisEmpty: function() {\n\t\treturn this._definition._item.isEmpty();\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar item = this._definition._item;\n\t\treturn item._getCachedBounds(item._matrix.prepended(matrix), options);\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix) {\n\t\tvar res = this._definition._item._hitTest(point, options, viewMatrix);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis._definition._item.draw(ctx, param);\n\t}\n\n});\n\nvar SymbolDefinition = Base.extend({\n\t_class: 'SymbolDefinition',\n\n\tinitialize: function SymbolDefinition(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tif (item)\n\t\t\tthis.setItem(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._item],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8)\n\t\t\tItem._clearBoundsCache(this);\n\t\tif (flags & 1)\n\t\t\tthis.project._changed(flags);\n\t},\n\n\tgetItem: function() {\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item, _dontCenter) {\n\t\tif (item._symbol)\n\t\t\titem = item.clone();\n\t\tif (this._item)\n\t\t\tthis._item._symbol = null;\n\t\tthis._item = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._symbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tgetDefinition: '#getItem',\n\tsetDefinition: '#setItem',\n\n\tplace: function(position) {\n\t\treturn new SymbolItem(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new SymbolDefinition(this._item.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this._item.equals(symbol._item)\n\t\t\t\t|| false;\n\t}\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values)\n\t\t\tthis.inject(values);\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(args) {\n\t\t\tvar options = args && Base.read(args);\n\t\t\treturn Base.set({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tposition: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\t_selection: 0,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut, selection;\n\t\tif (count > 0) {\n\t\t\tif (arg0 == null || typeof arg0 === 'object') {\n\t\t\t\tif (count === 1 && arg0 && 'point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t\tselection = arg0.selection;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t\thandleIn = arg1;\n\t\t\t\t\thandleOut = arg2;\n\t\t\t\t\tselection = arg3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\tif (selection)\n\t\t\tthis.setSelection(selection);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar point = this._point,\n\t\t\tselection = this._selection,\n\t\t\tobj = selection || this.hasHandles()\n\t\t\t\t\t? [point, this._handleIn, this._handleOut]\n\t\t\t\t\t: point;\n\t\tif (selection)\n\t\t\tobj.push(selection);\n\t\treturn Base.serialize(obj, options, true, dictionary);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(25);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tthis._point.set(Point.read(arguments));\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tthis._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tthis._handleOut.set(Point.read(arguments));\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tisSmooth: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut;\n\t\treturn !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t&& handleIn.isCollinear(handleOut);\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn._set(0, 0);\n\t\tthis._handleOut._set(0, 0);\n\t},\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tvar oldSelection = this._selection,\n\t\t\tpath = this._path;\n\t\tthis._selection = selection = selection || 0;\n\t\tif (path && selection !== oldSelection) {\n\t\t\tpath._updateSelection(this, oldSelection, selection);\n\t\t\tpath._changed(129);\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._selection & 7);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._changeSelection(7, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tsmooth: function(options, _first, _last) {\n\t\tvar opts = options || {},\n\t\t\ttype = opts.type,\n\t\t\tfactor = opts.factor,\n\t\t\tprev = this.getPrevious(),\n\t\t\tnext = this.getNext(),\n\t\t\tp0 = (prev || this)._point,\n\t\t\tp1 = this._point,\n\t\t\tp2 = (next || this)._point,\n\t\t\td1 = p0.getDistance(p1),\n\t\t\td2 = p1.getDistance(p2);\n\t\tif (!type || type === 'catmull-rom') {\n\t\t\tvar a = factor === undefined ? 0.5 : factor,\n\t\t\t\td1_a = Math.pow(d1, a),\n\t\t\t\td1_2a = d1_a * d1_a,\n\t\t\t\td2_a = Math.pow(d2, a),\n\t\t\t\td2_2a = d2_a * d2_a;\n\t\t\tif (!_first && prev) {\n\t\t\t\tvar A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,\n\t\t\t\t\tN = 3 * d2_a * (d2_a + d1_a);\n\t\t\t\tthis.setHandleIn(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,\n\t\t\t\t\t\t(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t\tif (!_last && next) {\n\t\t\t\tvar A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,\n\t\t\t\t\tN = 3 * d1_a * (d1_a + d2_a);\n\t\t\t\tthis.setHandleOut(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,\n\t\t\t\t\t\t(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t} else if (type === 'geometric') {\n\t\t\tif (prev && next) {\n\t\t\t\tvar vector = p0.subtract(p2),\n\t\t\t\t\tt = factor === undefined ? 0.4 : factor,\n\t\t\t\t\tk = t * d1 / (d1 + d2);\n\t\t\t\tif (!_first)\n\t\t\t\t\tthis.setHandleIn(vector.multiply(k));\n\t\t\t\tif (!_last)\n\t\t\t\t\tthis.setHandleOut(vector.multiply(k - t));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Smoothing method \\'' + type + '\\' not supported.');\n\t\t}\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\ttmp = handleIn.clone();\n\t\thandleIn.set(handleOut);\n\t\thandleOut.set(tmp);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar u = 1 - factor,\n\t\t\tv = factor,\n\t\t\tpoint1 = from._point,\n\t\t\tpoint2 = to._point,\n\t\t\thandleIn1 = from._handleIn,\n\t\t\thandleIn2 = to._handleIn,\n\t\t\thandleOut2 = to._handleOut,\n\t\t\thandleOut1 = from._handleOut;\n\t\tthis._point._set(\n\t\t\t\tu * point1._x + v * point2._x,\n\t\t\t\tu * point1._y + v * point2._y, true);\n\t\tthis._handleIn._set(\n\t\t\t\tu * handleIn1._x + v * handleIn2._x,\n\t\t\t\tu * handleIn1._y + v * handleIn2._y, true);\n\t\tthis._handleOut._set(\n\t\t\t\tu * handleOut1._x + v * handleOut2._x,\n\t\t\t\tu * handleOut1._y + v * handleOut2._y, true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y,\n\t\t\tselected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\t_set: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this._x) && isZero(this._y);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\tvar owner = this._owner;\n\t\treturn this === owner._point ? 1\n\t\t\t: this === owner._handleIn ? 2\n\t\t\t: this === owner._handleOut ? 4\n\t\t\t: 0;\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\tbeans: true,\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (!count) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tclassify: function() {\n\t\treturn Curve.classify(this.getValues());\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tthis._segment1._point.set(Point.read(arguments));\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tthis._segment2._point.set(Point.read(arguments));\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tthis._segment1._handleOut.set(Point.read(arguments));\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tthis._segment2._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._segment1._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t}\n}, {\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tdivideAt: function(location) {\n\t\treturn this.divideAtTime(location && location.curve === this\n\t\t\t\t? location.time : this.getTimeAt(location));\n\t},\n\n\tdivideAtTime: function(time, _setHandles) {\n\t\tvar tMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (time >= tMin && time <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), time),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tseg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tseg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n\t\t\t\tseg2._handleIn._set(right[4] - right[6],right[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(seg1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tthis._changed();\n\t\t\t\tres = new Curve(segment, seg2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar path = this._path;\n\t\treturn path ? path.splitAt(location) : null;\n\t},\n\n\tsplitAtTime: function(time) {\n\t\treturn this.splitAt(this.getLocationAtTime(time));\n\t},\n\n\tdivide: function(offset, isTime) {\n\t\treturn this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\tsplit: function(offset, isTime) {\n\t\treturn this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut._set(0, 0);\n\t\tthis._segment2._handleIn._set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix, straight) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tx1 = p1.x, y1 = p1.y,\n\t\t\tx2 = p2.x, y2 = p2.y,\n\t\t\tvalues = straight\n\t\t\t\t? [ x1, y1, x1, y1, x2, y2, x2, y2 ]\n\t\t\t\t: [\n\t\t\t\t\tx1, y1,\n\t\t\t\t\tx1 + h1._x, y1 + h1._y,\n\t\t\t\t\tx2 + h2._x, y2 + h2._y,\n\t\t\t\t\tx2, y2\n\t\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tx4 = u * x0 + t * x1, y4 = u * y0 + t * y1,\n\t\t\tx5 = u * x1 + t * x2, y5 = u * y1 + t * y2,\n\t\t\tx6 = u * x2 + t * x3, y6 = u * y2 + t * y3,\n\t\t\tx7 = u * x4 + t * x5, y7 = u * y4 + t * y5,\n\t\t\tx8 = u * x5 + t * x6, y8 = u * y5 + t * y6,\n\t\t\tx9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n\t\treturn [\n\t\t\t[x0, y0, x4, y4, x7, y7, x9, y9],\n\t\t\t[x9, y9, x8, y8, x6, y6, x3, y3]\n\t\t];\n\t},\n\n\tgetMonoCurves: function(v, dir) {\n\t\tvar curves = [],\n\t\t\tio = dir ? 0 : 1,\n\t\t\to0 = v[io + 0],\n\t\t\to1 = v[io + 2],\n\t\t\to2 = v[io + 4],\n\t\t\to3 = v[io + 6];\n\t\tif ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)\n\t\t\t\t|| Curve.isStraight(v)) {\n\t\t\tcurves.push(v);\n\t\t} else {\n\t\t\tvar a = 3 * (o1 - o2) - o0 + o3,\n\t\t\t\tb = 2 * (o0 + o2) - 4 * o1,\n\t\t\t\tc = o1 - o0,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [],\n\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\tif (!n) {\n\t\t\t\tcurves.push(v);\n\t\t\t} else {\n\t\t\t\troots.sort();\n\t\t\t\tvar t = roots[0],\n\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\tcurves.push(parts[0]);\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\tcurves.push(parts[0]);\n\t\t\t\t}\n\t\t\t\tcurves.push(parts[1]);\n\t\t\t}\n\t\t}\n\t\treturn curves;\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar v0 = v[coord],\n\t\t\tv1 = v[coord + 2],\n\t\t\tv2 = v[coord + 4],\n\t\t\tv3 = v[coord + 6],\n\t\t\tres = 0;\n\t\tif (  !(v0 < val && v3 < val && v1 < val && v2 < val ||\n\t\t\t\tv0 > val && v3 > val && v1 > val && v2 > val)) {\n\t\t\tvar c = 3 * (v1 - v0),\n\t\t\t\tb = 3 * (v2 - v1) - c,\n\t\t\t\ta = v3 - v0 - c - b;\n\t\t\tres = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n\t\t}\n\t\treturn res;\n\t},\n\n\tgetTimeOf: function(v, point) {\n\t\tvar p0 = new Point(v[0], v[1]),\n\t\t\tp3 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tt = point.isClose(p0, epsilon) ? 0\n\t\t\t  : point.isClose(p3, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t === null) {\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [];\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar u = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, u), geomEpsilon))\n\t\t\t\t\t\treturn u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p0, geomEpsilon) ? 0\n\t\t\t : point.isClose(p3, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestTime: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tvx = x3 - x0, vy = y3 - y0,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getTimeOf(v,\n\t\t\t\t\tnew Point(x0 + u * vx, y0 + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 1e-8) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\tisFlatEnough: function(v, flatness) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tux = 3 * x1 - 2 * x0 - x3,\n\t\t\tuy = 3 * y1 - 2 * y0 - y3,\n\t\t\tvx = 3 * x2 - 2 * x3 - x0,\n\t\t\tvy = 3 * y2 - 2 * y3 - y0;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t<= 16 * flatness * flatness;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)\n\t\t\t\t+ y1 * (x0 - x2) - x1 * (y0 - y2)\n\t\t\t\t+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\n\t\tpadding /= 2;\n\t\tvar minPad = min[coord] - padding,\n\t\t\tmaxPad = max[coord] + padding;\n\t\tif (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||\n\t\t\t\tv0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n\t\t\tif (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n\t\t\t\tadd(v0, padding);\n\t\t\t\tadd(v3, padding);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0,\n\t\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\t\ttMin = 1e-8,\n\t\t\t\t\ttMax = 1 - tMin;\n\t\t\t\tadd(v3, 0);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar t = roots[i],\n\t\t\t\t\t\tu = 1 - t;\n\t\t\t\t\tif (tMin <= t && t <= tMax)\n\t\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\t\tpadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false, this._path);\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(p1, h1, h2, p2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar v = p2.subtract(p1);\n\t\t\tif (v.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n\t\t\t\tvar l = new Line(p1, p2),\n\t\t\t\t\tepsilon = 1e-7;\n\t\t\t\tif (l.getDistance(p1.add(h1)) < epsilon &&\n\t\t\t\t\tl.getDistance(p2.add(h2)) < epsilon) {\n\t\t\t\t\tvar div = v.dot(v),\n\t\t\t\t\t\ts1 = v.dot(h1) / div,\n\t\t\t\t\t\ts2 = v.dot(h2) / div;\n\t\t\t\t\treturn s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(p1, h1, h2, p2) {\n\t\tvar third = p2.subtract(p1).divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function(epsilon) {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,\n\t\t\t\tepsilon);\n\t};\n\n\tthis.statics[name] = function(v, epsilon) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn test(\n\t\t\t\tnew Point(x0, y0),\n\t\t\t\tnew Point(v[2] - x0, v[3] - y0),\n\t\t\t\tnew Point(v[4] - x3, v[5] - y3),\n\t\t\t\tnew Point(x3, y3), epsilon);\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\thasLength: function(epsilon) {\n\t\treturn (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())\n\t\t\t\t&& this.getLength() > (epsilon || 0);\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)\n\t\t\t\t< 1e-8;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)\n\t\t\t\t< 1e-8;\n\t}\n}), {\n\tbeans: false,\n\n\tgetLocationAt: function(offset, _isTime) {\n\t\treturn this.getLocationAtTime(\n\t\t\t\t_isTime ? offset : this.getTimeAt(offset));\n\t},\n\n\tgetLocationAtTime: function(t) {\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetTimeAt: function(offset, start) {\n\t\treturn Curve.getTimeAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterAt: '#getTimeAt',\n\n\tgetOffsetAtTime: function(t) {\n\t\treturn this.getPartLength(0, t);\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetTimeOf: function() {\n\t\treturn Curve.getTimeOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetParameterOf: '#getTimeOf',\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestTime(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(location, _isTime) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, _isTime ? location\n\t\t\t\t\t\t: Curve.getTimeAt(values, location));\n\t\t\t};\n\n\t\t\tthis[name + 'AtTime'] = function(time) {\n\t\t\t\treturn Curve[name](this.getValues(), time);\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\t_evaluateMethods: methods\n\t\t\t}\n\t\t}\n\t);\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\n\t\t\tax = 9 * (x1 - x2) + 3 * (x3 - x0),\n\t\t\tbx = 6 * (x0 + x2) - 12 * x1,\n\t\t\tcx = 3 * (x1 - x0),\n\n\t\t\tay = 9 * (y1 - y2) + 3 * (y3 - y0),\n\t\t\tby = 6 * (y0 + y2) - 12 * y1,\n\t\t\tcy = 3 * (y1 - y0);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tisZero = Numerical.isZero;\n\t\tif (isZero(x1 - x0) && isZero(y1 - y0)) {\n\t\t\tx1 = x0;\n\t\t\ty1 = y0;\n\t\t}\n\t\tif (isZero(x2 - x3) && isZero(y2 - y3)) {\n\t\t\tx2 = x3;\n\t\t\ty2 = y3;\n\t\t}\n\t\tvar cx = 3 * (x1 - x0),\n\t\t\tbx = 3 * (x2 - x1) - cx,\n\t\t\tax = x3 - x0 - cx - bx,\n\t\t\tcy = 3 * (y1 - y0),\n\t\t\tby = 3 * (y2 - y1) - cy,\n\t\t\tay = y3 - y0 - cy - by,\n\t\t\tx, y;\n\t\tif (type === 0) {\n\t\t\tx = t === 0 ? x0 : t === 1 ? x3\n\t\t\t\t\t: ((ax * t + bx) * t + cx) * t + x0;\n\t\t\ty = t === 0 ? y0 : t === 1 ? y3\n\t\t\t\t\t: ((ay * t + by) * t + cy) * t + y0;\n\t\t} else {\n\t\t\tvar tMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t < tMin) {\n\t\t\t\tx = cx;\n\t\t\t\ty = cy;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tx = 3 * (x3 - x2);\n\t\t\t\ty = 3 * (y3 - y2);\n\t\t\t} else {\n\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t}\n\t\t\tif (normalized) {\n\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\tx = x2 - x1;\n\t\t\t\t\ty = y2 - y1;\n\t\t\t\t}\n\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\tif (len) {\n\t\t\t\t\tx /= len;\n\t\t\t\t\ty /= len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type === 3) {\n\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tclassify: function(v) {\n\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\ta1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,\n\t\t\t\ta2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,\n\t\t\t\ta3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,\n\t\t\t\td3 = 3 * a3,\n\t\t\t\td2 = d3 - a2,\n\t\t\t\td1 = d2 - a2 + a1,\n\t\t\t\tl = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),\n\t\t\t\ts = l !== 0 ? 1 / l : 0,\n\t\t\t\tisZero = Numerical.isZero,\n\t\t\t\tserpentine = 'serpentine';\n\t\t\td1 *= s;\n\t\t\td2 *= s;\n\t\t\td3 *= s;\n\n\t\t\tfunction type(type, t1, t2) {\n\t\t\t\tvar hasRoots = t1 !== undefined,\n\t\t\t\t\tt1Ok = hasRoots && t1 > 0 && t1 < 1,\n\t\t\t\t\tt2Ok = hasRoots && t2 > 0 && t2 < 1;\n\t\t\t\tif (hasRoots && (!(t1Ok || t2Ok)\n\t\t\t\t\t\t|| type === 'loop' && !(t1Ok && t2Ok))) {\n\t\t\t\t\ttype = 'arch';\n\t\t\t\t\tt1Ok = t2Ok = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: type,\n\t\t\t\t\troots: t1Ok || t2Ok\n\t\t\t\t\t\t\t? t1Ok && t2Ok\n\t\t\t\t\t\t\t\t? t1 < t2 ? [t1, t2] : [t2, t1]\n\t\t\t\t\t\t\t\t: [t1Ok ? t1 : t2]\n\t\t\t\t\t\t\t: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isZero(d1)) {\n\t\t\t\treturn isZero(d2)\n\t\t\t\t\t\t? type(isZero(d3) ? 'line' : 'quadratic')\n\t\t\t\t\t\t: type(serpentine, d3 / (3 * d2));\n\t\t\t}\n\t\t\tvar d = 3 * d2 * d2 - 4 * d1 * d3;\n\t\t\tif (isZero(d)) {\n\t\t\t\treturn type('cusp', d2 / (2 * d1));\n\t\t\t}\n\t\t\tvar f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),\n\t\t\t\tf2 = 2 * d1;\n\t\t\treturn type(d > 0 ? serpentine : 'loop',\n\t\t\t\t\t(d2 + f1) / f2,\n\t\t\t\t\t(d2 - f1) / f2);\n\t\t},\n\n\t\tgetLength: function(v, a, b, ds) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar c = v;\n\t\t\t\tif (b < 1) {\n\t\t\t\t\tc = Curve.subdivide(c, b)[0];\n\t\t\t\t\ta /= b;\n\t\t\t\t}\n\t\t\t\tif (a > 0) {\n\t\t\t\t\tc = Curve.subdivide(c, a)[1];\n\t\t\t\t}\n\t\t\t\tvar dx = c[6] - c[0],\n\t\t\t\t\tdy = c[7] - c[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\treturn Numerical.integrate(ds || getLengthIntegrand(v), a, b,\n\t\t\t\t\tgetIterations(a, b));\n\t\t},\n\n\t\tgetTimeAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0;\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Curve.getLength(v, a, b, ds),\n\t\t\t\tdiff = abs(offset) - rangeLength;\n\t\t\tif (abs(diff) < epsilon) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (diff > epsilon) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t},\n\n\t\tgetPeaks: function(v) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tax =     -x0 + 3 * x1 - 3 * x2 + x3,\n\t\t\t\tbx =  3 * x0 - 6 * x1 + 3 * x2,\n\t\t\t\tcx = -3 * x0 + 3 * x1,\n\t\t\t\tay =     -y0 + 3 * y1 - 3 * y2 + y3,\n\t\t\t\tby =  3 * y0 - 6 * y1 + 3 * y2,\n\t\t\t\tcy = -3 * y0 + 3 * y1,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [];\n\t\t\tNumerical.solveCubic(\n\t\t\t\t\t9 * (ax * ax + ay * ay),\n\t\t\t\t\t9 * (ax * bx + by * ay),\n\t\t\t\t\t2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),\n\t\t\t\t\t(cx * bx + by * cy),\n\t\t\t\t\troots, tMin, tMax);\n\t\t\treturn roots.sort();\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, include, c1, t1, c2, t2, overlap) {\n\t\tvar excludeStart = !overlap && c1.getPrevious() === c2,\n\t\t\texcludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&\n\t\t\tt1 <= (excludeEnd ? tMax : 1)) {\n\t\t\tif (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&\n\t\t\t\tt2 <= (excludeStart ? tMax : 1)) {\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1, null, overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2, null, overlap);\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc1)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc1, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, include, flip,\n\t\t\trecursion, calls, tMin, tMax, uMin, uMax) {\n\t\tif (++calls >= 4096 || ++recursion >= 40)\n\t\t\treturn calls;\n\t\tvar fatLineEpsilon = 1e-9,\n\t\t\tq0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif (d1 === 0 && d2 === 0\n\t\t\t\t&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0\n\t\t\t|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null\n\t\t\t|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn calls;\n\t\tvar tMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n\t\t\tvar t = (tMinNew + tMaxNew) / 2,\n\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tflip ? c2 : c1, flip ? u : t,\n\t\t\t\t\tflip ? c1 : c2, flip ? t : u);\n\t\t} else {\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tif (tMaxClip - tMinClip > 0.8) {\n\t\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = (tMinNew + tMaxNew) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[0], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, t);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[1], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, t, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[0], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, u, tMinNew, tMaxNew);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[1], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, u, uMax, tMinNew, tMaxNew);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (uMax - uMin >= fatLineEpsilon) {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, include, flip,\n\t\t\t\t\t\t\trecursion, calls, tMinNew, tMaxNew, uMin, uMax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn calls;\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= 0.5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getCurveLineIntersections(v, px, py, vx, vy) {\n\t\tvar isZero = Numerical.isZero;\n\t\tif (isZero(vx) && isZero(vy)) {\n\t\t\tvar t = Curve.getTimeOf(v, new Point(px, py));\n\t\t\treturn t === null ? [] : [t];\n\t\t}\n\t\tvar angle = Math.atan2(-vy, vx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trv = [],\n\t\t\troots = [];\n\t\tfor (var i = 0; i < 8; i += 2) {\n\t\t\tvar x = v[i] - px,\n\t\t\t\ty = v[i + 1] - py;\n\t\t\trv.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tCurve.solveCubic(rv, 1, 0, roots, 0, 1);\n\t\treturn roots;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, include,\n\t\t\tflip) {\n\t\tvar x1 = v2[0], y1 = v2[1],\n\t\t\tx2 = v2[6], y2 = v2[7],\n\t\t\troots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n\t\tfor (var i = 0, l = roots.length; i < l; i++) {\n\t\t\tvar t1 = roots[i],\n\t\t\t\tp1 = Curve.getPoint(v1, t1),\n\t\t\t\tt2 = Curve.getTimeOf(v2, p1);\n\t\t\tif (t2 !== null) {\n\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\tflip ? c2 : c1, flip ? t2 : t1,\n\t\t\t\t\t\tflip ? c1 : c2, flip ? t1 : t2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, include) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, Curve.getTimeOf(v1, pt),\n\t\t\t\t\tc2, Curve.getTimeOf(v2, pt));\n\t\t}\n\t}\n\n\tfunction getCurveIntersections(v1, v2, c1, c2, locations, include) {\n\t\tvar epsilon = 1e-12,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max;\n\n\t\tif (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >\n\t\t\tmin(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmin(v1[0], v1[2], v1[4], v1[6]) - epsilon <\n\t\t\tmax(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmax(v1[1], v1[3], v1[5], v1[7]) + epsilon >\n\t\t\tmin(v2[1], v2[3], v2[5], v2[7]) &&\n\t\t\tmin(v1[1], v1[3], v1[5], v1[7]) - epsilon <\n\t\t\tmax(v2[1], v2[3], v2[5], v2[7])) {\n\t\t\tvar overlaps = getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\tc1, overlap[0],\n\t\t\t\t\t\t\tc2, overlap[1], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tflip = straight1 && !straight2,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tflip ? v2 : v1, flip ? v1 : v2,\n\t\t\t\t\t\t\tflip ? c2 : c1, flip ? c1 : c2,\n\t\t\t\t\t\t\tlocations, include, flip,\n\t\t\t\t\t\t\t0, 0, 0, 1, 0, 1);\n\t\t\t\tif (!straight || locations.length === before) {\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tvar t1 = i >> 1,\n\t\t\t\t\t\t\tt2 = i & 1,\n\t\t\t\t\t\t\ti1 = t1 * 6,\n\t\t\t\t\t\t\ti2 = t2 * 6,\n\t\t\t\t\t\t\tp1 = new Point(v1[i1], v1[i1 + 1]),\n\t\t\t\t\t\t\tp2 = new Point(v2[i2], v2[i2 + 1]);\n\t\t\t\t\t\tif (p1.isClose(p2, epsilon)) {\n\t\t\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\t\t\tc1, t1,\n\t\t\t\t\t\t\t\t\tc2, t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getLoopIntersection(v1, c1, locations, include) {\n\t\tvar info = Curve.classify(v1);\n\t\tif (info.type === 'loop') {\n\t\t\tvar roots = info.roots;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, roots[0],\n\t\t\t\t\tc1, roots[1]);\n\t\t}\n\t  return locations;\n\t}\n\n\tfunction getIntersections(curves1, curves2, include, matrix1, matrix2,\n\t\t\t_returnFirst) {\n\t\tvar self = !curves2;\n\t\tif (self)\n\t\t\tcurves2 = curves1;\n\t\tvar length1 = curves1.length,\n\t\t\tlength2 = curves2.length,\n\t\t\tvalues2 = [],\n\t\t\tarrays = [],\n\t\t\tlocations,\n\t\t\tcurrent;\n\t\tfor (var i = 0; i < length2; i++)\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvar curve1 = curves1[i],\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\tpath1 = curve1.getPath();\n\t\t\tif (path1 !== current) {\n\t\t\t\tcurrent = path1;\n\t\t\t\tlocations = [];\n\t\t\t\tarrays.push(locations);\n\t\t\t}\n\t\t\tif (self) {\n\t\t\t\tgetLoopIntersection(values1, curve1, locations, include);\n\t\t\t}\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\treturn locations;\n\t\t\t\tgetCurveIntersections(values1, values2[j], curve1, curves2[j],\n\t\t\t\t\t\tlocations, include);\n\t\t\t}\n\t\t}\n\t\tlocations = [];\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getOverlaps(v1, v2) {\n\n\t\tfunction getSquaredLineLength(v) {\n\t\t\tvar x = v[6] - v[0],\n\t\t\t\ty = v[7] - v[1];\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tvar abs = Math.abs,\n\t\t\tgetDistance = Line.getDistance,\n\t\t\ttimeEpsilon = 1e-8,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\tstraightBoth = straight1 && straight2,\n\t\t\tflip = getSquaredLineLength(v1) < getSquaredLineLength(v2),\n\t\t\tl1 = flip ? v2 : v1,\n\t\t\tl2 = flip ? v1 : v2,\n\t\t\tpx = l1[0], py = l1[1],\n\t\t\tvx = l1[6] - px, vy = l1[7] - py;\n\t\tif (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&\n\t\t\tgetDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n\t\t\tif (!straightBoth &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {\n\t\t\t\tstraight1 = straight2 = straightBoth = true;\n\t\t\t}\n\t\t} else if (straightBoth) {\n\t\t\treturn null;\n\t\t}\n\t\tif (straight1 ^ straight2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar v = [v1, v2],\n\t\t\tpairs = [];\n\t\tfor (var i = 0; i < 4 && pairs.length < 2; i++) {\n\t\t\tvar i1 = i & 1,\n\t\t\t\ti2 = i1 ^ 1,\n\t\t\t\tt1 = i >> 1,\n\t\t\t\tt2 = Curve.getTimeOf(v[i1], new Point(\n\t\t\t\t\tv[i2][t1 ? 6 : 0],\n\t\t\t\t\tv[i2][t1 ? 7 : 1]));\n\t\t\tif (t2 != null) {\n\t\t\t\tvar pair = i1 ? [t1, t2] : [t2, t1];\n\t\t\t\tif (!pairs.length ||\n\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon) {\n\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && !pairs.length)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pairs.length !== 2) {\n\t\t\tpairs = null;\n\t\t} else if (!straightBoth) {\n\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\tpairs = null;\n\t\t}\n\t\treturn pairs;\n\t}\n\n\treturn {\n\t\tgetIntersections: function(curve) {\n\t\t\tvar v1 = this.getValues(),\n\t\t\t\tv2 = curve && curve !== this && curve.getValues();\n\t\t\treturn v2 ? getCurveIntersections(v1, v2, this, curve, [])\n\t\t\t\t\t  : getLoopIntersection(v1, this, []);\n\t\t},\n\n\t\tstatics: {\n\t\t\tgetOverlaps: getOverlaps,\n\t\t\tgetIntersections: getIntersections,\n\t\t\tgetCurveLineIntersections: getCurveLineIntersections\n\t\t}\n\t};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\n\tinitialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n\t\tif (time >= 0.99999999) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\ttime = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._setCurve(curve);\n\t\tthis._time = time;\n\t\tthis._point = point || curve.getPointAtTime(time);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._previous = null;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tvar path = curve._path;\n\t\tthis._path = path;\n\t\tthis._version = path ? path._version : 0;\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tthis._setCurve(segment.getCurve());\n\t\tthis._segment = segment;\n\t\tthis._time = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar segment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tif (time === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (time != null) {\n\t\t\t\tsegment = curve.getPartLength(0, time)\n\t\t\t\t\t< curve.getPartLength(time, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tthis._time = this._offset = this._curveOffset = this._curve = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn this._curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetTime: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this._time;\n\t\treturn curve && time == null\n\t\t\t? this._time = curve.getTimeOf(this._point)\n\t\t\t: time;\n\t},\n\n\tgetParameter: '#getTime',\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar offset = this._curveOffset;\n\t\tif (offset == null) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tthis._curveOffset = offset = time != null && curve\n\t\t\t\t\t&& curve.getPartLength(0, time);\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = curve && curve.divideAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tpath = curve._path,\n\t\t\tres = curve && curve.splitAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(path.getLastSegment());\n\t\t}\n\t\treturn  res;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc;\n\t\tif (!res && loc instanceof CurveLocation) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tp1 = c1._path,\n\t\t\t\tp2 = c2._path;\n\t\t\tif (p1 === p2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tepsilon = 1e-7,\n\t\t\t\t\tdiff = abs(this.getOffset() - loc.getOffset()),\n\t\t\t\t\ti1 = !_ignoreOther && this._intersection,\n\t\t\t\t\ti2 = !_ignoreOther && loc._intersection;\n\t\t\t\tres = (diff < epsilon\n\t\t\t\t\t\t|| p1 && abs(p1.getLength() - diff) < epsilon)\n\t\t\t\t\t&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar time = this.getTime();\n\t\tif (time != null)\n\t\t\tparts.push('time: ' + f.number(time));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getTime(),\n\t\t\tt2 = inter.getTime(),\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tt1Inside = t1 >= tMin && t1 <= tMax,\n\t\t\tt2Inside = t2 >= tMin && t2 <= tMax;\n\t\tif (t1Inside && t2Inside)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = t1 < tMin ? c2.getPrevious() : c2,\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = t2 < tMin ? c4.getPrevious() : c4;\n\t\tif (t1 > tMax)\n\t\t\tc2 = c2.getNext();\n\t\tif (t2 > tMax)\n\t\t\tc4 = c4.getNext();\n\t\tif (!c1 || !c2 || !c3 || !c4)\n\t\t\treturn false;\n\n\t\tvar offsets = [];\n\n\t\tfunction addOffsets(curve, end) {\n\t\t\tvar v = curve.getValues(),\n\t\t\t\troots = Curve.classify(v).roots || Curve.getPeaks(v),\n\t\t\t\tcount = roots.length,\n\t\t\t\tt = end && count > 1 ? roots[count - 1]\n\t\t\t\t\t\t: count > 0 ? roots[0]\n\t\t\t\t\t\t: 0.5;\n\t\t\toffsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);\n\t\t}\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min || angle < max;\n\t\t}\n\n\t\tif (!t1Inside) {\n\t\t\taddOffsets(c1, true);\n\t\t\taddOffsets(c2, false);\n\t\t}\n\t\tif (!t2Inside) {\n\t\t\taddOffsets(c3, true);\n\t\t\taddOffsets(c4, false);\n\t\t}\n\t\tvar pt = this.getPoint(),\n\t\t\toffset = Math.min.apply(Math, offsets),\n\t\t\tv2 = t1Inside ? c2.getTangentAtTime(t1)\n\t\t\t\t\t: c2.getPointAt(offset).subtract(pt),\n\t\t\tv1 = t1Inside ? v2.negate()\n\t\t\t\t\t: c1.getPointAt(-offset).subtract(pt),\n\t\t\tv4 = t2Inside ? c4.getTangentAtTime(t2)\n\t\t\t\t\t: c4.getPointAt(offset).subtract(pt),\n\t\t\tv3 = t2Inside ? v4.negate()\n\t\t\t\t\t: c3.getPointAt(-offset).subtract(pt),\n\t\t\ta1 = v1.getAngle(),\n\t\t\ta2 = v2.getAngle(),\n\t\t\ta3 = v3.getAngle(),\n\t\t\ta4 = v4.getAngle();\n\t\treturn !!(t1Inside\n\t\t\t\t? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&\n\t\t\t\t  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))\n\t\t\t\t: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&\n\t\t\t\t  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));\n\t},\n\n\thasOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve._evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this.getTime();\n\t\treturn time != null && curve && curve[get](time, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t1e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 !== path2\n\t\t\t\t? path1._id - path2._id\n\t\t\t\t: (loc.getIndex() + loc.getTime())\n\t\t\t\t- (loc2.getIndex() + loc2.getTime());\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\t_selectBounds: false,\n\t_canScaleStroke: true,\n\tbeans: true,\n\n\tinitialize: function PathItem() {\n\t},\n\n\tstatics: {\n\t\tcreate: function(arg) {\n\t\t\tvar data,\n\t\t\t\tsegments,\n\t\t\t\tcompound;\n\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\tsegments = arg.segments;\n\t\t\t\tdata = arg.pathData;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tsegments = arg;\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tdata = arg;\n\t\t\t}\n\t\t\tif (segments) {\n\t\t\t\tvar first = segments[0];\n\t\t\t\tcompound = first && Array.isArray(first[0]);\n\t\t\t} else if (data) {\n\t\t\t\tcompound = (data.match(/m/gi) || []).length > 1\n\t\t\t\t\t\t|| /z\\s*\\S+/i.test(data);\n\t\t\t}\n\t\t\tvar ctor = compound ? CompoundPath : Path;\n\t\t\treturn new ctor(arg);\n\t\t}\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tisClockwise: function() {\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis[move ? 'moveTo' : 'lineTo'](current = getPoint(j));\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\t\tmove = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tcurrent = current.clone();\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(1e-12);\n\t\t\t\tcurrent = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = point.isInside(\n\t\t\t\tthis.getBounds({ internal: true, handle: true }))\n\t\t\t\t\t? this._getWinding(point)\n\t\t\t\t\t: {};\n\t\treturn winding.onPath || !!(this.getFillRule() === 'evenodd'\n\t\t\t\t? winding.windingL & 1 || winding.windingR & 1\n\t\t\t\t: winding.winding);\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix._orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix)._orNullIfIdentity();\n\t\treturn self || this.getBounds(matrix1).intersects(\n\t\t\t\tpath.getBounds(matrix2), 1e-12)\n\t\t\t\t? Curve.getIntersections(\n\t\t\t\t\t\tthis.getCurves(), !self && path.getCurves(), include,\n\t\t\t\t\t\tmatrix1, matrix2, _returnFirst)\n\t\t\t\t: [];\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.hasOverlap() || inter.isCrossing();\n\t\t});\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar isPath = !this._children,\n\t\t\tname = isPath ? '_segments' : '_children',\n\t\t\titemsFrom = from[name],\n\t\t\titemsTo = to[name],\n\t\t\titems = this[name];\n\t\tif (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {\n\t\t\tthrow new Error('Invalid operands in interpolate() call: ' +\n\t\t\t\t\tfrom + ', ' + to);\n\t\t}\n\t\tvar current = items.length,\n\t\t\tlength = itemsTo.length;\n\t\tif (current < length) {\n\t\t\tvar ctor = isPath ? Segment : Path;\n\t\t\tfor (var i = current; i < length; i++) {\n\t\t\t\tthis.add(new ctor());\n\t\t\t}\n\t\t} else if (current > length) {\n\t\t\tthis[isPath ? 'removeSegments' : 'removeChildren'](length, current);\n\t\t}\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titems[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n\t\t}\n\t\tif (isPath) {\n\t\t\tthis.setClosed(from._closed);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tcompare: function(path) {\n\t\tvar ok = false;\n\t\tif (path) {\n\t\t\tvar paths1 = this._children || [this],\n\t\t\t\tpaths2 = path._children ? path._children.slice() : [path],\n\t\t\t\tlength1 = paths1.length,\n\t\t\t\tlength2 = paths2.length,\n\t\t\t\tmatched = [],\n\t\t\t\tcount = 0;\n\t\t\tok = true;\n\t\t\tfor (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {\n\t\t\t\tvar path1 = paths1[i1];\n\t\t\t\tok = false;\n\t\t\t\tfor (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {\n\t\t\t\t\tif (path1.compare(paths2[i2])) {\n\t\t\t\t\t\tif (!matched[i2]) {\n\t\t\t\t\t\t\tmatched[i2] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = ok && count === length2;\n\t\t}\n\t\treturn ok;\n\t},\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar segments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: arguments\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? arguments\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._segmentSelection = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setSegments(source._segments);\n\t\tthis._closed = source._closed;\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tthis._length = this._area = undefined;\n\t\t\tif (flags & 16) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 32) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected(),\n\t\t\tlength = segments && segments.length;\n\t\tthis._segments.length = 0;\n\t\tthis._segmentSelection = 0;\n\t\tthis._curves = undefined;\n\t\tif (length) {\n\t\t\tvar last = segments[length - 1];\n\t\t\tif (typeof last === 'boolean') {\n\t\t\t\tthis.setClosed(last);\n\t\t\t\tlength--;\n\t\t\t}\n\t\t\tthis._add(Segment.readList(segments, 0, {}, length));\n\t\t}\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine) {\n\t\t\t\t\t\tvar dx = curX - prevX,\n\t\t\t\t\t\t\tdy = curY - prevY;\n\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t  dx === 0 ? 'v' + f.number(dy)\n\t\t\t\t\t\t\t: dy === 0 ? 'h' + f.number(dx)\n\t\t\t\t\t\t\t: 'l' + f.pair(dx, dy));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair( inX - prevX,  inY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (!length)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._segments.length;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar segments = this._segments,\n\t\t\tcoords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selection);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tstart = index > 0 && index + amount - 1 === total ? index - 1\n\t\t\t\t\t: index,\n\t\t\t\tinsert = start,\n\t\t\t\tend = Math.min(start + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [start, 0].concat(segs._curves));\n\t\t\t\tinsert += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = insert; i < end; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(start, end);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(start, end) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && !start ? segments.length - 1\n\t\t\t\t: start - 1]) {\n\t\t\tcurve._segment2 = segments[start] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[end]) {\n\t\t\tcurve._segment1 = segments[end];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readList(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readList(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(start, end, _includeCurves) {\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(start, end - start),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, segment._selection, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = start, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = start > 0 && end === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? start - 1\n\t\t\t\t\t: start,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\t\tcurves[i]._path = null;\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tvar area = this._area;\n\t\tif (area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tclosed = this._closed;\n\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar last = i + 1 === l;\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[last ? 0 : i + 1],\n\t\t\t\t\t\tnull, last && !closed));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn area;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this.isSelected() && length > 0 && this._segmentSelection\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelection: function setSelection(selection) {\n\t\tif (!(selection & 1))\n\t\t\tthis._selectSegments(false);\n\t\tsetSelection.base.call(this, selection);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tselection = selected ? 7 : 0;\n\t\tthis._segmentSelection = selection * length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tsegments[i]._selection = selection;\n\t},\n\n\t_updateSelection: function(segment, oldSelection, newSelection) {\n\t\tsegment._selection = newSelection;\n\t\tvar selection = this._segmentSelection += newSelection - oldSelection;\n\t\tif (selection > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tdivideAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tcurve;\n\t\treturn loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))\n\t\t\t\t? curve._segment1\n\t\t\t\t: null;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tindex = loc && loc.index,\n\t\t\ttime = loc && loc.time,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (time > tMax) {\n\t\t\tindex++;\n\t\t\ttime = 0;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (time >= tMin) {\n\t\t\t\tcurves[index++].divideAtTime(time);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.copyAttributes(this);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\tsplit: function(index, time) {\n\t\tvar curve,\n\t\t\tlocation = time === undefined ? index\n\t\t\t\t: (curve = this.getCurves()[index])\n\t\t\t\t\t&& curve.getLocationAtTime(time);\n\t\treturn location != null ? this.splitAt(location) : null;\n\t},\n\n\tjoin: function(path, tolerance) {\n\t\tvar epsilon = tolerance || 0;\n\t\tif (path && path !== this) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.isClose(last2._point, epsilon))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.isClose(first2._point, epsilon)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.isClose(first2._point, epsilon))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.isClose(last2._point, epsilon)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.isClose(last._point, epsilon)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\treduce: function(options) {\n\t\tvar curves = this.getCurves(),\n\t\t\tsimplify = options && options.simplify,\n\t\t\ttolerance = simplify ? 1e-7 : 0;\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (!curve.hasLength(tolerance)\n\t\t\t\t\t|| simplify && curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tthis._changed(9);\n\t},\n\n\tflatten: function(flatness) {\n\t\tvar flattener = new PathFlattener(this, flatness || 0.25, 256, true),\n\t\t\tparts = flattener.parts,\n\t\t\tlength = parts.length,\n\t\t\tsegments = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tsegments.push(new Segment(parts[i].curve.slice(0, 2)));\n\t\t}\n\t\tif (!this._closed && length > 0) {\n\t\t\tsegments.push(new Segment(parts[length - 1].curve.slice(6)));\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tvar segments = new PathFitter(this).fit(tolerance || 2.5);\n\t\tif (segments)\n\t\t\tthis.setSegments(segments);\n\t\treturn !!segments;\n\t},\n\n\tsmooth: function(options) {\n\t\tvar that = this,\n\t\t\topts = options || {},\n\t\t\ttype = opts.type || 'asymmetric',\n\t\t\tsegments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tclosed = this._closed;\n\n\t\tfunction getIndex(value, _default) {\n\t\t\tvar index = value && value.index;\n\t\t\tif (index != null) {\n\t\t\t\tvar path = value.path;\n\t\t\t\tif (path && path !== that)\n\t\t\t\t\tthrow new Error(value._class + ' ' + index + ' of ' + path\n\t\t\t\t\t\t\t+ ' is not part of ' + that);\n\t\t\t\tif (_default && value instanceof Curve)\n\t\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tindex = typeof value === 'number' ? value : _default;\n\t\t\t}\n\t\t\treturn Math.min(index < 0 && closed\n\t\t\t\t\t? index % length\n\t\t\t\t\t: index < 0 ? index + length : index, length - 1);\n\t\t}\n\n\t\tvar loop = closed && opts.from === undefined && opts.to === undefined,\n\t\t\tfrom = getIndex(opts.from, 0),\n\t\t\tto = getIndex(opts.to, length - 1);\n\n\t\tif (from > to) {\n\t\t\tif (closed) {\n\t\t\t\tfrom -= length;\n\t\t\t} else {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t}\n\t\tif (/^(?:asymmetric|continuous)$/.test(type)) {\n\t\t\tvar asymmetric = type === 'asymmetric',\n\t\t\t\tmin = Math.min,\n\t\t\t\tamount = to - from + 1,\n\t\t\t\tn = amount - 1,\n\t\t\t\tpadding = loop ? min(amount, 4) : 1,\n\t\t\t\tpaddingLeft = padding,\n\t\t\t\tpaddingRight = padding,\n\t\t\t\tknots = [];\n\t\t\tif (!closed) {\n\t\t\t\tpaddingLeft = min(1, from);\n\t\t\t\tpaddingRight = min(1, length - to - 1);\n\t\t\t}\n\t\t\tn += paddingLeft + paddingRight;\n\t\t\tif (n <= 1)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {\n\t\t\t\tknots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n\t\t\t}\n\n\t\t\tvar x = knots[0]._x + 2 * knots[1]._x,\n\t\t\t\ty = knots[0]._y + 2 * knots[1]._y,\n\t\t\t\tf = 2,\n\t\t\t\tn_1 = n - 1,\n\t\t\t\trx = [x],\n\t\t\t\try = [y],\n\t\t\t\trf = [f],\n\t\t\t\tpx = [],\n\t\t\t\tpy = [];\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tvar internal = i < n_1,\n\t\t\t\t\ta = internal ? 1 : asymmetric ? 1 : 2,\n\t\t\t\t\tb = internal ? 4 : asymmetric ? 2 : 7,\n\t\t\t\t\tu = internal ? 4 : asymmetric ? 3 : 8,\n\t\t\t\t\tv = internal ? 2 : asymmetric ? 0 : 1,\n\t\t\t\t\tm = a / f;\n\t\t\t\tf = rf[i] = b - m;\n\t\t\t\tx = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n\t\t\t\ty = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n\t\t\t}\n\n\t\t\tpx[n_1] = rx[n_1] / rf[n_1];\n\t\t\tpy[n_1] = ry[n_1] / rf[n_1];\n\t\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\t\tpx[i] = (rx[i] - px[i + 1]) / rf[i];\n\t\t\t\tpy[i] = (ry[i] - py[i + 1]) / rf[i];\n\t\t\t}\n\t\t\tpx[n] = (3 * knots[n]._x - px[n_1]) / 2;\n\t\t\tpy[n] = (3 * knots[n]._y - py[n_1]) / 2;\n\n\t\t\tfor (var i = paddingLeft, max = n - paddingRight, j = from;\n\t\t\t\t\ti <= max; i++, j++) {\n\t\t\t\tvar segment = segments[j < 0 ? j + length : j],\n\t\t\t\t\tpt = segment._point,\n\t\t\t\t\thx = px[i] - pt._x,\n\t\t\t\t\thy = py[i] - pt._y;\n\t\t\t\tif (loop || i < max)\n\t\t\t\t\tsegment.setHandleOut(hx, hy);\n\t\t\t\tif (loop || i > paddingLeft)\n\t\t\t\t\tsegment.setHandleIn(-hx, -hy);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = from; i <= to; i++) {\n\t\t\t\tsegments[i < 0 ? i + length : i].smooth(opts,\n\t\t\t\t\t\t!loop && i === from, !loop && i === to);\n\t\t\t}\n\t\t}\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t});\n\t\t\tshape.copyAttributes(this, true);\n\t\t\tshape._matrix.prepend(this._matrix);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\tif (insert === undefined || insert)\n\t\t\t\tshape.insertAbove(this);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\ttoPath: '#clone',\n\n\tcompare: function compare(path) {\n\t\tif (!path || path instanceof CompoundPath)\n\t\t\treturn compare.base.call(this, path);\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = curves2.length;\n\t\tif (!length1 || !length2) {\n\t\t\treturn length1 == length2;\n\t\t}\n\t\tvar v1 = curves1[0].getValues(),\n\t\t\tvalues2 = [],\n\t\t\tpos1 = 0, pos2,\n\t\t\tend1 = 0, end2;\n\t\tfor (var i = 0; i < length2; i++) {\n\t\t\tvar v2 = curves2[i].getValues();\n\t\t\tvalues2.push(v2);\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tpos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n\t\t\t\tend2 = overlaps[0][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar abs = Math.abs,\n\t\t\tepsilon = 1e-8,\n\t\t\tv2 = values2[pos2],\n\t\t\tstart2;\n\t\twhile (v1 && v2) {\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tvar t1 = overlaps[0][0];\n\t\t\t\tif (abs(t1 - end1) < epsilon) {\n\t\t\t\t\tend1 = overlaps[1][0];\n\t\t\t\t\tif (end1 === 1) {\n\t\t\t\t\t\tv1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n\t\t\t\t\t\tend1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = overlaps[0][1];\n\t\t\t\t\tif (abs(t2 - end2) < epsilon) {\n\t\t\t\t\t\tif (!start2)\n\t\t\t\t\t\t\tstart2 = [pos2, t2];\n\t\t\t\t\t\tend2 = overlaps[1][1];\n\t\t\t\t\t\tif (end2 === 1) {\n\t\t\t\t\t\t\tif (++pos2 >= length2)\n\t\t\t\t\t\t\t\tpos2 = 0;\n\t\t\t\t\t\t\tv2 = values2[pos2] || curves2[pos2].getValues();\n\t\t\t\t\t\t\tend2 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v1) {\n\t\t\t\t\t\t\treturn start2[0] === pos2 && start2[1] === end2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tstrokeRadius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (strokeRadius !== null) {\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tstrokePadding = strokePadding.add(\n\t\t\t\t\tPath._getStrokePadding(strokeRadius, strokeMatrix));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tvar isJoin = closed || segment._index > 0\n\t\t\t\t\t&& segment._index < numSegments - 1;\n\t\t\tif ((isJoin ? join : cap) === 'round') {\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t} else {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (isJoin) {\n\t\t\t\t\tif (!segment.isSmooth()) {\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius,\n\t\t\t\t\t\t\t   miterLimit, null, strokeMatrix, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t} else if (cap === 'square') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, null,\n\t\t\t\t\t\t\tstrokeMatrix, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (strokeRadius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar time = loc.getTime();\n\t\t\t\tif (time === 0 || time === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point)\n\t\t\t\t\t\t\t<= miterLimit * strokeRadius\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar loc = this.getLocationAt(offset);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset) {\n\t\tif (typeof offset === 'number') {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength()) {\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\t}\n\t\t} else if (offset && offset.getPath && offset.getPath() === this) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn null;\n\t}\n\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tvar half = size / 2,\n\t\t\tcoords = new Array(6),\n\t\t\tpX, pY;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tselection = segment._selection;\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tpX = coords[0];\n\t\t\tpY = coords[1];\n\t\t\tif (selection & 2)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (selection & 4)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (!(selection & 1)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar flattener = new PathFlattener(this, 0.25, 32, false,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = flattener.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\tflattener.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (!segments.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar abs = Math.abs,\n\t\t\t\tsqrt = Math.sqrt,\n\t\t\t\tcurrent = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(arguments);\n\t\t\t} else {\n\t\t\t\tvar radius = Size.read(arguments),\n\t\t\t\t\tisZero = Numerical.isZero;\n\t\t\t\tif (isZero(radius.width) || isZero(radius.height))\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq = x * x,\n\t\t\t\t\tySq = y * y;\n\t\t\t\tvar factor = sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1) * sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar epsilon = 1e-7,\n\t\t\t\text = abs(extent),\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = to,\n\t\t\t\t\tout = null;\n\t\t\t\tif (i < count) {\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t}\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(tolerance) {\n\t\t\tthis.setClosed(true);\n\t\t\tthis.join(this, tolerance);\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(matrix, options) {\n\t\tvar method = options.handle\n\t\t\t\t? 'getHandleBounds'\n\t\t\t\t: options.stroke\n\t\t\t\t? 'getStrokeBounds'\n\t\t\t\t: 'getBounds';\n\t\treturn Path[method](this._segments, this._closed, this, matrix, options);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, path, matrix, options, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6)),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = style.hasStroke(),\n\t\t\tstrokeWidth = style.getStrokeWidth(),\n\t\t\tstrokeMatrix = stroke && path._getStrokeMatrix(matrix, options),\n\t\t\tstrokePadding = stroke && Path._getStrokePadding(strokeWidth,\n\t\t\t\tstrokeMatrix),\n\t\t\tbounds = Path.getBounds(segments, closed, path, matrix, options,\n\t\t\t\tstrokePadding);\n\t\tif (!stroke)\n\t\t\treturn bounds;\n\t\tvar strokeRadius = strokeWidth / 2,\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = style.getMiterLimit(),\n\t\t\tjoinBounds = new Rectangle(new Size(strokePadding));\n\n\t\tfunction addPoint(point) {\n\t\t\tbounds = bounds.include(point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(\n\t\t\t\t\tjoinBounds.setCenter(segment._point.transform(matrix)));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tif (join === 'round' || segment.isSmooth()) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius, miterLimit,\n\t\t\t\t\t\tmatrix, strokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, matrix,\n\t\t\t\t\t\tstrokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tvar length = segments.length - (closed ? 0 : 1);\n\t\tfor (var i = 1; i < length; i++)\n\t\t\taddJoin(segments[i], join);\n\t\tif (closed) {\n\t\t\taddJoin(segments[0], join);\n\t\t} else if (length > 0) {\n\t\t\taddCap(segments[0], cap);\n\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getStrokePadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar hor = new Point(radius, 0).transform(matrix),\n\t\t\tver = new Point(0, radius).transform(matrix),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = Math.atan2(b * tan, a),\n\t\t\tty = Math.atan2(b, tan * a);\n\t\treturn [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, matrix,\n\t\t\tstrokeMatrix, addPoint, isArea) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPoint1().transform(matrix),\n\t\t\tnormal1 = curve1.getNormalAtTime(1).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\tnormal2 = curve2.getNormalAtTime(0).multiply(radius)\n\t\t\t\t.transform(strokeMatrix);\n\t\tif (normal1.getDirectedAngle(normal2) < 0) {\n\t\t\tnormal1 = normal1.negate();\n\t\t\tnormal2 = normal2.negate();\n\t\t}\n\t\tif (isArea)\n\t\t\taddPoint(point);\n\t\taddPoint(point.add(normal1));\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(point.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(point.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit * radius) {\n\t\t\t\taddPoint(corner);\n\t\t\t}\n\t\t}\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,\n\t\t\taddPoint, isArea) {\n\t\tvar point = segment._point.transform(matrix),\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal()\n\t\t\t\t\t.multiply(loc.getTime() === 0 ? radius : -radius)\n\t\t\t\t\t.transform(strokeMatrix);\n\t\tif (cap === 'square') {\n\t\t\tif (isArea) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tpoint = point.add(normal.rotate(-90));\n\t\t}\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = options.stroke && style.hasStroke(),\n\t\t\tstrokePadding,\n\t\t\tjoinPadding;\n\t\tif (stroke) {\n\t\t\tvar strokeMatrix = path._getStrokeMatrix(matrix, options),\n\t\t\t\tstrokeRadius = style.getStrokeWidth() / 2,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n\t\t\tstrokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n\t\t\tjoinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n\t\t}\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = !j ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && props.insert == false && Item.NO_INSERT);\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props, { insert: true });\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t], false, arguments);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\tpath = new Path(props && props.insert == false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = sides % 3 === 0,\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\tbeans: true,\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items) {\n\t\tvar list = items,\n\t\t\tfirst = list[0];\n\t\tif (first && typeof first[0] === 'number')\n\t\t\tlist = [list];\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = list[i];\n\t\t\tif (list === items && !(item instanceof Path))\n\t\t\t\tlist = Base.slice(list);\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tlist[i] = new Path({ segments: item, insert: false });\n\t\t\t} else if (item instanceof CompoundPath) {\n\t\t\t\tlist.splice.apply(list, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\treturn insertChildren.base.call(this, index, list);\n\t},\n\n\treduce: function reduce(options) {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce(options);\n\t\t\tif (path.isEmpty())\n\t\t\t\tpath.remove();\n\t\t}\n\t\tif (!children.length) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.copyAttributes(this);\n\t\t\tpath.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClosed: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tif (!children[i]._closed)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].setClosed(closed);\n\t\t}\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t},\n\n\tgetLength: function() {\n\t\tvar children = this._children,\n\t\t\tlength = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tlength += children[i].getLength();\n\t\treturn length;\n\t},\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.appended(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join('');\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\treturn _hitTestChildren.base.call(this, point,\n\t\t\t\toptions.class === Path || options.type === 'path' ? options\n\t\t\t\t\t: Base.set({}, options, { fill: false }),\n\t\t\t\tviewMatrix);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (!children.length)\n\t\t\treturn;\n\n\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\tctx.beginPath();\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectionItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectionItems[child._id]) {\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.appended(mx));\n\t\t\t}\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && !children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\treturn Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',\n\t\t\t'arcBy'],\n\t\tfunction(key) {\n\t\t\tthis[key] = function() {\n\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t};\n\t\t}, {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\n\t\t\tclosePath: function(tolerance) {\n\t\t\t\tgetCurrentPath(this, true).closePath(tolerance);\n\t\t\t}\n\t\t}\n\t);\n}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {\n\tthis[key] = function(param) {\n\t\tvar children = this._children,\n\t\t\tres;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tres = children[i][key](param) || res;\n\t\t}\n\t\treturn res;\n\t};\n}, {}));\n\nPathItem.inject(new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\toperators = {\n\t\t\tunite:     { '1': true, '2': true },\n\t\t\tintersect: { '2': true },\n\t\t\tsubtract:  { '1': true },\n\t\t\texclude:   { '1': true, '-1': true }\n\t\t};\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path.clone(false).reduce({ simplify: true })\n\t\t\t\t.transform(null, true, true);\n\t\treturn resolve\n\t\t\t\t? res.resolveCrossings().reorient(\n\t\t\t\t\tres.getFillRule() === 'nonzero', true)\n\t\t\t\t: res;\n\t}\n\n\tfunction createResult(paths, simplify, path1, path2, options) {\n\t\tvar result = new CompoundPath(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tresult = result.reduce({ simplify: simplify });\n\t\tif (!(options && options.insert == false)) {\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex() ? path2 : path1);\n\t\t}\n\t\tresult.copyAttributes(path1, true);\n\t\treturn result;\n\t}\n\n\tfunction traceBoolean(path1, path2, operation, options) {\n\t\tif (options && (options.trace == false || options.stroke) &&\n\t\t\t\t/^(subtract|intersect)$/.test(operation))\n\t\t\treturn splitBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true),\n\t\t\toperator = operators[operation];\n\t\toperator[operation] = true;\n\t\tif (_path2 && (operator.subtract || operator.exclude)\n\t\t\t\t^ (_path2.isClockwise() ^ _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar crossings = divideLocations(\n\t\t\t\tCurveLocation.expand(_path1.getCrossings(_path2))),\n\t\t\tpaths1 = _path1._children || [_path1],\n\t\t\tpaths2 = _path2 && (_path2._children || [_path2]),\n\t\t\tsegments = [],\n\t\t\tcurves = [],\n\t\t\tpaths;\n\n\t\tfunction collect(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\tcurves.push.apply(curves, path.getCurves());\n\t\t\t\tpath._overlapsOnly = true;\n\t\t\t}\n\t\t}\n\n\t\tif (crossings.length) {\n\t\t\tcollect(paths1);\n\t\t\tif (paths2)\n\t\t\t\tcollect(paths2);\n\t\t\tfor (var i = 0, l = crossings.length; i < l; i++) {\n\t\t\t\tpropagateWinding(crossings[i]._segment, _path1, _path2, curves,\n\t\t\t\t\t\toperator);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i],\n\t\t\t\t\tinter = segment._intersection;\n\t\t\t\tif (!segment._winding) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2, curves, operator);\n\t\t\t\t}\n\t\t\t\tif (!(inter && inter._overlap))\n\t\t\t\t\tsegment._path._overlapsOnly = false;\n\t\t\t}\n\t\t\tpaths = tracePaths(segments, operator);\n\t\t} else {\n\t\t\tpaths = reorientPaths(\n\t\t\t\t\tpaths2 ? paths1.concat(paths2) : paths1.slice(),\n\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\treturn !!operator[w];\n\t\t\t\t\t});\n\t\t}\n\n\t\treturn createResult(paths, true, path1, path2, options);\n\t}\n\n\tfunction splitBoolean(path1, path2, operation) {\n\t\tvar _path1 = preparePath(path1),\n\t\t\t_path2 = preparePath(path2),\n\t\t\tcrossings = _path1.getCrossings(_path2),\n\t\t\tsubtract = operation === 'subtract',\n\t\t\tdivide = operation === 'divide',\n\t\t\tadded = {},\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (!added[path._id] && (divide ||\n\t\t\t\t\t_path2.contains(path.getPointAt(path.getLength() / 2))\n\t\t\t\t\t\t^ subtract)) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn added[path._id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = crossings.length - 1; i >= 0; i--) {\n\t\t\tvar path = crossings[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn createResult(paths, false, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._previous;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._previous)\n\t\t\t\tto = to._previous;\n\t\t\tfrom._next = to;\n\t\t\tto._previous = from;\n\t\t}\n\t}\n\n\tfunction clearCurveHandles(curves) {\n\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\tcurves[i].clearHandles();\n\t}\n\n\tfunction reorientPaths(paths, isInside, clockwise) {\n\t\tvar length = paths && paths.length;\n\t\tif (length) {\n\t\t\tvar lookup = Base.each(paths, function (path, i) {\n\t\t\t\t\tthis[path._id] = {\n\t\t\t\t\t\tcontainer: null,\n\t\t\t\t\t\twinding: path.isClockwise() ? 1 : -1,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t};\n\t\t\t\t}, {}),\n\t\t\t\tsorted = paths.slice().sort(function (a, b) {\n\t\t\t\t\treturn abs(b.getArea()) - abs(a.getArea());\n\t\t\t\t}),\n\t\t\t\tfirst = sorted[0];\n\t\t\tif (clockwise == null)\n\t\t\t\tclockwise = first.isClockwise();\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar path1 = sorted[i],\n\t\t\t\t\tentry1 = lookup[path1._id],\n\t\t\t\t\tpoint = path1.getInteriorPoint(),\n\t\t\t\t\tcontainerWinding = 0;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tvar path2 = sorted[j];\n\t\t\t\t\tif (path2.contains(point)) {\n\t\t\t\t\t\tvar entry2 = lookup[path2._id];\n\t\t\t\t\t\tcontainerWinding = entry2.winding;\n\t\t\t\t\t\tentry1.winding += containerWinding;\n\t\t\t\t\t\tentry1.container = entry2.exclude ? entry2.container\n\t\t\t\t\t\t\t\t: path2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isInside(entry1.winding) === isInside(containerWinding)) {\n\t\t\t\t\tentry1.exclude = true;\n\t\t\t\t\tpaths[entry1.index] = null;\n\t\t\t\t} else {\n\t\t\t\t\tvar container = entry1.container;\n\t\t\t\t\tpath1.setClockwise(container ? !container.isClockwise()\n\t\t\t\t\t\t\t: clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\tfunction divideLocations(locations, include, clearLater) {\n\t\tvar results = include && [],\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tclearHandles = false,\n\t\t\tclearCurves = clearLater || [],\n\t\t\tclearLookup = clearLater && {},\n\t\t\trenormalizeLocs,\n\t\t\tprevCurve,\n\t\t\tprevTime;\n\n\t\tfunction getId(curve) {\n\t\t\treturn curve._path._id + '.' + curve._segment1._index;\n\t\t}\n\n\t\tfor (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {\n\t\t\tvar curve = clearLater[i];\n\t\t\tif (curve._path)\n\t\t\t\tclearLookup[getId(curve)] = true;\n\t\t}\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\ttime = loc._time,\n\t\t\t\torigTime = time,\n\t\t\t\texclude = include && !include(loc),\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tsegment;\n\t\t\tif (curve) {\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tclearHandles = !curve.hasHandles()\n\t\t\t\t\t\t\t|| clearLookup && clearLookup[getId(curve)];\n\t\t\t\t\trenormalizeLocs = [];\n\t\t\t\t\tprevTime = null;\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t} else if (prevTime >= tMin) {\n\t\t\t\t\ttime /= prevTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exclude) {\n\t\t\t\tif (renormalizeLocs)\n\t\t\t\t\trenormalizeLocs.push(loc);\n\t\t\t\tcontinue;\n\t\t\t} else if (include) {\n\t\t\t\tresults.unshift(loc);\n\t\t\t}\n\t\t\tprevTime = origTime;\n\t\t\tif (time < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tvar newCurve = curve.divideAtTime(time, true);\n\t\t\t\tif (clearHandles)\n\t\t\t\t\tclearCurves.push(curve, newCurve);\n\t\t\t\tsegment = newCurve._segment1;\n\t\t\t\tfor (var j = renormalizeLocs.length - 1; j >= 0; j--) {\n\t\t\t\t\tvar l = renormalizeLocs[j];\n\t\t\t\t\tl._time = (l._time - time) / (1 - time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t}\n\t\tif (!clearLater)\n\t\t\tclearCurveHandles(clearCurves);\n\t\treturn results || locations;\n\t}\n\n\tfunction getWinding(point, curves, dir, closed, dontFlip) {\n\t\tvar ia = dir ? 1 : 0,\n\t\t\tio = ia ^ 1,\n\t\t\tpv = [point.x, point.y],\n\t\t\tpa = pv[ia],\n\t\t\tpo = pv[io],\n\t\t\twindingEpsilon = 1e-9,\n\t\t\tqualityEpsilon = 1e-6,\n\t\t\tpaL = pa - windingEpsilon,\n\t\t\tpaR = pa + windingEpsilon,\n\t\t\twindingL = 0,\n\t\t\twindingR = 0,\n\t\t\tpathWindingL = 0,\n\t\t\tpathWindingR = 0,\n\t\t\tonPath = false,\n\t\t\tonAnyPath = false,\n\t\t\tquality = 1,\n\t\t\troots = [],\n\t\t\tvPrev,\n\t\t\tvClose;\n\n\t\tfunction addWinding(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po < min(o0, o3) || po > max(o0, o3)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar a0 = v[ia + 0],\n\t\t\t\ta1 = v[ia + 2],\n\t\t\t\ta2 = v[ia + 4],\n\t\t\t\ta3 = v[ia + 6];\n\t\t\tif (o0 === o3) {\n\t\t\t\tif (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t =   po === o0 ? 0\n\t\t\t\t\t: po === o3 ? 1\n\t\t\t\t\t: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Curve.solveCubic(v, io, po, roots, 0, 1) > 0\n\t\t\t\t\t\t? roots[0]\n\t\t\t\t\t\t: 1,\n\t\t\t\ta =   t === 0 ? a0\n\t\t\t\t\t: t === 1 ? a3\n\t\t\t\t\t: Curve.getPoint(v, t)[dir ? 'y' : 'x'],\n\t\t\t\twinding = o0 > o3 ? 1 : -1,\n\t\t\t\twindingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,\n\t\t\t\ta3Prev = vPrev[ia + 6];\n\t\t\tif (po !== o0) {\n\t\t\t\tif (a < paL) {\n\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t} else if (a > paR) {\n\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t} else {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\tif (a > pa - qualityEpsilon && a < pa + qualityEpsilon)\n\t\t\t\t\tquality /= 2;\n\t\t\t} else {\n\t\t\t\tif (winding !== windingPrev) {\n\t\t\t\t\tif (a0 < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t} else if (a0 > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t}\n\t\t\t\t} else if (a0 != a3Prev) {\n\t\t\t\t\tif (a3Prev < paR && a > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t} else if (a3Prev > paL && a < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquality = 0;\n\t\t\t}\n\t\t\tvPrev = v;\n\t\t\treturn !dontFlip && a > paL && a < paR\n\t\t\t\t\t&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0\n\t\t\t\t\t&& getWinding(point, curves, !dir, closed, true);\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to1 = v[io + 2],\n\t\t\t\to2 = v[io + 4],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n\t\t\t\tvar a0 = v[ia + 0],\n\t\t\t\t\ta1 = v[ia + 2],\n\t\t\t\t\ta2 = v[ia + 4],\n\t\t\t\t\ta3 = v[ia + 6],\n\t\t\t\t\tmonoCurves = paL > max(a0, a1, a2, a3) ||\n\t\t\t\t\t\t\t\t paR < min(a0, a1, a2, a3)\n\t\t\t\t\t\t\t? [v] : Curve.getMonoCurves(v, dir),\n\t\t\t\t\tres;\n\t\t\t\tfor (var i = 0, l = monoCurves.length; i < l; i++) {\n\t\t\t\t\tif (res = addWinding(monoCurves[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i],\n\t\t\t\tpath = curve._path,\n\t\t\t\tv = curve.getValues(),\n\t\t\t\tres;\n\t\t\tif (!i || curves[i - 1]._path !== path) {\n\t\t\t\tvPrev = null;\n\t\t\t\tif (!path._closed) {\n\t\t\t\t\tvClose = Curve.getValues(\n\t\t\t\t\t\t\tpath.getLastCurve().getSegment2(),\n\t\t\t\t\t\t\tcurve.getSegment1(),\n\t\t\t\t\t\t\tnull, !closed);\n\t\t\t\t\tif (vClose[io] !== vClose[io + 6]) {\n\t\t\t\t\t\tvPrev = vClose;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!vPrev) {\n\t\t\t\t\tvPrev = v;\n\t\t\t\t\tvar prev = path.getLastCurve();\n\t\t\t\t\twhile (prev && prev !== curve) {\n\t\t\t\t\t\tvar v2 = prev.getValues();\n\t\t\t\t\t\tif (v2[io] !== v2[io + 6]) {\n\t\t\t\t\t\t\tvPrev = v2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = prev.getPrevious();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res = handleCurve(v))\n\t\t\t\treturn res;\n\n\t\t\tif (i + 1 === l || curves[i + 1]._path !== path) {\n\t\t\t\tif (vClose && (res = handleCurve(vClose)))\n\t\t\t\t\treturn res;\n\t\t\t\tif (onPath && !pathWindingL && !pathWindingR) {\n\t\t\t\t\tpathWindingL = pathWindingR = path.isClockwise(closed) ^ dir\n\t\t\t\t\t\t\t? 1 : -1;\n\t\t\t\t}\n\t\t\t\twindingL += pathWindingL;\n\t\t\t\twindingR += pathWindingR;\n\t\t\t\tpathWindingL = pathWindingR = 0;\n\t\t\t\tif (onPath) {\n\t\t\t\t\tonAnyPath = true;\n\t\t\t\t\tonPath = false;\n\t\t\t\t}\n\t\t\t\tvClose = null;\n\t\t\t}\n\t\t}\n\t\twindingL = abs(windingL);\n\t\twindingR = abs(windingR);\n\t\treturn {\n\t\t\twinding: max(windingL, windingR),\n\t\t\twindingL: windingL,\n\t\t\twindingR: windingR,\n\t\t\tquality: quality,\n\t\t\tonPath: onAnyPath\n\t\t};\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, curves, operator) {\n\t\tvar chain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twinding;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve(),\n\t\t\t\tlength = curve.getLength();\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\ttotalLength += length;\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tvar offsets = [0.5, 0.25, 0.75],\n\t\t\twinding = { winding: 0, quality: -1 },\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tfor (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {\n\t\t\tvar length = totalLength * offsets[i];\n\t\t\tfor (var j = 0, l = chain.length; j < l; j++) {\n\t\t\t\tvar entry = chain[j],\n\t\t\t\t\tcurveLength = entry.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tvar curve = entry.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\toperand = parent instanceof CompoundPath ? parent : path,\n\t\t\t\t\t\tt = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),\n\t\t\t\t\t\tpt = curve.getPointAtTime(t),\n\t\t\t\t\t\tdir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n\t\t\t\t\tvar wind = !(operator.subtract && path2 && (\n\t\t\t\t\t\t\toperand === path1 &&\n\t\t\t\t\t\t\t\tpath2._getWinding(pt, dir, true).winding ||\n\t\t\t\t\t\t\toperand === path2 &&\n\t\t\t\t\t\t\t\t!path1._getWinding(pt, dir, true).winding))\n\t\t\t\t\t\t\t? getWinding(pt, curves, dir, true)\n\t\t\t\t\t\t\t: { winding: 0, quality: 1 };\n\t\t\t\t\tif (wind.quality > winding.quality)\n\t\t\t\t\t\twinding = wind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tfor (var j = chain.length - 1; j >= 0; j--) {\n\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t}\n\n\tfunction tracePaths(segments, operator) {\n\t\tvar paths = [],\n\t\t\tstarts;\n\n\t\tfunction isValid(seg) {\n\t\t\tvar winding;\n\t\t\treturn !!(seg && !seg._visited && (!operator\n\t\t\t\t\t|| operator[(winding = seg._winding || {}).winding]\n\t\t\t\t\t\t&& !(operator.unite && winding.winding === 2\n\t\t\t\t\t\t\t&& winding.windingL && winding.windingR)));\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\tif (seg) {\n\t\t\t\tfor (var i = 0, l = starts.length; i < l; i++) {\n\t\t\t\t\tif (seg === starts[i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction visitPath(path) {\n\t\t\tvar segments = path._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._visited = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCrossingSegments(segment, collectStarts) {\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tstart = inter,\n\t\t\t\tcrossings = [];\n\t\t\tif (collectStarts)\n\t\t\t\tstarts = [segment];\n\n\t\t\tfunction collect(inter, end) {\n\t\t\t\twhile (inter && inter !== end) {\n\t\t\t\t\tvar other = inter._segment,\n\t\t\t\t\t\tpath = other._path,\n\t\t\t\t\t\tnext = other.getNext() || path && path.getFirstSegment(),\n\t\t\t\t\t\tnextInter = next && next._intersection;\n\t\t\t\t\tif (other !== segment && (isStart(other) || isStart(next)\n\t\t\t\t\t\t|| next && (isValid(other) && (isValid(next)\n\t\t\t\t\t\t\t|| nextInter && isValid(nextInter._segment))))) {\n\t\t\t\t\t\tcrossings.push(other);\n\t\t\t\t\t}\n\t\t\t\t\tif (collectStarts)\n\t\t\t\t\t\tstarts.push(other);\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inter) {\n\t\t\t\tcollect(inter);\n\t\t\t\twhile (inter && inter._prev)\n\t\t\t\t\tinter = inter._prev;\n\t\t\t\tcollect(inter, start);\n\t\t\t}\n\t\t\treturn crossings;\n\t\t}\n\n\t\tsegments.sort(function(seg1, seg2) {\n\t\t\tvar inter1 = seg1._intersection,\n\t\t\t\tinter2 = seg2._intersection,\n\t\t\t\tover1 = !!(inter1 && inter1._overlap),\n\t\t\t\tover2 = !!(inter2 && inter2._overlap),\n\t\t\t\tpath1 = seg1._path,\n\t\t\t\tpath2 = seg2._path;\n\t\t\treturn over1 ^ over2\n\t\t\t\t\t? over1 ? 1 : -1\n\t\t\t\t\t: !inter1 ^ !inter2\n\t\t\t\t\t\t? inter1 ? 1 : -1\n\t\t\t\t\t\t: path1 !== path2\n\t\t\t\t\t\t\t? path1._id - path2._id\n\t\t\t\t\t\t\t: seg1._index - seg2._index;\n\t\t});\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tvalid = isValid(seg),\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false,\n\t\t\t\tclosed = true,\n\t\t\t\tbranches = [],\n\t\t\t\tbranch,\n\t\t\t\tvisited,\n\t\t\t\thandleIn;\n\t\t\tif (valid && seg._path._overlapsOnly) {\n\t\t\t\tvar path1 = seg._path,\n\t\t\t\t\tpath2 = seg._intersection._segment._path;\n\t\t\t\tif (path1.compare(path2)) {\n\t\t\t\t\tif (path1.getArea())\n\t\t\t\t\t\tpaths.push(path1.clone(false));\n\t\t\t\t\tvisitPath(path1);\n\t\t\t\t\tvisitPath(path2);\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (valid) {\n\t\t\t\tvar first = !path,\n\t\t\t\t\tcrossings = getCrossingSegments(seg, first),\n\t\t\t\t\tother = crossings.shift(),\n\t\t\t\t\tfinished = !first && (isStart(seg) || isStart(other)),\n\t\t\t\t\tcross = !finished && other;\n\t\t\t\tif (first) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tif (seg.isFirst() || seg.isLast())\n\t\t\t\t\t\tclosed = seg._path._closed;\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cross && branch) {\n\t\t\t\t\tbranches.push(branch);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (!branch) {\n\t\t\t\t\tif (cross)\n\t\t\t\t\t\tcrossings.push(seg);\n\t\t\t\t\tbranch = {\n\t\t\t\t\t\tstart: path._segments.length,\n\t\t\t\t\t\tcrossings: crossings,\n\t\t\t\t\t\tvisited: visited = [],\n\t\t\t\t\t\thandleIn: handleIn\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (cross)\n\t\t\t\t\tseg = other;\n\t\t\t\tif (!isValid(seg)) {\n\t\t\t\t\tpath.removeSegments(branch.start);\n\t\t\t\t\tfor (var j = 0, k = visited.length; j < k; j++) {\n\t\t\t\t\t\tvisited[j]._visited = false;\n\t\t\t\t\t}\n\t\t\t\t\tvisited.length = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tseg = branch && branch.crossings.shift();\n\t\t\t\t\t\tif (!seg) {\n\t\t\t\t\t\t\tbranch = branches.pop();\n\t\t\t\t\t\t\tif (branch) {\n\t\t\t\t\t\t\t\tvisited = branch.visited;\n\t\t\t\t\t\t\t\thandleIn = branch.handleIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (branch && !isValid(seg));\n\t\t\t\t\tif (!seg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar next = seg.getNext();\n\t\t\t\tpath.add(new Segment(seg._point, handleIn,\n\t\t\t\t\t\tnext && seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tvisited.push(seg);\n\t\t\t\tseg = next || seg._path.getFirstSegment();\n\t\t\t\thandleIn = next && next._handleIn;\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(handleIn);\n\t\t\t\t\tpath.setClosed(closed);\n\t\t\t\t}\n\t\t\t\tif (path.getArea() !== 0) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, dir, closed) {\n\t\t\treturn getWinding(point, this.getCurves(), dir, closed);\n\t\t},\n\n\t\tunite: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'unite', options);\n\t\t},\n\n\t\tintersect: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'intersect', options);\n\t\t},\n\n\t\tsubtract: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'subtract', options);\n\t\t},\n\n\t\texclude: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'exclude', options);\n\t\t},\n\n\t\tdivide: function(path, options) {\n\t\t\treturn options && (options.trace == false || options.stroke)\n\t\t\t\t\t? splitBoolean(this, path, 'divide')\n\t\t\t\t\t: createResult([\n\t\t\t\t\t\tthis.subtract(path, options),\n\t\t\t\t\t\tthis.intersect(path, options)\n\t\t\t\t\t], true, this, path, options);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = children || [this];\n\n\t\t\tfunction hasOverlap(seg) {\n\t\t\t\tvar inter = seg && seg._intersection;\n\t\t\t\treturn inter && inter._overlap;\n\t\t\t}\n\n\t\t\tvar hasOverlaps = false,\n\t\t\t\thasCrossings = false,\n\t\t\t\tintersections = this.getIntersections(null, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap() && (hasOverlaps = true) ||\n\t\t\t\t\t\t\tinter.isCrossing() && (hasCrossings = true);\n\t\t\t\t}),\n\t\t\t\tclearCurves = hasOverlaps && hasCrossings && [];\n\t\t\tintersections = CurveLocation.expand(intersections);\n\t\t\tif (hasOverlaps) {\n\t\t\t\tvar overlaps = divideLocations(intersections, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap();\n\t\t\t\t}, clearCurves);\n\t\t\t\tfor (var i = overlaps.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar seg = overlaps[i]._segment,\n\t\t\t\t\t\tprev = seg.getPrevious(),\n\t\t\t\t\t\tnext = seg.getNext();\n\t\t\t\t\tif (hasOverlap(prev) && hasOverlap(next)) {\n\t\t\t\t\t\tseg.remove();\n\t\t\t\t\t\tprev._handleOut._set(0, 0);\n\t\t\t\t\t\tnext._handleIn._set(0, 0);\n\t\t\t\t\t\tif (prev !== seg && !prev.getCurve().hasLength()) {\n\t\t\t\t\t\t\tnext._handleIn.set(prev._handleIn);\n\t\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCrossings) {\n\t\t\t\tdivideLocations(intersections, hasOverlaps && function(inter) {\n\t\t\t\t\tvar curve1 = inter.getCurve(),\n\t\t\t\t\t\tseg1 = inter.getSegment(),\n\t\t\t\t\t\tother = inter._intersection,\n\t\t\t\t\t\tcurve2 = other._curve,\n\t\t\t\t\t\tseg2 = other._segment;\n\t\t\t\t\tif (curve1 && curve2 && curve1._path && curve2._path)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (seg1)\n\t\t\t\t\t\tseg1._intersection = null;\n\t\t\t\t\tif (seg2)\n\t\t\t\t\t\tseg2._intersection = null;\n\t\t\t\t}, clearCurves);\n\t\t\t\tif (clearCurves)\n\t\t\t\t\tclearCurveHandles(clearCurves);\n\t\t\t\tpaths = tracePaths(Base.each(paths, function(path) {\n\t\t\t\t\tthis.push.apply(this, path._segments);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\tvar length = paths.length,\n\t\t\t\titem;\n\t\t\tif (length > 1 && children) {\n\t\t\t\tif (paths !== children)\n\t\t\t\t\tthis.setChildren(paths);\n\t\t\t\titem = this;\n\t\t\t} else if (length === 1 && !children) {\n\t\t\t\tif (paths[0] !== this)\n\t\t\t\t\tthis.setSegments(paths[0].removeSegments());\n\t\t\t\titem = this;\n\t\t\t}\n\t\t\tif (!item) {\n\t\t\t\titem = new CompoundPath(Item.NO_INSERT);\n\t\t\t\titem.addChildren(paths);\n\t\t\t\titem = item.reduce();\n\t\t\t\titem.copyAttributes(this);\n\t\t\t\tthis.replaceWith(item);\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\n\t\treorient: function(nonZero, clockwise) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && children.length) {\n\t\t\t\tthis.setChildren(reorientPaths(this.removeChildren(),\n\t\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\t\treturn !!(nonZero ? w : w & 1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclockwise));\n\t\t\t} else if (clockwise !== undefined) {\n\t\t\t\tthis.setClockwise(clockwise);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\ty = point.y,\n\t\t\t\t\tintercepts = [],\n\t\t\t\t\troots = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar v = curves[i].getValues(),\n\t\t\t\t\t\to0 = v[1],\n\t\t\t\t\t\to1 = v[3],\n\t\t\t\t\t\to2 = v[5],\n\t\t\t\t\t\to3 = v[7];\n\t\t\t\t\tif (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n\t\t\t\t\t\tvar monoCurves = Curve.getMonoCurves(v);\n\t\t\t\t\t\tfor (var j = 0, m = monoCurves.length; j < m; j++) {\n\t\t\t\t\t\t\tvar mv = monoCurves[j],\n\t\t\t\t\t\t\t\tmo0 = mv[1],\n\t\t\t\t\t\t\t\tmo3 = mv[7];\n\t\t\t\t\t\t\tif ((mo0 !== mo3) &&\n\t\t\t\t\t\t\t\t(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){\n\t\t\t\t\t\t\t\tvar x = y === mo0 ? mv[0]\n\t\t\t\t\t\t\t\t\t: y === mo3 ? mv[6]\n\t\t\t\t\t\t\t\t\t: Curve.solveCubic(mv, 1, y, roots, 0, 1)\n\t\t\t\t\t\t\t\t\t\t=== 1\n\t\t\t\t\t\t\t\t\t\t? Curve.getPoint(mv, roots[0]).x\n\t\t\t\t\t\t\t\t\t\t: (mv[0] + mv[6]) / 2;\n\t\t\t\t\t\t\t\tintercepts.push(x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (intercepts.length > 1) {\n\t\t\t\t\tintercepts.sort(function(a, b) { return a - b; });\n\t\t\t\t\tpoint.x = (intercepts[0] + intercepts[1]) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point;\n\t\t}\n\t};\n});\n\nvar PathFlattener = Base.extend({\n\t_class: 'PathFlattener',\n\n\tinitialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminSpan = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, t1, t2) {\n\t\t\tif ((t2 - t1) > minSpan\n\t\t\t\t\t&& !(ignoreStraight && Curve.isStraight(curve))\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, flatness || 0.25)) {\n\t\t\t\tvar halves = Curve.subdivide(curve, 0.5),\n\t\t\t\t\ttMid = (t1 + t2) / 2;\n\t\t\t\tcomputeParts(halves[0], index, t1, tMid);\n\t\t\t\tcomputeParts(halves[1], index, tMid, t2);\n\t\t\t} else {\n\t\t\t\tvar dx = curve[6] - curve[0],\n\t\t\t\t\tdy = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tif (dist > 0) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tcurve: curve,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttime: t2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\t_get: function(offset) {\n\t\tvar parts = this.parts,\n\t\t\tlength = parts.length,\n\t\t\tstart,\n\t\t\ti, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (!j || parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\tvar part = parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = parts[i - 1],\n\t\t\t\t\tprevTime = prev && prev.index === part.index ? prev.time : 0,\n\t\t\t\t\tprevOffset = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tindex: part.index,\n\t\t\t\t\ttime: prevTime + (part.time - prevTime)\n\t\t\t\t\t\t* (offset - prevOffset) / (part.offset - prevOffset)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tindex: parts[length - 1].index,\n\t\t\ttime: 1\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tvar start = this._get(from),\n\t\t\tend = this._get(to);\n\t\tfor (var i = start.index, l = end.index; i <= l; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti === start.index ? start.time : 0,\n\t\t\t\t\ti === end.index ? end.time : 1);\n\t\t\tif (i === start.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar param = this._get(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.time);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tclosed = path._closed;\n\t\tfor (var i = 0, prev, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point;\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(prev = point.clone());\n\t\t\t}\n\t\t}\n\t\tif (closed) {\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\t\tthis.closed = closed;\n\t},\n\n\tfit: function(error) {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = null;\n\t\tif (length > 0) {\n\t\t\tsegments = [new Segment(points[0])];\n\t\t\tif (length > 1) {\n\t\t\t\tthis.fitCubic(segments, error, 0, length - 1,\n\t\t\t\t\t\tpoints[1].subtract(points[0]),\n\t\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]));\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tsegments.shift();\n\t\t\t\t\tsegments.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(segments, error, first, last, tan1, tan2) {\n\t\tvar points = this.points;\n\t\tif (last - first === 1) {\n\t\t\tvar pt1 = points[first],\n\t\t\t\tpt2 = points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(error, error * error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < error && parametersInOrder) {\n\t\t\t\tthis.addCurve(segments, curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar tanCenter = points[split - 1].subtract(points[split + 1]);\n\t\tthis.fitCubic(segments, error, first, split, tan1, tanCenter);\n\t\tthis.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(segments, curve) {\n\t\tvar prev = segments[segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tsegments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tabs = Math.abs,\n\t\t\tpoints = this.points,\n\t\t\tpt1 = points[first],\n\t\t\tpt2 = points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1,\n\t\t\talpha2;\n\t\tif (abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\talpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0\n\t\t\t\t\t\t\t: abs(c1) > epsilon ? X[1] / c1\n\t\t\t\t\t\t\t: 0;\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1,\n\t\t\t\tpt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)),\n\t\t\t\tpt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\treturn Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsOptions: { stroke: false, handle: false },\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setContent(source._content);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(265);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\tvar lines = this._lines,\n\t\t\tstyle = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar rect = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(rect, rect) : rect;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tcolorCache = {},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tcomponents = [0, 0, 0];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\tcomponents = match[1].split(',');\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar value = +components[i];\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t}\n\t\t} else if (window) {\n\t\t\tvar cached = colorCache[string];\n\t\t\tif (!cached) {\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\tdata[2] / 255\n\t\t\t\t];\n\t\t\t}\n\t\t\tcomponents = cached.slice();\n\t\t} else {\n\t\t\tcomponents = [0, 0, 0];\n\t\t}\n\t\treturn components;\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t? function(value) {\n\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t};\n\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar args = arguments,\n\t\t\t\treading = this.__read,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (reading)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = Base.slice(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (reading) {\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = Base.slice(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && !i && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (reading && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (reading)\n\t\t\t\tthis.__read = read;\n\t\t\treturn this;\n\t\t},\n\n\t\tset: '#initialize',\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this.getAlpha() === col.getAlpha()\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx, matrix) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\thighlight = components[3],\n\t\t\t\tinverse = matrix && matrix.inverted(),\n\t\t\t\tcanvasGradient;\n\t\t\tif (inverse) {\n\t\t\t\torigin = inverse._transformPoint(origin);\n\t\t\t\tdestination = inverse._transformPoint(destination);\n\t\t\t\tif (highlight)\n\t\t\t\t\thighlight = inverse._transformPoint(highlight);\n\t\t\t}\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin);\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tcanvasGradient.addColorStop(\n\t\t\t\t\t\toffset == null ? i / (l - 1) : offset,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && Base.isPlainObject(stops)) {\n\t\t\tthis.set(stops);\n\t\t\tstops = radial = null;\n\t\t}\n\t\tif (this._stops == null) {\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t}\n\t\tif (this._radial == null) {\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t\t}\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++) {\n\t\t\tthis._owners[i]._changed();\n\t\t}\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (!this._owners.length)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tstops[i] = this._stops[i].clone();\n\t\t}\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t}\n\t\tvar _stops = this._stops;\n\t\tif (_stops) {\n\t\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t\t_stops[i]._owner = undefined;\n\t\t}\n\t\t_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t_stops[i]._owner = this;\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class) {\n\t\t\tvar stops1 = this._stops,\n\t\t\t\tstops2 = gradient._stops,\n\t\t\t\tlength = stops1.length;\n\t\t\tif (length === stops2.length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (!stops1[i].equals(stops2[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tvar color = arg0,\n\t\t\toffset = arg1;\n\t\tif (typeof arg0 === 'object' && arg1 === undefined) {\n\t\t\tif (Array.isArray(arg0) && typeof arg0[0] !== 'number') {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\toffset = arg0[1];\n\t\t\t} else if ('color' in arg0 || 'offset' in arg0\n\t\t\t\t\t|| 'rampPoint' in arg0) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\toffset = arg0.offset || arg0.rampPoint || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setColor(color);\n\t\tthis.setOffset(offset);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._offset);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar color = this._color,\n\t\t\toffset = this._offset;\n\t\treturn Base.serialize(offset == null ? [color] : [color, offset],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(65);\n\t},\n\n\tgetOffset: function() {\n\t\treturn this._offset;\n\t},\n\n\tsetOffset: function(offset) {\n\t\tthis._offset = offset;\n\t\tthis._changed();\n\t},\n\n\tgetRampPoint: '#getOffset',\n\tsetRampPoint: '#setOffset',\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function() {\n\t\tvar color = Color.read(arguments, 0, { clone: true });\n\t\tif (color)\n\t\t\tcolor._owner = this;\n\t\tthis._color = color;\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._offset == stop._offset\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar itemDefaults = {\n\t\tfillColor: null,\n\t\tfillRule: 'nonzero',\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\tshadowColor: null,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: null\n\t},\n\tgroupDefaults = Base.set({}, itemDefaults, {\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tleading: null,\n\t\tjustification: 'left'\n\t}),\n\ttextDefaults = Base.set({}, groupDefaults, {\n\t\tfillColor: new Color()\n\t}),\n\tflags = {\n\t\tstrokeWidth: 97,\n\t\tstrokeCap: 97,\n\t\tstrokeJoin: 97,\n\t\tstrokeScaling: 105,\n\t\tmiterLimit: 97,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t},\n\titem = {\n\t\tbeans: true\n\t},\n\tfields = {\n\t\t_class: 'Style',\n\t\tbeans: true,\n\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project\n\t\t\t\t\t|| paper.project;\n\t\t\tthis._defaults = !_owner || _owner instanceof Group ? groupDefaults\n\t\t\t\t\t: _owner instanceof TextItem ? textDefaults\n\t\t\t\t\t: itemDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t}\n\t};\n\n\tBase.each(groupDefaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children;\n\t\t\tif (children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t} else if (key in this._defaults) {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old && old._owner !== undefined)\n\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tvalue;\n\t\t\tif (key in this._defaults && (!children || !children.length\n\t\t\t\t\t|| _dontMerge || owner instanceof CompoundPath)) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tBase.each({\n\t\tFont: 'FontFamily',\n\t\tWindingRule: 'FillRule'\n\t}, function(value, key) {\n\t\tvar get = 'get' + key,\n\t\t\tset = 'set' + key;\n\t\tfields[get] = item[get] = '#get' + value;\n\t\tfields[set] = item[set] = '#set' + value;\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\tfunction compare(style1, style2, secondary) {\n\t\t\tvar values1 = style1._values,\n\t\t\t\tvalues2 = style2._values,\n\t\t\t\tdefaults2 = style2._defaults;\n\t\t\tfor (var key in values1) {\n\t\t\t\tvar value1 = values1[key],\n\t\t\t\t\tvalue2 = values2[key];\n\t\t\t\tif (!(secondary && key in values2) && !Base.equals(value1,\n\t\t\t\t\t\tvalue2 === undefined ? defaults2[key] : value2))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& compare(this, style)\n\t\t\t\t&& compare(style, this, true)\n\t\t\t\t|| false;\n\t},\n\n\thasFill: function() {\n\t\tvar color = this.getFillColor();\n\t\treturn !!color && color.alpha > 0;\n\t},\n\n\thasStroke: function() {\n\t\tvar color = this.getStrokeColor();\n\t\treturn !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\tvar color = this.getShadowColor();\n\t\treturn !!color && color.alpha > 0 && (this.getShadowBlur() > 0\n\t\t\t\t|| !this.getShadowOffset().isZero());\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tisInserted: function(el) {\n\t\t\treturn document.body.contains(el);\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn el && handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\ttimer;\n\n\tfunction handleCallbacks() {\n\t\tvar functions = callbacks;\n\t\tcallbacks = [];\n\t\tfor (var i = 0, l = functions.length; i < l; i++)\n\t\t\tfunctions[i]();\n\t\trequested = nativeRequest && callbacks.length;\n\t\tif (requested)\n\t\t\tnativeRequest(handleCallbacks);\n\t}\n\n\treturn function(callback) {\n\t\tcallbacks.push(callback);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t}\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t}\n\n\t\tvar size;\n\t\tif (window && element) {\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserDrag: none,\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsize = getCanvasSize();\n\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = new Size(element);\n\t\t\telement = null;\n\t\t}\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window && window.devicePixelRatio || 1;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize = size;\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t\tthis._itemEvents = { native: {}, virtual: {} };\n\t\tthis._autoUpdate = !paper.agent.node;\n\t\tthis._needsUpdate = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tvar project = this._project;\n\t\tif (project._view === this)\n\t\t\tproject._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(\n\t\tItem._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),\n\t\tfunction(name) {\n\t\t\tthis[name] = {};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\tgetAutoUpdate: function() {\n\t\treturn this._autoUpdate;\n\t},\n\n\tsetAutoUpdate: function(autoUpdate) {\n\t\tthis._autoUpdate = autoUpdate;\n\t\tif (autoUpdate)\n\t\t\tthis.requestUpdate();\n\t},\n\n\tupdate: function() {\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\trequestUpdate: function() {\n\t\tif (!this._requested) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (that._animate) {\n\t\t\t\t\tthat.requestUpdate();\n\t\t\t\t\tvar element = that._element;\n\t\t\t\t\tif ((!DomElement.getPrefixed(document, 'hidden')\n\t\t\t\t\t\t\t|| PaperScope.getAttribute(element, 'keepalive')\n\t\t\t\t\t\t\t\t=== 'true') && DomElement.isInView(element)) {\n\t\t\t\t\t\tthat._handleFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (that._autoUpdate)\n\t\t\t\t\tthat.update();\n\t\t\t});\n\t\t\tthis._requested = true;\n\t\t}\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tthis.requestUpdate();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._last ? now - this._last : 0;\n\t\tthis._last = now;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tthis._project._changed(2049);\n\t\tthis._bounds = this._decomposed = undefined;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize.set(size);\n\t\tthis._changed();\n\t\tthis.emit('resize', { size: size, delta: delta });\n\t\tif (this._autoUpdate) {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_setElementSize: function(width, height) {\n\t\tvar element = this._element;\n\t\tif (element) {\n\t\t\tif (element.width !== width)\n\t\t\t\telement.width = width;\n\t\t\tif (element.height !== height)\n\t\t\t\telement.height = height;\n\t\t}\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tisInserted: function() {\n\t\treturn DomElement.isInserted(this._element);\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixels;\n\t\tif (element) {\n\t\t\tvar parent = element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tpixels = parseFloat(pixels);\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\treturn 0;\n\t}\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getCenter(true)));\n\t};\n}, {\n\t_decompose: function() {\n\t\treturn this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.translate(this.getCenter().subtract(center));\n\t},\n\n\tgetZoom: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling ? (scaling.x + scaling.y) / 2 : 0;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis.transform(new Matrix().scale(zoom / this.getZoom(),\n\t\t\tthis.getCenter()));\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed && decomposed.rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tthis.rotate(rotation - current);\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling\n\t\t\t\t? new LinkedPoint(scaling.x, scaling.y, this, 'setScaling')\n\t\t\t\t: undefined;\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling) {\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._matrix.append(matrix);\n\t},\n\n\tscrollBy: function() {\n\t\tthis.translate(Point.read(arguments).negate());\n\t}\n}), {\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tgetEventPoint: function(event) {\n\t\treturn this.viewToProject(DomEvent.getOffset(event, this._element));\n\t},\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (document && typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\tvar ctor = window ? CanvasView : View;\n\t\t\treturn new ctor(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tif (!window)\n\t\treturn;\n\tvar prevFocus,\n\t\ttempFocus,\n\t\tdragging = false,\n\t\tmouseDown = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[\n\t\t\t\ttarget.getAttribute('id')];\n\t}\n\n\tfunction updateFocus() {\n\t\tvar view = View._focused;\n\t\tif (!view || !view.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tif ((view = View._views[i]).isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, event, point) {\n\t\tview._handleMouseEvent('mousemove', event, point);\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {},\n\t\tdocEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML')) {\n\t\t\t\t\tvar offset = DomEvent.getOffset(event, view._element),\n\t\t\t\t\t\tx = offset.x,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\tax = abs(x),\n\t\t\t\t\t\tmax = 1 << 25,\n\t\t\t\t\t\tdiff = ax - max;\n\t\t\t\t\toffset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n\t\t\t\t\thandleMouseMove(view, event, view.viewToProject(offset));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tscroll: updateFocus\n\t\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event);\n\t\tif (!dragging) {\n\t\t\tdragging = true;\n\t\t\tview._handleMouseEvent('mousedown', event);\n\t\t}\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!mouseDown) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target) {\n\t\t\t\t\tif (view)\n\t\t\t\t\t\thandleMouseMove(view, event);\n\t\t\t\t\tif (!prevFocus)\n\t\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t}\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tif (prevFocus && !prevFocus.isInserted())\n\t\t\t\t\tprevFocus = null;\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tprevFocus = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view)\n\t\t\thandleMouseMove(view, event);\n\t};\n\n\tdocEvents[mousedown] = function() {\n\t\tmouseDown = true;\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (view && dragging)\n\t\t\tview._handleMouseEvent('mouseup', event);\n\t\tmouseDown = dragging = false;\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar called = false,\n\t\tprevented = false,\n\t\tfallbacks = {\n\t\t\tdoubleclick: 'click',\n\t\t\tmousedrag: 'mousemove'\n\t\t},\n\t\twasInView = false,\n\t\toverView,\n\t\tdownPoint,\n\t\tlastPoint,\n\t\tdownItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tclickItem,\n\t\tclickTime,\n\t\tdblClick;\n\n\tfunction emitMouseEvent(obj, target, type, event, point, prevPoint,\n\t\t\tstopItem) {\n\t\tvar stopped = false,\n\t\t\tmouseEvent;\n\n\t\tfunction emit(obj, type) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point,\n\t\t\t\t\t\t\ttarget || obj,\n\t\t\t\t\t\t\tprevPoint ? point.subtract(prevPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent)) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif (mouseEvent.prevented)\n\t\t\t\t\t\tprevented = true;\n\t\t\t\t\tif (mouseEvent.stopped)\n\t\t\t\t\t\treturn stopped = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar fallback = fallbacks[type];\n\t\t\t\tif (fallback)\n\t\t\t\t\treturn emit(obj, fallback);\n\t\t\t}\n\t\t}\n\n\t\twhile (obj && obj !== stopItem) {\n\t\t\tif (emit(obj, type))\n\t\t\t\tbreak;\n\t\t\tobj = obj._parent;\n\t\t}\n\t\treturn stopped;\n\t}\n\n\tfunction emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n\t\tview._project.removeOn(type);\n\t\tprevented = called = false;\n\t\treturn (dragItem && emitMouseEvent(dragItem, null, type, event,\n\t\t\t\t\tpoint, prevPoint)\n\t\t\t|| hitItem && hitItem !== dragItem\n\t\t\t\t&& !hitItem.isDescendant(dragItem)\n\t\t\t\t&& emitMouseEvent(hitItem, null, type, event, point, prevPoint,\n\t\t\t\t\tdragItem)\n\t\t\t|| emitMouseEvent(view, dragItem || hitItem || view, type, event,\n\t\t\t\t\tpoint, prevPoint));\n\t}\n\n\tvar itemEventsMap = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleMouseEvent: function(type, event, point) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\thitItems = itemEvents.native[type],\n\t\t\t\tnativeMove = type === 'mousemove',\n\t\t\t\ttool = this._scope.tool,\n\t\t\t\tview = this;\n\n\t\t\tfunction responds(type) {\n\t\t\t\treturn itemEvents.virtual[type] || view.responds(type)\n\t\t\t\t\t\t|| tool && tool.responds(type);\n\t\t\t}\n\n\t\t\tif (nativeMove && dragging && responds('mousedrag'))\n\t\t\t\ttype = 'mousedrag';\n\t\t\tif (!point)\n\t\t\t\tpoint = this.getEventPoint(event);\n\n\t\t\tvar inView = this.getBounds().contains(point),\n\t\t\t\thit = hitItems && inView && view._project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\thitItem = hit && hit.item || null,\n\t\t\t\thandle = false,\n\t\t\t\tmouse = {};\n\t\t\tmouse[type.substr(5)] = true;\n\n\t\t\tif (hitItems && hitItem !== overItem) {\n\t\t\t\tif (overItem) {\n\t\t\t\t\temitMouseEvent(overItem, null, 'mouseleave', event, point);\n\t\t\t\t}\n\t\t\t\tif (hitItem) {\n\t\t\t\t\temitMouseEvent(hitItem, null, 'mouseenter', event, point);\n\t\t\t\t}\n\t\t\t\toverItem = hitItem;\n\t\t\t}\n\t\t\tif (wasInView ^ inView) {\n\t\t\t\temitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',\n\t\t\t\t\t\tevent, point);\n\t\t\t\toverView = inView ? this : null;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tif ((inView || mouse.drag) && !point.equals(lastPoint)) {\n\t\t\t\temitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',\n\t\t\t\t\t\tevent, point, lastPoint);\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\twasInView = inView;\n\t\t\tif (mouse.down && inView || mouse.up && downPoint) {\n\t\t\t\temitMouseEvents(this, hitItem, type, event, point, downPoint);\n\t\t\t\tif (mouse.down) {\n\t\t\t\t\tdblClick = hitItem === clickItem\n\t\t\t\t\t\t&& (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = clickItem = hitItem;\n\t\t\t\t\tif (!prevented && hitItem) {\n\t\t\t\t\t\tvar item = hitItem;\n\t\t\t\t\t\twhile (item && !item.responds('mousedrag'))\n\t\t\t\t\t\t\titem = item._parent;\n\t\t\t\t\t\tif (item)\n\t\t\t\t\t\t\tdragItem = hitItem;\n\t\t\t\t\t}\n\t\t\t\t\tdownPoint = point;\n\t\t\t\t} else if (mouse.up) {\n\t\t\t\t\tif (!prevented && hitItem === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\temitMouseEvents(this, hitItem, dblClick ? 'doubleclick'\n\t\t\t\t\t\t\t\t: 'click', event, point, downPoint);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t}\n\t\t\t\twasInView = false;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tlastPoint = point;\n\t\t\tif (handle && tool) {\n\t\t\t\tcalled = tool._handleMouseEvent(type, event, point, mouse)\n\t\t\t\t\t|| called;\n\t\t\t}\n\n\t\t\tif (called && !mouse.move || mouse.down && responds('mouseup'))\n\t\t\t\tevent.preventDefault();\n\t\t},\n\n\t\t_handleKeyEvent: function(type, event, key, character) {\n\t\t\tvar scope = this._scope,\n\t\t\t\ttool = scope.tool,\n\t\t\t\tkeyEvent;\n\n\t\t\tfunction emit(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tpaper = scope;\n\t\t\t\t\tobj.emit(type, keyEvent = keyEvent\n\t\t\t\t\t\t\t|| new KeyEvent(type, event, key, character));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isVisible()) {\n\t\t\t\temit(this);\n\t\t\t\tif (tool && tool.responds(type))\n\t\t\t\t\temit(tool);\n\t\t\t}\n\t\t},\n\n\t\t_countItemEvent: function(type, sign) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\tnative = itemEvents.native,\n\t\t\t\tvirtual = itemEvents.virtual;\n\t\t\tfor (var key in itemEventsMap) {\n\t\t\t\tnative[key] = (native[key] || 0)\n\t\t\t\t\t\t+ (itemEventsMap[key][type] || 0) * sign;\n\t\t\t}\n\t\t\tvirtual[type] = (virtual[type] || 0) + sign;\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof window.HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ Base.slice(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tvar ctx = this._context = canvas.getContext('2d');\n\t\tctx.save();\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(ctx,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t\tthis._needsUpdate = true;\n\t},\n\n\tremove: function remove() {\n\t\tthis._context.restore();\n\t\treturn remove.base.call(this);\n\t},\n\n\t_setElementSize: function _setElementSize(width, height) {\n\t\tvar pixelRatio = this._pixelRatio;\n\t\t_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n\t\tif (pixelRatio !== 1) {\n\t\t\tvar element = this._element,\n\t\t\t\tctx = this._context;\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\tctx.save();\n\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetPixelSize: function getPixelSize(size) {\n\t\tvar agent = paper.agent,\n\t\t\tpixels;\n\t\tif (agent && agent.firefox) {\n\t\t\tpixels = getPixelSize.base.call(this, size);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function() {\n\t\tif (!this._needsUpdate)\n\t\t\treturn false;\n\t\tvar project = this._project,\n\t\t\tctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tif (project)\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tthis._needsUpdate = false;\n\t\treturn true;\n\t}\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t\tthis.type = event && event.type;\n\t},\n\n\tprevented: false,\n\tstopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.prevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.stopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetTimeStamp: function() {\n\t\treturn this.event.timeStamp;\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(type, event, key, character) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\tvar keyLookup = {\n\t\t\t'\\t': 'tab',\n\t\t\t' ': 'space',\n\t\t\t'\\b': 'backspace',\n\t\t\t'\\x7f': 'delete',\n\t\t\t'Spacebar': 'space',\n\t\t\t'Del': 'delete',\n\t\t\t'Win': 'meta',\n\t\t\t'Esc': 'escape'\n\t\t},\n\n\t\tcharLookup = {\n\t\t\t'tab': '\\t',\n\t\t\t'space': ' ',\n\t\t\t'enter': '\\r'\n\t\t},\n\n\t\tkeyMap = {},\n\t\tcharMap = {},\n\t\tmetaFixMap,\n\t\tdownKey,\n\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\talt: false,\n\t\t\tmeta: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}).inject({\n\t\t\toption: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.alt;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcommand: {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar agent = paper && paper.agent;\n\t\t\t\t\treturn agent && agent.mac ? this.meta : this.control;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tfunction getKey(event) {\n\t\tvar key = event.key || event.keyIdentifier;\n\t\tkey = /^U\\+/.test(key)\n\t\t\t\t? String.fromCharCode(parseInt(key.substr(2), 16))\n\t\t\t\t: /^Arrow[A-Z]/.test(key) ? key.substr(5)\n\t\t\t\t: key === 'Unidentified' ? String.fromCharCode(event.keyCode)\n\t\t\t\t: key;\n\t\treturn keyLookup[key] ||\n\t\t\t\t(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n\t}\n\n\tfunction handleKey(down, key, character, event) {\n\t\tvar type = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharMap[key] = character;\n\t\t} else {\n\t\t\tdelete charMap[key];\n\t\t}\n\t\tif (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar agent = paper && paper.agent;\n\t\t\tif (name === 'meta' && agent && agent.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tmetaFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var k in metaFixMap) {\n\t\t\t\t\t\tif (k in charMap)\n\t\t\t\t\t\t\thandleKey(false, k, metaFixMap[k], event);\n\t\t\t\t\t}\n\t\t\t\t\tmetaFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && metaFixMap) {\n\t\t\tmetaFixMap[key] = character;\n\t\t}\n\t\tif (view) {\n\t\t\tview._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,\n\t\t\t\t\tcharacter);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar key = getKey(event),\n\t\t\t\tagent = paper && paper.agent;\n\t\t\tif (key.length > 1 || agent && (agent.chrome && (event.altKey\n\t\t\t\t\t\t|| agent.mac && event.metaKey\n\t\t\t\t\t\t|| !agent.mac && event.ctrlKey))) {\n\t\t\t\thandleKey(true, key,\n\t\t\t\t\t\tcharLookup[key] || (key.length > 1 ? '' : key), event);\n\t\t\t} else {\n\t\t\t\tdownKey = key;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downKey) {\n\t\t\t\tvar key = getKey(event),\n\t\t\t\t\tcode = event.charCode,\n\t\t\t\t\tcharacter = code >= 32 ? String.fromCharCode(code)\n\t\t\t\t\t\t: key.length > 1 ? '' : key;\n\t\t\t\tif (key !== downKey) {\n\t\t\t\t\tkey = character.toLowerCase();\n\t\t\t\t}\n\t\t\t\thandleKey(true, key, character, event);\n\t\t\t\tdownKey = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar key = getKey(event);\n\t\t\tif (key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn this.tool[/^mouse(down|up)$/.test(this.type)\n\t\t\t\t? '_downCount' : '_moveCount'];\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',\n\t\t\t'onKeyUp'],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._moveCount = -1;\n\t\tthis._downCount = -1;\n\t\tthis.set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_handleMouseEvent: function(type, event, point, mouse) {\n\t\tpaper = this._scope;\n\t\tif (mouse.drag && !this.responds(type))\n\t\t\ttype = 'mousemove';\n\t\tvar move = mouse.move || mouse.drag,\n\t\t\tresponds = this.responds(type),\n\t\t\tminDistance = this.minDistance,\n\t\t\tmaxDistance = this.maxDistance,\n\t\t\tcalled = false,\n\t\t\ttool = this;\n\t\tfunction update(minDistance, maxDistance) {\n\t\t\tvar pt = point,\n\t\t\t\ttoolPoint = move ? tool._point : (tool._downPoint || pt);\n\t\t\tif (move) {\n\t\t\t\tif (tool._moveCount && pt.equals(toolPoint)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (toolPoint && (minDistance != null || maxDistance != null)) {\n\t\t\t\t\tvar vector = pt.subtract(toolPoint),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < (minDistance || 0))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance) {\n\t\t\t\t\t\tpt = toolPoint.add(vector.normalize(\n\t\t\t\t\t\t\t\tMath.min(distance, maxDistance)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttool._moveCount++;\n\t\t\t}\n\t\t\ttool._point = pt;\n\t\t\ttool._lastPoint = toolPoint || pt;\n\t\t\tif (mouse.down) {\n\t\t\t\ttool._moveCount = -1;\n\t\t\t\ttool._downPoint = pt;\n\t\t\t\ttool._downCount++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction emit() {\n\t\t\tif (responds) {\n\t\t\t\tcalled = tool.emit(type, new ToolEvent(tool, type, event))\n\t\t\t\t\t\t|| called;\n\t\t\t}\n\t\t}\n\n\t\tif (mouse.down) {\n\t\t\tupdate();\n\t\t\temit();\n\t\t} else if (mouse.up) {\n\t\t\tupdate(null, maxDistance);\n\t\t\temit();\n\t\t} else if (responds) {\n\t\t\twhile (update(minDistance, maxDistance))\n\t\t\t\temit();\n\t\t}\n\t\treturn called;\n\t}\n\n});\n\nvar Http = {\n\trequest: function(options) {\n\t\tvar xhr = new self.XMLHttpRequest();\n\t\txhr.open((options.method || 'get').toUpperCase(), options.url,\n\t\t\t\tBase.pick(options.async, true));\n\t\tif (options.mimeType)\n\t\t\txhr.overrideMimeType(options.mimeType);\n\t\txhr.onload = function() {\n\t\t\tvar status = xhr.status;\n\t\t\tif (status === 0 || status === 200) {\n\t\t\t\tif (options.onLoad) {\n\t\t\t\t\toptions.onLoad.call(xhr, xhr.responseText);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txhr.onerror();\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tvar status = xhr.status,\n\t\t\t\tmessage = 'Could not load \"' + options.url + '\" (Status: '\n\t\t\t\t\t\t+ status + ')';\n\t\t\tif (options.onError) {\n\t\t\t\toptions.onError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height) {\n\t\tif (!window)\n\t\t\treturn null;\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tclear = false;\n\t\t}\n\t\tvar ctx = canvas.getContext('2d');\n\t\tif (!ctx) {\n\t\t\tthrow new Error('Canvas ' + canvas +\n\t\t\t\t\t' is unable to provide a 2D context.');\n\t\t}\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height) {\n\t\tvar canvas = this.getCanvas(width, height);\n\t\treturn canvas ? canvas.getContext('2d') : null;\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj && obj.canvas ? obj.canvas : obj;\n\t\tif (canvas && canvas.getContext) {\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1);\n\tif (ctx) {\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken\n\t\t\t\t\t\t\t? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t}\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SvgElement = new function() {\n\tvar svg = 'http://www.w3.org/2000/svg',\n\t\txmlns = 'http://www.w3.org/2000/xmlns',\n\t\txlink = 'http://www.w3.org/1999/xlink',\n\t\tattributeNamespace = {\n\t\t\thref: xlink,\n\t\t\txlink: xmlns,\n\t\t\txmlns: xmlns + '/',\n\t\t\t'xmlns:xlink': xmlns + '/'\n\t\t};\n\n\tfunction create(tag, attributes, formatter) {\n\t\treturn set(document.createElementNS(svg, tag), attributes, formatter);\n\t}\n\n\tfunction get(node, name) {\n\t\tvar namespace = attributeNamespace[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\treturn value === 'null' ? null : value;\n\t}\n\n\tfunction set(node, attributes, formatter) {\n\t\tfor (var name in attributes) {\n\t\t\tvar value = attributes[name],\n\t\t\t\tnamespace = attributeNamespace[name];\n\t\t\tif (typeof value === 'number' && formatter)\n\t\t\t\tvalue = formatter.number(value);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, name, value);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\treturn {\n\t\tsvg: svg,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\n\t\tcreate: create,\n\t\tget: get,\n\t\tset: set\n\t};\n};\n\nvar SvgStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tfillRule: ['fill-rule', 'string'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'style']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nnew function() {\n\tvar formatter;\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tmatrix = matrix._shiftless();\n\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\ttrans = null;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling,\n\t\t\t\t\tskew = decomposed.skewing;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (skew.x)\n\t\t\t\t\tparts.push('skewX(' + formatter.number(skew.x) + ')');\n\t\t\t\tif (skew.y)\n\t\t\t\t\tparts.push('skewY(' + formatter.number(skew.y) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = SvgElement.create('g', attrs, formatter);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = SvgElement.create('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tSvgElement.set(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages == false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn SvgElement.create('image', attrs, formatter);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\tlength = segments.length,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (matchShapes && length >= 2 && !item.hasHandles()) {\n\t\t\tif (length > 2) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t}\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar start = segments[0]._point,\n\t\t\t\t\tend = segments[1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: end.x,\n\t\t\t\t\ty2: end.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn SvgElement.create('path', attrs, formatter);\n\t}\n\n\tfunction exportSymbolItem(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tdefinition = item._definition,\n\t\t\tnode = getDefinition(definition, 'symbol'),\n\t\t\tdefinitionItem = definition._item,\n\t\t\tbounds = definitionItem.getBounds();\n\t\tif (!node) {\n\t\t\tnode = SvgElement.create('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tnode.appendChild(exportSVG(definitionItem, options));\n\t\t\tsetDefinition(definition, node, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + node.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = bounds.width;\n\t\tattrs.height = bounds.height;\n\t\tattrs.overflow = 'visible';\n\t\treturn SvgElement.create('use', attrs, formatter);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin(),\n\t\t\t\tdestination = color.getDestination(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = SvgElement.create((radial ? 'radial' : 'linear')\n\t\t\t\t\t+ 'Gradient', attrs, formatter);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha(),\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: offset == null ? i / (l - 1) : offset\n\t\t\t\t};\n\t\t\t\tif (stopColor)\n\t\t\t\t\tattrs['stop-color'] = stopColor.toCSS(true);\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(\n\t\t\t\t\t\tSvgElement.create('stop', attrs, formatter));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = SvgElement.create('text', getTransform(item._matrix, true),\n\t\t\t\tformatter);\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tSymbolItem: exportSymbolItem,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent(),\n\t\t\tstyle = [];\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SvgStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tif (type === 'style') {\n\t\t\t\t\tstyle.push(entry.attribute + ': ' + value);\n\t\t\t\t} else {\n\t\t\t\t\tattrs[entry.attribute] = value == null ? 'none'\n\t\t\t\t\t\t\t: type === 'color' ? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array' ? value.join(',')\n\t\t\t\t\t\t\t: type === 'lookup' ? entry.toSVG[value]\n\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (style.length)\n\t\t\tattrs.style = style.join(';');\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn SvgElement.set(node, attrs, formatter);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-'\n\t\t\t\t+ (item._id || item.__id || (item.__id = UID.get('svg')))];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + typeId;\n\t\tdefinitions.svgs[type + '-' + (item._id || item.__id)] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = SvgElement.create('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(SvgElement.create('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new self.XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar children = this._children,\n\t\t\t\tview = this.getView(),\n\t\t\t\tbounds = Base.pick(options.bounds, 'view'),\n\t\t\t\tmx = options.matrix || bounds === 'view' && view._matrix,\n\t\t\t\tmatrix = mx && Matrix.read([mx]),\n\t\t\t\trect = bounds === 'view'\n\t\t\t\t\t? new Rectangle([0, 0], view.getViewSize())\n\t\t\t\t\t: bounds === 'content'\n\t\t\t\t\t\t? Item._getBounds(children, matrix, { stroke: true })\n\t\t\t\t\t\t\t.rect\n\t\t\t\t\t\t: Rectangle.read([bounds], 0, { readNull: true }),\n\t\t\t\tattrs = {\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: SvgElement.svg,\n\t\t\t\t\t'xmlns:xlink': SvgElement.xlink,\n\t\t\t\t};\n\t\t\tif (rect) {\n\t\t\t\tattrs.width = rect.width;\n\t\t\t\tattrs.height = rect.height;\n\t\t\t\tif (rect.x || rect.y)\n\t\t\t\t\tattrs.viewBox = formatter.rectangle(rect);\n\t\t\t}\n\t\t\tvar node = SvgElement.create('svg', attrs, formatter),\n\t\t\t\tparent = node;\n\t\t\tif (matrix && !matrix.isIdentity()) {\n\t\t\t\tparent = node.appendChild(SvgElement.create('g',\n\t\t\t\t\t\tgetTransform(matrix), formatter));\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tparent.appendChild(exportSVG(children[i], options, true));\n\t\t\t}\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tvar definitions = {},\n\t\trootSize;\n\n\tfunction getValue(node, name, isString, allowNull, allowPercent) {\n\t\tvar value = SvgElement.get(node, name),\n\t\t\tres = value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString ? '' : 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t\treturn /%\\s*$/.test(value)\n\t\t\t? (res / 100) * (allowPercent ? 1\n\t\t\t\t: rootSize[/x|^width/.test(name) ? 'width' : 'height'])\n\t\t\t: res;\n\t}\n\n\tfunction getPoint(node, x, y, allowNull, allowPercent) {\n\t\tx = getValue(node, x || 'x', false, allowNull, allowPercent);\n\t\ty = getValue(node, y || 'y', false, allowNull, allowPercent);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull, allowPercent) {\n\t\tw = getValue(node, w || 'width', false, allowNull, allowPercent);\n\t\th = getValue(node, h || 'height', false, allowNull, allowPercent);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none' ? null\n\t\t\t\t: type === 'number' ? parseFloat(value)\n\t\t\t\t: type === 'array' ?\n\t\t\t\t\tvalue ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t: type === 'color' ? getDefinition(value) || value\n\t\t\t\t: type === 'lookup' ? lookup[value]\n\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\tisDefs = type === 'defs',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip && !isDefs) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportNode(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& !/^defs$/i.test(childNode.nodeName)\n\t\t\t\t\t&& (child = importNode(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof SymbolDefinition))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || isDefs) {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\treturn PathItem.create(node.getAttribute('d'));\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tradial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t\tif (gradient._radial ^ radial) {\n\t\t\t\tgradient = gradient.clone();\n\t\t\t\tgradient._radial = radial;\n\t\t\t}\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, radial);\n\t\t}\n\t\tvar origin, destination, highlight,\n\t\t\tscaleToBounds = getValue(node, 'gradientUnits', true) !==\n\t\t\t\t'userSpaceOnUse';\n\t\tif (radial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy', false, scaleToBounds);\n\t\t\tdestination = origin.add(\n\t\t\t\t\tgetValue(node, 'r', false, false, scaleToBounds), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1', false, scaleToBounds);\n\t\t\tdestination = getPoint(node, 'x2', 'y2', false, scaleToBounds);\n\t\t}\n\t\tvar color = applyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\tcolor._scaleToBounds = scaleToBounds;\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\treturn importNode(child, options, isRoot);\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node);\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\tgetPoint(node).add(size.divide(2)));\n\t\t\t\tthis.translate(center);\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new SymbolDefinition(\n\t\t\t\t\timportGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node);\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof SymbolDefinition\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(\n\t\t\t\t\tgetPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\treturn new Shape.Rectangle(new Rectangle(\n\t\t\t\t\t\tgetPoint(node),\n\t\t\t\t\t\tgetSize(node)\n\t\t\t\t\t), getSize(node, 'rx', 'ry'));\n\t\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(\n\t\t\t\t\tgetPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node).add(\n\t\t\t\t\tgetPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t}\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tif (item.transform) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.append(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',\n\t\t\tcolor = item[key] && item[key]();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SvgStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\tif (item[entry.set]) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color') {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tif (color._scaleToBounds) {\n\t\t\t\t\t\t\tvar bounds = item.getBounds();\n\t\t\t\t\t\t\tcolor.transform(new Matrix()\n\t\t\t\t\t\t\t\t.translate(bounds.getPoint())\n\t\t\t\t\t\t\t\t.scale(bounds.getSize()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tif (item.setOffset) {\n\t\t\t\tvar percent = value.match(/(.*)%$/);\n\t\t\t\titem.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n\t\t\t}\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, null, null, true),\n\t\t\t\tgroup,\n\t\t\t\tmatrix;\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? size.divide(rect.getSize()) : 1,\n\t\t\t\tmatrix = new Matrix().scale(scale)\n\t\t\t\t\t\t.translate(rect.getPoint().negate());\n\t\t\t\tgroup = item;\n\t\t\t} else if (item instanceof SymbolDefinition) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tgroup = item._item;\n\t\t\t}\n\t\t\tif (group)  {\n\t\t\t\tif (getAttribute(node, 'overflow', styles) !== 'visible') {\n\t\t\t\t\tvar clip = new Shape.Rectangle(rect);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t\tif (matrix)\n\t\t\t\t\tgroup.transform(matrix);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value ? undefined\n\t\t\t\t: value === 'none' ? null\n\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tif (node.style) {\n\t\t\tvar parent = node.parentNode,\n\t\t\t\tstyles = {\n\t\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\t\tparent: !isRoot && !/^defs$/i.test(parent.tagName)\n\t\t\t\t\t\t\t&& DomElement.getStyles(parent) || {}\n\t\t\t\t};\n\t\t\tBase.each(attributes, function(apply, name) {\n\t\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\t\titem = value !== undefined\n\t\t\t\t\t\t&& apply(item, value, name, node, styles) || item;\n\t\t\t});\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/),\n\t\t\tname = match && match[1],\n\t\t\tres = name && definitions[window\n\t\t\t\t\t? name.replace(window.location.href.split('#')[0] + '#', '')\n\t\t\t\t\t: name];\n\t\tif (res && res._scaleToBounds) {\n\t\t\tres = res.clone();\n\t\t\tres._scaleToBounds = true;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction importNode(node, options, isRoot) {\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\tisElement = type !== '#document',\n\t\t\tbody = document.body,\n\t\t\tcontainer,\n\t\t\tparent,\n\t\t\tnext;\n\t\tif (isRoot && isElement) {\n\t\t\trootSize = paper.getView().getSize();\n\t\t\trootSize = getSize(node, null, null, true) || rootSize;\n\t\t\tcontainer = SvgElement.create('svg', {\n\t\t\t\tstyle: 'stroke-width: 1px; stroke-miterlimit: 10'\n\t\t\t});\n\t\t\tparent = node.parentNode;\n\t\t\tnext = node.nextSibling;\n\t\t\tcontainer.appendChild(node);\n\t\t\tbody.appendChild(container);\n\t\t}\n\t\tvar settings = paper.settings,\n\t\t\tapplyMatrix = settings.applyMatrix,\n\t\t\tinsertItems = settings.insertItems;\n\t\tsettings.applyMatrix = false;\n\t\tsettings.insertItems = false;\n\t\tvar importer = importers[type],\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.insertItems = insertItems;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (isElement && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport,\n\t\t\t\tdata = isElement && node.getAttribute('data-paper-data');\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (container) {\n\t\t\tbody.removeChild(container);\n\t\t\tif (parent) {\n\t\t\t\tif (next) {\n\t\t\t\t\tparent.insertBefore(node, next);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importSVG(source, options, owner) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\toptions = typeof options === 'function' ? { onLoad: options }\n\t\t\t\t: options || {};\n\t\tvar scope = paper,\n\t\t\titem = null;\n\n\t\tfunction onLoad(svg) {\n\t\t\ttry {\n\t\t\t\tvar node = typeof svg === 'object' ? svg : new self.DOMParser()\n\t\t\t\t\t\t.parseFromString(svg, 'image/svg+xml');\n\t\t\t\tif (!node.nodeName) {\n\t\t\t\t\tnode = null;\n\t\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\t\t}\n\t\t\t\tpaper = scope;\n\t\t\t\titem = importNode(node, options, true);\n\t\t\t\tif (!options || options.insert !== false) {\n\t\t\t\t\towner._insertItem(undefined, item);\n\t\t\t\t}\n\t\t\t\tvar onLoad = options.onLoad;\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad(item, svg);\n\t\t\t} catch (e) {\n\t\t\t\tonError(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction onError(message, status) {\n\t\t\tvar onError = options.onError;\n\t\t\tif (onError) {\n\t\t\t\tonError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\tvar node = document.getElementById(source);\n\t\t\tif (node) {\n\t\t\t\tonLoad(node);\n\t\t\t} else {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: source,\n\t\t\t\t\tasync: true,\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function() {\n\t\t\t\tonLoad(reader.result);\n\t\t\t};\n\t\t\treader.onerror = function() {\n\t\t\t\tonError(reader.error);\n\t\t\t};\n\t\t\treturn reader.readAsText(source);\n\t\t} else {\n\t\t\tonLoad(source);\n\t\t}\n\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = function() {\n\tvar global = this,\n\t\tacorn = global.acorn;\n\tif (!acorn && typeof require !== 'undefined') {\n\t\ttry { acorn = require('acorn'); } catch(e) {}\n\t}\n\tif (!acorn) {\n\t\tvar exports, module;\n\t\tacorn = exports = module = {};\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports);\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod);\n  mod(root.acorn || (root.acorn = {}));\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.0\";\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\treturn parseTopLevel(options.program);\n  };\n\n  var defaultOptions = exports.defaultOptions = {\n\tecmaVersion: 5,\n\tstrictSemicolons: false,\n\tallowTrailingCommas: true,\n\tforbidReserved: false,\n\tallowReturnOutsideFunction: false,\n\tlocations: false,\n\tonComment: null,\n\tranges: false,\n\tprogram: null,\n\tsourceFile: null,\n\tdirectSourceFile: null\n  };\n\n  function setOptions(opts) {\n\toptions = opts || {};\n\tfor (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n\t  options[opt] = defaultOptions[opt];\n\tsourceFile = options.sourceFile || null;\n  }\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n\tfor (var line = 1, cur = 0;;) {\n\t  lineBreak.lastIndex = cur;\n\t  var match = lineBreak.exec(input);\n\t  if (match && match.index < offset) {\n\t\t++line;\n\t\tcur = match.index + match[0].length;\n\t  } else break;\n\t}\n\treturn {line: line, column: offset - cur};\n  };\n\n  exports.tokenize = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\n\tvar t = {};\n\tfunction getToken(forceRegexp) {\n\t  lastEnd = tokEnd;\n\t  readToken(forceRegexp);\n\t  t.start = tokStart; t.end = tokEnd;\n\t  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n\t  t.type = tokType; t.value = tokVal;\n\t  return t;\n\t}\n\tgetToken.jumpTo = function(pos, reAllowed) {\n\t  tokPos = pos;\n\t  if (options.locations) {\n\t\ttokCurLine = 1;\n\t\ttokLineStart = lineBreak.lastIndex = 0;\n\t\tvar match;\n\t\twhile ((match = lineBreak.exec(input)) && match.index < pos) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = match.index + match[0].length;\n\t\t}\n\t  }\n\t  tokRegexpAllowed = reAllowed;\n\t  skipSpace();\n\t};\n\treturn getToken;\n  };\n\n  var tokPos;\n\n  var tokStart, tokEnd;\n\n  var tokStartLoc, tokEndLoc;\n\n  var tokType, tokVal;\n\n  var tokRegexpAllowed;\n\n  var tokCurLine, tokLineStart;\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  var inFunction, labels, strict;\n\n  function raise(pos, message) {\n\tvar loc = getLineInfo(input, pos);\n\tmessage += \" (\" + loc.line + \":\" + loc.column + \")\";\n\tvar err = new SyntaxError(message);\n\terr.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n\tthrow err;\n  }\n\n  var empty = [];\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n\t\t\t\t\t  \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n\t\t\t\t\t  \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n\t\t\t\t\t  \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n\t\t\t\t\t  \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n\t\t\t\t\t  \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n\t\t\t\t\t  \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n\t\t\t\t\t  \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n\t\t\t\t\t  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n\t\t\t\t\t  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n\t\t\t\t\t  num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  function makePredicate(words) {\n\twords = words.split(\" \");\n\tvar f = \"\", cats = [];\n\tout: for (var i = 0; i < words.length; ++i) {\n\t  for (var j = 0; j < cats.length; ++j)\n\t\tif (cats[j][0].length == words[i].length) {\n\t\t  cats[j].push(words[i]);\n\t\t  continue out;\n\t\t}\n\t  cats.push([words[i]]);\n\t}\n\tfunction compareTo(arr) {\n\t  if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n\t  f += \"switch(str){\";\n\t  for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n\t  f += \"return true}return false;\";\n\t}\n\n\tif (cats.length > 3) {\n\t  cats.sort(function(a, b) {return b.length - a.length;});\n\t  f += \"switch(str.length){\";\n\t  for (var i = 0; i < cats.length; ++i) {\n\t\tvar cat = cats[i];\n\t\tf += \"case \" + cat[0].length + \":\";\n\t\tcompareTo(cat);\n\t  }\n\t  f += \"}\";\n\n\t} else {\n\t  compareTo(words);\n\t}\n\treturn new Function(\"str\", f);\n  }\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n\tif (code < 65) return code === 36;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n\tif (code < 48) return code === 36;\n\tif (code < 58) return true;\n\tif (code < 65) return false;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  function line_loc_t() {\n\tthis.line = tokCurLine;\n\tthis.column = tokPos - tokLineStart;\n  }\n\n  function initTokenState() {\n\ttokCurLine = 1;\n\ttokPos = tokLineStart = 0;\n\ttokRegexpAllowed = true;\n\tskipSpace();\n  }\n\n  function finishToken(type, val) {\n\ttokEnd = tokPos;\n\tif (options.locations) tokEndLoc = new line_loc_t;\n\ttokType = type;\n\tskipSpace();\n\ttokVal = val;\n\ttokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n\tif (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n\ttokPos = end + 2;\n\tif (options.locations) {\n\t  lineBreak.lastIndex = start;\n\t  var match;\n\t  while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n\t\t++tokCurLine;\n\t\ttokLineStart = match.index + match[0].length;\n\t  }\n\t}\n\tif (options.onComment)\n\t  options.onComment(true, input.slice(start + 2, end), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n\tvar start = tokPos;\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar ch = input.charCodeAt(tokPos+=2);\n\twhile (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n\t  ++tokPos;\n\t  ch = input.charCodeAt(tokPos);\n\t}\n\tif (options.onComment)\n\t  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipSpace() {\n\twhile (tokPos < inputLen) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === 32) {\n\t\t++tokPos;\n\t  } else if (ch === 13) {\n\t\t++tokPos;\n\t\tvar next = input.charCodeAt(tokPos);\n\t\tif (next === 10) {\n\t\t  ++tokPos;\n\t\t}\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch === 10 || ch === 8232 || ch === 8233) {\n\t\t++tokPos;\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch > 8 && ch < 14) {\n\t\t++tokPos;\n\t  } else if (ch === 47) {\n\t\tvar next = input.charCodeAt(tokPos + 1);\n\t\tif (next === 42) {\n\t\t  skipBlockComment();\n\t\t} else if (next === 47) {\n\t\t  skipLineComment();\n\t\t} else break;\n\t  } else if (ch === 160) {\n\t\t++tokPos;\n\t  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t\t++tokPos;\n\t  } else {\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  function readToken_dot() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next >= 48 && next <= 57) return readNumber(true);\n\t++tokPos;\n\treturn finishToken(_dot);\n  }\n\n  function readToken_slash() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (tokRegexpAllowed) {++tokPos; return readRegexp();}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) {\n\t  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n\t\t  newline.test(input.slice(lastEnd, tokPos))) {\n\t\ttokPos += 3;\n\t\tskipLineComment();\n\t\tskipSpace();\n\t\treturn readToken();\n\t  }\n\t  return finishOp(_incDec, 2);\n\t}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tvar size = 1;\n\tif (next === code) {\n\t  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n\t  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n\t  return finishOp(_bitShift, size);\n\t}\n\tif (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n\t\tinput.charCodeAt(tokPos + 3) == 45) {\n\t  tokPos += 4;\n\t  skipLineComment();\n\t  skipSpace();\n\t  return readToken();\n\t}\n\tif (next === 61)\n\t  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n\treturn finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n\treturn finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n\tswitch(code) {\n\tcase 46:\n\t  return readToken_dot();\n\n\tcase 40: ++tokPos; return finishToken(_parenL);\n\tcase 41: ++tokPos; return finishToken(_parenR);\n\tcase 59: ++tokPos; return finishToken(_semi);\n\tcase 44: ++tokPos; return finishToken(_comma);\n\tcase 91: ++tokPos; return finishToken(_bracketL);\n\tcase 93: ++tokPos; return finishToken(_bracketR);\n\tcase 123: ++tokPos; return finishToken(_braceL);\n\tcase 125: ++tokPos; return finishToken(_braceR);\n\tcase 58: ++tokPos; return finishToken(_colon);\n\tcase 63: ++tokPos; return finishToken(_question);\n\n\tcase 48:\n\t  var next = input.charCodeAt(tokPos + 1);\n\t  if (next === 120 || next === 88) return readHexNumber();\n\tcase 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:\n\t  return readNumber(false);\n\n\tcase 34: case 39:\n\t  return readString(code);\n\n\tcase 47:\n\t  return readToken_slash(code);\n\n\tcase 37: case 42:\n\t  return readToken_mult_modulo();\n\n\tcase 124: case 38:\n\t  return readToken_pipe_amp(code);\n\n\tcase 94:\n\t  return readToken_caret();\n\n\tcase 43: case 45:\n\t  return readToken_plus_min(code);\n\n\tcase 60: case 62:\n\t  return readToken_lt_gt(code);\n\n\tcase 61: case 33:\n\t  return readToken_eq_excl(code);\n\n\tcase 126:\n\t  return finishOp(_prefix, 1);\n\t}\n\n\treturn false;\n  }\n\n  function readToken(forceRegexp) {\n\tif (!forceRegexp) tokStart = tokPos;\n\telse tokPos = tokStart + 1;\n\tif (options.locations) tokStartLoc = new line_loc_t;\n\tif (forceRegexp) return readRegexp();\n\tif (tokPos >= inputLen) return finishToken(_eof);\n\n\tvar code = input.charCodeAt(tokPos);\n\tif (isIdentifierStart(code) || code === 92 ) return readWord();\n\n\tvar tok = getTokenFromCode(code);\n\n\tif (tok === false) {\n\t  var ch = String.fromCharCode(code);\n\t  if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n\t  raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n\t}\n\treturn tok;\n  }\n\n  function finishOp(type, size) {\n\tvar str = input.slice(tokPos, tokPos + size);\n\ttokPos += size;\n\tfinishToken(type, str);\n  }\n\n  function readRegexp() {\n\tvar content = \"\", escaped, inClass, start = tokPos;\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n\t  var ch = input.charAt(tokPos);\n\t  if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n\t  if (!escaped) {\n\t\tif (ch === \"[\") inClass = true;\n\t\telse if (ch === \"]\" && inClass) inClass = false;\n\t\telse if (ch === \"/\" && !inClass) break;\n\t\tescaped = ch === \"\\\\\";\n\t  } else escaped = false;\n\t  ++tokPos;\n\t}\n\tvar content = input.slice(start, tokPos);\n\t++tokPos;\n\tvar mods = readWord1();\n\tif (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n\ttry {\n\t  var value = new RegExp(content, mods);\n\t} catch (e) {\n\t  if (e instanceof SyntaxError) raise(start, e.message);\n\t  raise(e);\n\t}\n\treturn finishToken(_regexp, value);\n  }\n\n  function readInt(radix, len) {\n\tvar start = tokPos, total = 0;\n\tfor (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t  var code = input.charCodeAt(tokPos), val;\n\t  if (code >= 97) val = code - 97 + 10;\n\t  else if (code >= 65) val = code - 65 + 10;\n\t  else if (code >= 48 && code <= 57) val = code - 48;\n\t  else val = Infinity;\n\t  if (val >= radix) break;\n\t  ++tokPos;\n\t  total = total * radix + val;\n\t}\n\tif (tokPos === start || len != null && tokPos - start !== len) return null;\n\n\treturn total;\n  }\n\n  function readHexNumber() {\n\ttokPos += 2;\n\tvar val = readInt(16);\n\tif (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\treturn finishToken(_num, val);\n  }\n\n  function readNumber(startsWithDot) {\n\tvar start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n\tif (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n\tif (input.charCodeAt(tokPos) === 46) {\n\t  ++tokPos;\n\t  readInt(10);\n\t  isFloat = true;\n\t}\n\tvar next = input.charCodeAt(tokPos);\n\tif (next === 69 || next === 101) {\n\t  next = input.charCodeAt(++tokPos);\n\t  if (next === 43 || next === 45) ++tokPos;\n\t  if (readInt(10) === null) raise(start, \"Invalid number\");\n\t  isFloat = true;\n\t}\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n\tvar str = input.slice(start, tokPos), val;\n\tif (isFloat) val = parseFloat(str);\n\telse if (!octal || str.length === 1) val = parseInt(str, 10);\n\telse if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n\telse val = parseInt(str, 8);\n\treturn finishToken(_num, val);\n  }\n\n  function readString(quote) {\n\ttokPos++;\n\tvar out = \"\";\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === quote) {\n\t\t++tokPos;\n\t\treturn finishToken(_string, out);\n\t  }\n\t  if (ch === 92) {\n\t\tch = input.charCodeAt(++tokPos);\n\t\tvar octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n\t\tif (octal) octal = octal[0];\n\t\twhile (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n\t\tif (octal === \"0\") octal = null;\n\t\t++tokPos;\n\t\tif (octal) {\n\t\t  if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n\t\t  out += String.fromCharCode(parseInt(octal, 8));\n\t\t  tokPos += octal.length - 1;\n\t\t} else {\n\t\t  switch (ch) {\n\t\t  case 110: out += \"\\n\"; break;\n\t\t  case 114: out += \"\\r\"; break;\n\t\t  case 120: out += String.fromCharCode(readHexChar(2)); break;\n\t\t  case 117: out += String.fromCharCode(readHexChar(4)); break;\n\t\t  case 85: out += String.fromCharCode(readHexChar(8)); break;\n\t\t  case 116: out += \"\\t\"; break;\n\t\t  case 98: out += \"\\b\"; break;\n\t\t  case 118: out += \"\\u000b\"; break;\n\t\t  case 102: out += \"\\f\"; break;\n\t\t  case 48: out += \"\\0\"; break;\n\t\t  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;\n\t\t  case 10:\n\t\t\tif (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n\t\t\tbreak;\n\t\t  default: out += String.fromCharCode(ch); break;\n\t\t  }\n\t\t}\n\t  } else {\n\t\tif (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n\t\tout += String.fromCharCode(ch);\n\t\t++tokPos;\n\t  }\n\t}\n  }\n\n  function readHexChar(len) {\n\tvar n = readInt(16, len);\n\tif (n === null) raise(tokStart, \"Bad character escape sequence\");\n\treturn n;\n  }\n\n  var containsEsc;\n\n  function readWord1() {\n\tcontainsEsc = false;\n\tvar word, first = true, start = tokPos;\n\tfor (;;) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (isIdentifierChar(ch)) {\n\t\tif (containsEsc) word += input.charAt(tokPos);\n\t\t++tokPos;\n\t  } else if (ch === 92) {\n\t\tif (!containsEsc) word = input.slice(start, tokPos);\n\t\tcontainsEsc = true;\n\t\tif (input.charCodeAt(++tokPos) != 117)\n\t\t  raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n\t\t++tokPos;\n\t\tvar esc = readHexChar(4);\n\t\tvar escStr = String.fromCharCode(esc);\n\t\tif (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n\t\tif (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n\t\t  raise(tokPos - 4, \"Invalid Unicode escape\");\n\t\tword += escStr;\n\t  } else {\n\t\tbreak;\n\t  }\n\t  first = false;\n\t}\n\treturn containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  function readWord() {\n\tvar word = readWord1();\n\tvar type = _name;\n\tif (!containsEsc && isKeyword(word))\n\t  type = keywordTypes[word];\n\treturn finishToken(type, word);\n  }\n\n  function next() {\n\tlastStart = tokStart;\n\tlastEnd = tokEnd;\n\tlastEndLoc = tokEndLoc;\n\treadToken();\n  }\n\n  function setStrict(strct) {\n\tstrict = strct;\n\ttokPos = tokStart;\n\tif (options.locations) {\n\t  while (tokPos < tokLineStart) {\n\t\ttokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n\t\t--tokCurLine;\n\t  }\n\t}\n\tskipSpace();\n\treadToken();\n  }\n\n  function node_t() {\n\tthis.type = null;\n\tthis.start = tokStart;\n\tthis.end = null;\n  }\n\n  function node_loc_t() {\n\tthis.start = tokStartLoc;\n\tthis.end = null;\n\tif (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n\tvar node = new node_t();\n\tif (options.locations)\n\t  node.loc = new node_loc_t();\n\tif (options.directSourceFile)\n\t  node.sourceFile = options.directSourceFile;\n\tif (options.ranges)\n\t  node.range = [tokStart, 0];\n\treturn node;\n  }\n\n  function startNodeFrom(other) {\n\tvar node = new node_t();\n\tnode.start = other.start;\n\tif (options.locations) {\n\t  node.loc = new node_loc_t();\n\t  node.loc.start = other.loc.start;\n\t}\n\tif (options.ranges)\n\t  node.range = [other.range[0], 0];\n\n\treturn node;\n  }\n\n  function finishNode(node, type) {\n\tnode.type = type;\n\tnode.end = lastEnd;\n\tif (options.locations)\n\t  node.loc.end = lastEndLoc;\n\tif (options.ranges)\n\t  node.range[1] = lastEnd;\n\treturn node;\n  }\n\n  function isUseStrict(stmt) {\n\treturn options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n\t  stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  function eat(type) {\n\tif (tokType === type) {\n\t  next();\n\t  return true;\n\t}\n  }\n\n  function canInsertSemicolon() {\n\treturn !options.strictSemicolons &&\n\t  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  function semicolon() {\n\tif (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  function expect(type) {\n\tif (tokType === type) next();\n\telse unexpected();\n  }\n\n  function unexpected() {\n\traise(tokStart, \"Unexpected token\");\n  }\n\n  function checkLVal(expr) {\n\tif (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n\t  raise(expr.start, \"Assigning to rvalue\");\n\tif (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n\t  raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  function parseTopLevel(program) {\n\tlastStart = lastEnd = tokPos;\n\tif (options.locations) lastEndLoc = new line_loc_t;\n\tinFunction = strict = null;\n\tlabels = [];\n\treadToken();\n\n\tvar node = program || startNode(), first = true;\n\tif (!program) node.body = [];\n\twhile (tokType !== _eof) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && isUseStrict(stmt)) setStrict(true);\n\t  first = false;\n\t}\n\treturn finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  function parseStatement() {\n\tif (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n\t  readToken(true);\n\n\tvar starttype = tokType, node = startNode();\n\n\tswitch (starttype) {\n\tcase _break: case _continue:\n\t  next();\n\t  var isBreak = starttype === _break;\n\t  if (eat(_semi) || canInsertSemicolon()) node.label = null;\n\t  else if (tokType !== _name) unexpected();\n\t  else {\n\t\tnode.label = parseIdent();\n\t\tsemicolon();\n\t  }\n\n\t  for (var i = 0; i < labels.length; ++i) {\n\t\tvar lab = labels[i];\n\t\tif (node.label == null || lab.name === node.label.name) {\n\t\t  if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n\t\t  if (node.label && isBreak) break;\n\t\t}\n\t  }\n\t  if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n\t  return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n\tcase _debugger:\n\t  next();\n\t  semicolon();\n\t  return finishNode(node, \"DebuggerStatement\");\n\n\tcase _do:\n\t  next();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  expect(_while);\n\t  node.test = parseParenExpression();\n\t  semicolon();\n\t  return finishNode(node, \"DoWhileStatement\");\n\n\tcase _for:\n\t  next();\n\t  labels.push(loopLabel);\n\t  expect(_parenL);\n\t  if (tokType === _semi) return parseFor(node, null);\n\t  if (tokType === _var) {\n\t\tvar init = startNode();\n\t\tnext();\n\t\tparseVar(init, true);\n\t\tfinishNode(init, \"VariableDeclaration\");\n\t\tif (init.declarations.length === 1 && eat(_in))\n\t\t  return parseForIn(node, init);\n\t\treturn parseFor(node, init);\n\t  }\n\t  var init = parseExpression(false, true);\n\t  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n\t  return parseFor(node, init);\n\n\tcase _function:\n\t  next();\n\t  return parseFunction(node, true);\n\n\tcase _if:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  node.consequent = parseStatement();\n\t  node.alternate = eat(_else) ? parseStatement() : null;\n\t  return finishNode(node, \"IfStatement\");\n\n\tcase _return:\n\t  if (!inFunction && !options.allowReturnOutsideFunction)\n\t\traise(tokStart, \"'return' outside of function\");\n\t  next();\n\n\t  if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n\t  else { node.argument = parseExpression(); semicolon(); }\n\t  return finishNode(node, \"ReturnStatement\");\n\n\tcase _switch:\n\t  next();\n\t  node.discriminant = parseParenExpression();\n\t  node.cases = [];\n\t  expect(_braceL);\n\t  labels.push(switchLabel);\n\n\t  for (var cur, sawDefault; tokType != _braceR;) {\n\t\tif (tokType === _case || tokType === _default) {\n\t\t  var isCase = tokType === _case;\n\t\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t\t  node.cases.push(cur = startNode());\n\t\t  cur.consequent = [];\n\t\t  next();\n\t\t  if (isCase) cur.test = parseExpression();\n\t\t  else {\n\t\t\tif (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n\t\t\tcur.test = null;\n\t\t  }\n\t\t  expect(_colon);\n\t\t} else {\n\t\t  if (!cur) unexpected();\n\t\t  cur.consequent.push(parseStatement());\n\t\t}\n\t  }\n\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t  next();\n\t  labels.pop();\n\t  return finishNode(node, \"SwitchStatement\");\n\n\tcase _throw:\n\t  next();\n\t  if (newline.test(input.slice(lastEnd, tokStart)))\n\t\traise(lastEnd, \"Illegal newline after throw\");\n\t  node.argument = parseExpression();\n\t  semicolon();\n\t  return finishNode(node, \"ThrowStatement\");\n\n\tcase _try:\n\t  next();\n\t  node.block = parseBlock();\n\t  node.handler = null;\n\t  if (tokType === _catch) {\n\t\tvar clause = startNode();\n\t\tnext();\n\t\texpect(_parenL);\n\t\tclause.param = parseIdent();\n\t\tif (strict && isStrictBadIdWord(clause.param.name))\n\t\t  raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n\t\texpect(_parenR);\n\t\tclause.guard = null;\n\t\tclause.body = parseBlock();\n\t\tnode.handler = finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.guardedHandlers = empty;\n\t  node.finalizer = eat(_finally) ? parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t\traise(node.start, \"Missing catch or finally clause\");\n\t  return finishNode(node, \"TryStatement\");\n\n\tcase _var:\n\t  next();\n\t  parseVar(node);\n\t  semicolon();\n\t  return finishNode(node, \"VariableDeclaration\");\n\n\tcase _while:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  return finishNode(node, \"WhileStatement\");\n\n\tcase _with:\n\t  if (strict) raise(tokStart, \"'with' in strict mode\");\n\t  next();\n\t  node.object = parseParenExpression();\n\t  node.body = parseStatement();\n\t  return finishNode(node, \"WithStatement\");\n\n\tcase _braceL:\n\t  return parseBlock();\n\n\tcase _semi:\n\t  next();\n\t  return finishNode(node, \"EmptyStatement\");\n\n\tdefault:\n\t  var maybeName = tokVal, expr = parseExpression();\n\t  if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n\t\tfor (var i = 0; i < labels.length; ++i)\n\t\t  if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t\tvar kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n\t\tlabels.push({name: maybeName, kind: kind});\n\t\tnode.body = parseStatement();\n\t\tlabels.pop();\n\t\tnode.label = expr;\n\t\treturn finishNode(node, \"LabeledStatement\");\n\t  } else {\n\t\tnode.expression = expr;\n\t\tsemicolon();\n\t\treturn finishNode(node, \"ExpressionStatement\");\n\t  }\n\t}\n  }\n\n  function parseParenExpression() {\n\texpect(_parenL);\n\tvar val = parseExpression();\n\texpect(_parenR);\n\treturn val;\n  }\n\n  function parseBlock(allowStrict) {\n\tvar node = startNode(), first = true, strict = false, oldStrict;\n\tnode.body = [];\n\texpect(_braceL);\n\twhile (!eat(_braceR)) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && allowStrict && isUseStrict(stmt)) {\n\t\toldStrict = strict;\n\t\tsetStrict(strict = true);\n\t  }\n\t  first = false;\n\t}\n\tif (strict && !oldStrict) setStrict(false);\n\treturn finishNode(node, \"BlockStatement\");\n  }\n\n  function parseFor(node, init) {\n\tnode.init = init;\n\texpect(_semi);\n\tnode.test = tokType === _semi ? null : parseExpression();\n\texpect(_semi);\n\tnode.update = tokType === _parenR ? null : parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForStatement\");\n  }\n\n  function parseForIn(node, init) {\n\tnode.left = init;\n\tnode.right = parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForInStatement\");\n  }\n\n  function parseVar(node, noIn) {\n\tnode.declarations = [];\n\tnode.kind = \"var\";\n\tfor (;;) {\n\t  var decl = startNode();\n\t  decl.id = parseIdent();\n\t  if (strict && isStrictBadIdWord(decl.id.name))\n\t\traise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n\t  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n\t  node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n\t  if (!eat(_comma)) break;\n\t}\n\treturn node;\n  }\n\n  function parseExpression(noComma, noIn) {\n\tvar expr = parseMaybeAssign(noIn);\n\tif (!noComma && tokType === _comma) {\n\t  var node = startNodeFrom(expr);\n\t  node.expressions = [expr];\n\t  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n\t  return finishNode(node, \"SequenceExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseMaybeAssign(noIn) {\n\tvar left = parseMaybeConditional(noIn);\n\tif (tokType.isAssign) {\n\t  var node = startNodeFrom(left);\n\t  node.operator = tokVal;\n\t  node.left = left;\n\t  next();\n\t  node.right = parseMaybeAssign(noIn);\n\t  checkLVal(left);\n\t  return finishNode(node, \"AssignmentExpression\");\n\t}\n\treturn left;\n  }\n\n  function parseMaybeConditional(noIn) {\n\tvar expr = parseExprOps(noIn);\n\tif (eat(_question)) {\n\t  var node = startNodeFrom(expr);\n\t  node.test = expr;\n\t  node.consequent = parseExpression(true);\n\t  expect(_colon);\n\t  node.alternate = parseExpression(true, noIn);\n\t  return finishNode(node, \"ConditionalExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprOps(noIn) {\n\treturn parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  function parseExprOp(left, minPrec, noIn) {\n\tvar prec = tokType.binop;\n\tif (prec != null && (!noIn || tokType !== _in)) {\n\t  if (prec > minPrec) {\n\t\tvar node = startNodeFrom(left);\n\t\tnode.left = left;\n\t\tnode.operator = tokVal;\n\t\tvar op = tokType;\n\t\tnext();\n\t\tnode.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n\t\tvar exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n\t\treturn parseExprOp(exprNode, minPrec, noIn);\n\t  }\n\t}\n\treturn left;\n  }\n\n  function parseMaybeUnary() {\n\tif (tokType.prefix) {\n\t  var node = startNode(), update = tokType.isUpdate;\n\t  node.operator = tokVal;\n\t  node.prefix = true;\n\t  tokRegexpAllowed = true;\n\t  next();\n\t  node.argument = parseMaybeUnary();\n\t  if (update) checkLVal(node.argument);\n\t  else if (strict && node.operator === \"delete\" &&\n\t\t\t   node.argument.type === \"Identifier\")\n\t\traise(node.start, \"Deleting local variable in strict mode\");\n\t  return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t}\n\tvar expr = parseExprSubscripts();\n\twhile (tokType.postfix && !canInsertSemicolon()) {\n\t  var node = startNodeFrom(expr);\n\t  node.operator = tokVal;\n\t  node.prefix = false;\n\t  node.argument = expr;\n\t  checkLVal(expr);\n\t  next();\n\t  expr = finishNode(node, \"UpdateExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprSubscripts() {\n\treturn parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n\tif (eat(_dot)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseIdent(true);\n\t  node.computed = false;\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (eat(_bracketL)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseExpression();\n\t  node.computed = true;\n\t  expect(_bracketR);\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (!noCalls && eat(_parenL)) {\n\t  var node = startNodeFrom(base);\n\t  node.callee = base;\n\t  node.arguments = parseExprList(_parenR, false);\n\t  return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n\t} else return base;\n  }\n\n  function parseExprAtom() {\n\tswitch (tokType) {\n\tcase _this:\n\t  var node = startNode();\n\t  next();\n\t  return finishNode(node, \"ThisExpression\");\n\tcase _name:\n\t  return parseIdent();\n\tcase _num: case _string: case _regexp:\n\t  var node = startNode();\n\t  node.value = tokVal;\n\t  node.raw = input.slice(tokStart, tokEnd);\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _null: case _true: case _false:\n\t  var node = startNode();\n\t  node.value = tokType.atomValue;\n\t  node.raw = tokType.keyword;\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _parenL:\n\t  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n\t  next();\n\t  var val = parseExpression();\n\t  val.start = tokStart1;\n\t  val.end = tokEnd;\n\t  if (options.locations) {\n\t\tval.loc.start = tokStartLoc1;\n\t\tval.loc.end = tokEndLoc;\n\t  }\n\t  if (options.ranges)\n\t\tval.range = [tokStart1, tokEnd];\n\t  expect(_parenR);\n\t  return val;\n\n\tcase _bracketL:\n\t  var node = startNode();\n\t  next();\n\t  node.elements = parseExprList(_bracketR, true, true);\n\t  return finishNode(node, \"ArrayExpression\");\n\n\tcase _braceL:\n\t  return parseObj();\n\n\tcase _function:\n\t  var node = startNode();\n\t  next();\n\t  return parseFunction(node, false);\n\n\tcase _new:\n\t  return parseNew();\n\n\tdefault:\n\t  unexpected();\n\t}\n  }\n\n  function parseNew() {\n\tvar node = startNode();\n\tnext();\n\tnode.callee = parseSubscripts(parseExprAtom(), true);\n\tif (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n\telse node.arguments = empty;\n\treturn finishNode(node, \"NewExpression\");\n  }\n\n  function parseObj() {\n\tvar node = startNode(), first = true, sawGetSet = false;\n\tnode.properties = [];\n\tnext();\n\twhile (!eat(_braceR)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (options.allowTrailingCommas && eat(_braceR)) break;\n\t  } else first = false;\n\n\t  var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n\t  if (eat(_colon)) {\n\t\tprop.value = parseExpression(true);\n\t\tkind = prop.kind = \"init\";\n\t  } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n\t\t\t\t (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n\t\tisGetSet = sawGetSet = true;\n\t\tkind = prop.kind = prop.key.name;\n\t\tprop.key = parsePropertyName();\n\t\tif (tokType !== _parenL) unexpected();\n\t\tprop.value = parseFunction(startNode(), false);\n\t  } else unexpected();\n\n\t  if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n\t\tfor (var i = 0; i < node.properties.length; ++i) {\n\t\t  var other = node.properties[i];\n\t\t  if (other.key.name === prop.key.name) {\n\t\t\tvar conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n\t\t\t  kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n\t\t\tif (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n\t\t\tif (conflict) raise(prop.key.start, \"Redefinition of property\");\n\t\t  }\n\t\t}\n\t  }\n\t  node.properties.push(prop);\n\t}\n\treturn finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n\tif (tokType === _num || tokType === _string) return parseExprAtom();\n\treturn parseIdent(true);\n  }\n\n  function parseFunction(node, isStatement) {\n\tif (tokType === _name) node.id = parseIdent();\n\telse if (isStatement) unexpected();\n\telse node.id = null;\n\tnode.params = [];\n\tvar first = true;\n\texpect(_parenL);\n\twhile (!eat(_parenR)) {\n\t  if (!first) expect(_comma); else first = false;\n\t  node.params.push(parseIdent());\n\t}\n\n\tvar oldInFunc = inFunction, oldLabels = labels;\n\tinFunction = true; labels = [];\n\tnode.body = parseBlock(true);\n\tinFunction = oldInFunc; labels = oldLabels;\n\n\tif (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n\t  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n\t\tvar id = i < 0 ? node.id : node.params[i];\n\t\tif (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n\t\t  raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n\t\tif (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n\t\t  raise(id.start, \"Argument name clash in strict mode\");\n\t  }\n\t}\n\n\treturn finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n\tvar elts = [], first = true;\n\twhile (!eat(close)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n\t  } else first = false;\n\n\t  if (allowEmpty && tokType === _comma) elts.push(null);\n\t  else elts.push(parseExpression(true));\n\t}\n\treturn elts;\n  }\n\n  function parseIdent(liberal) {\n\tvar node = startNode();\n\tif (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n\tif (tokType === _name) {\n\t  if (!liberal &&\n\t\t  (options.forbidReserved &&\n\t\t   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||\n\t\t   strict && isStrictReservedWord(tokVal)) &&\n\t\t  input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n\t\traise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n\t  node.name = tokVal;\n\t} else if (liberal && tokType.keyword) {\n\t  node.name = tokType.keyword;\n\t} else {\n\t  unexpected();\n\t}\n\ttokRegexpAllowed = false;\n\tnext();\n\treturn finishNode(node, \"Identifier\");\n  }\n\n});\n\n\t\tif (!acorn.version)\n\t\t\tacorn = null;\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn (global.acorn || acorn).parse(code, options);\n\t}\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': '__equals',\n\t\t'!=': '__equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': '__self'\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{\n\t\t\t__self: function() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction compile(code, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction walkAST(node, parent) {\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tfor (var key in node) {\n\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar value = node[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\twalkAST(value, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\t\texp = left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')';\n\t\t\t\t\t\t\treplaceCode(node, /^\\(.*\\)$/.test(getCode(node))\n\t\t\t\t\t\t\t\t\t? '(' + exp + ')' : exp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction encodeVLQ(value) {\n\t\t\tvar res = '',\n\t\t\t\tbase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\tvalue = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n\t\t\twhile (value || !res) {\n\t\t\t\tvar next = value & (32 - 1);\n\t\t\t\tvalue >>= 5;\n\t\t\t\tif (value)\n\t\t\t\t\tnext |= 32;\n\t\t\t\tres += base64[next];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar url = options.url || '',\n\t\t\tagent = paper.agent,\n\t\t\tversion = agent.versionNumber,\n\t\t\toffsetCode = false,\n\t\t\tsourceMaps = options.sourceMaps,\n\t\t\tsource = options.source || code,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg,\n\t\t\toffset = options.offset || 0,\n\t\t\tmap;\n\t\tif (sourceMaps && (agent.chrome && version >= 30\n\t\t\t\t|| agent.webkit && version >= 537.76\n\t\t\t\t|| agent.firefox && version >= 23\n\t\t\t\t|| agent.node)) {\n\t\t\tif (agent.node) {\n\t\t\t\toffset -= 2;\n\t\t\t} else if (window && url && !window.location.href.indexOf(url)) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\toffsetCode = offset > 0 && !(\n\t\t\t\t\tagent.chrome && version >= 36 ||\n\t\t\t\t\tagent.safari && version >= 600 ||\n\t\t\t\t\tagent.firefox && version >= 40 ||\n\t\t\t\t\tagent.node);\n\t\t\tvar mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1\n\t\t\t\t\t+ (offsetCode ? offset : 0);\n\t\t\tmap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url],\n\t\t\t\tsourcesContent: [source]\n\t\t\t};\n\t\t}\n\t\twalkAST(parse(code, { ranges: true, preserveParens: true }));\n\t\tif (map) {\n\t\t\tif (offsetCode) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code;\n\t\t\t}\n\t\t\tif (/^(inline|both)$/.test(sourceMaps)) {\n\t\t\t\tcode += \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ self.btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(map))));\n\t\t\t}\n\t\t\tcode += \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn {\n\t\t\turl: url,\n\t\t\tsource: source,\n\t\t\tcode: code,\n\t\t\tmap: map\n\t\t};\n\t}\n\n\tfunction execute(code, scope, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/\n\t\t\t\t\t.test(code) && !/\\bnew\\s+Tool\\b/.test(code)\n\t\t\t\t\t\t? new Tool() : null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc,\n\t\t\tcompiled = typeof code === 'object' ? code : compile(code, options);\n\t\tcode = compiled.code;\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\thandlers = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t}\n\t\t}, []).join(', ');\n\t\tif (handlers)\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\tvar agent = paper.agent;\n\t\tif (document && (agent.chrome\n\t\t\t\t|| agent.firefox && agent.versionNumber < 40)) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (agent.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = paper._execute;\n\t\t\tdelete paper._execute;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar res = func.apply(scope, args) || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = res[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (res.onResize)\n\t\t\t\tview.setOnResize(res.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (res.onFrame)\n\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\tview.requestUpdate();\n\t\t}\n\t\treturn compiled;\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: src,\n\t\t\t\t\tasync: async,\n\t\t\t\t\tmimeType: 'text/plain',\n\t\t\t\t\tonLoad: function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document && document.getElementsByTagName('script'),\n\t\t\t\tloadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (window) {\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse\n\t};\n\n}.call(this);\n\npaper = new (PaperScope.inject(Base.exports, {\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key,\n\tDomEvent: DomEvent,\n\tDomElement: DomElement,\n\tdocument: document,\n\twindow: window,\n\tSymbol: SymbolDefinition,\n\tPlacedSymbol: SymbolItem\n}))();\n\nif (paper.agent.node) {\n\trequire('./node/extend.js')(paper);\n}\n\nif (typeof define === 'function' && define.amd) {\n\tdefine('paper', paper);\n} else if (typeof module === 'object' && module) {\n\tmodule.exports = paper;\n}\n\nreturn paper;\n}.call(this, typeof self === 'object' ? self : null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/paper/dist/paper-full.js\n// module id = 19\n// module chunks = 1"],"sourceRoot":""}